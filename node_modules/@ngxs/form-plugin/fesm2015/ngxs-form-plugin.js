import { Injectable, Directive, Input, ChangeDetectorRef, NgModule } from '@angular/core';
import { setValue, getActionTypeFromInstance, Store, getValue, NGXS_PLUGINS } from '@ngxs/store';
import { FormGroupDirective, ReactiveFormsModule } from '@angular/forms';
import { Subject } from 'rxjs';
import { takeUntil, debounceTime, first } from 'rxjs/operators';

class UpdateFormStatus {
    constructor(payload) {
        this.payload = payload;
    }
}
UpdateFormStatus.type = '[Forms] Update Form Status';
class UpdateFormValue {
    constructor(payload) {
        this.payload = payload;
    }
}
UpdateFormValue.type = '[Forms] Update Form Value';
class UpdateForm {
    constructor(payload) {
        this.payload = payload;
    }
}
UpdateForm.type = '[Forms] Update Form';
class UpdateFormDirty {
    constructor(payload) {
        this.payload = payload;
    }
}
UpdateFormDirty.type = '[Forms] Update Form Dirty';
class SetFormDirty {
    constructor(payload) {
        this.payload = payload;
    }
}
SetFormDirty.type = '[Forms] Set Form Dirty';
class SetFormPristine {
    constructor(payload) {
        this.payload = payload;
    }
}
SetFormPristine.type = '[Forms] Set Form Pristine';
class UpdateFormErrors {
    constructor(payload) {
        this.payload = payload;
    }
}
UpdateFormErrors.type = '[Forms] Update Form Errors';
class SetFormDisabled {
    constructor(payload) {
        this.payload = payload;
    }
}
SetFormDisabled.type = '[Forms] Set Form Disabled';
class SetFormEnabled {
    constructor(payload) {
        this.payload = payload;
    }
}
SetFormEnabled.type = '[Forms] Set Form Enabled';

class NgxsFormPlugin {
    constructor() { }
    handle(state, event, next) {
        const type = getActionTypeFromInstance(event);
        let nextState = state;
        if (type === UpdateFormValue.type || type === UpdateForm.type) {
            nextState = setValue(nextState, `${event.payload.path}.model`, Object.assign({}, event.payload.value));
        }
        if (type === UpdateFormStatus.type || type === UpdateForm.type) {
            nextState = setValue(nextState, `${event.payload.path}.status`, event.payload.status);
        }
        if (type === UpdateFormErrors.type || type === UpdateForm.type) {
            nextState = setValue(nextState, `${event.payload.path}.errors`, Object.assign({}, event.payload.errors));
        }
        if (type === UpdateFormDirty.type || type === UpdateForm.type) {
            nextState = setValue(nextState, `${event.payload.path}.dirty`, event.payload.dirty);
        }
        if (type === SetFormDirty.type) {
            nextState = setValue(nextState, `${event.payload}.dirty`, true);
        }
        if (type === SetFormPristine.type) {
            nextState = setValue(nextState, `${event.payload}.dirty`, false);
        }
        if (type === SetFormDisabled.type) {
            nextState = setValue(nextState, `${event.payload}.disabled`, true);
        }
        if (type === SetFormEnabled.type) {
            nextState = setValue(nextState, `${event.payload}.disabled`, false);
        }
        return next(nextState, event);
    }
}
NgxsFormPlugin.decorators = [
    { type: Injectable },
];
/** @nocollapse */
NgxsFormPlugin.ctorParameters = () => [];

class FormDirective {
    constructor(_store, _formGroupDirective, _cd) {
        this._store = _store;
        this._formGroupDirective = _formGroupDirective;
        this._cd = _cd;
        this.debounce = 100;
        this._destroy$ = new Subject();
        this._updating = false;
    }
    ngOnInit() {
        this._store
            .select(state => getValue(state, `${this.path}.model`))
            .pipe(takeUntil(this._destroy$))
            .subscribe(model => {
            if (!this._updating && model) {
                this._formGroupDirective.form.patchValue(model);
                this._cd.markForCheck();
            }
        });
        // On first state change, sync form model, status and dirty with state
        this._store
            .select(state => getValue(state, `${this.path}`))
            .pipe(takeUntil(this._destroy$), first())
            .subscribe(state => {
            this._store.dispatch([
                new UpdateFormValue({
                    path: this.path,
                    value: this._formGroupDirective.form.getRawValue()
                }),
                new UpdateFormStatus({
                    path: this.path,
                    status: this._formGroupDirective.form.status
                }),
                new UpdateFormDirty({
                    path: this.path,
                    dirty: this._formGroupDirective.form.dirty
                })
            ]);
        });
        this._store
            .select(state => getValue(state, `${this.path}.dirty`))
            .pipe(takeUntil(this._destroy$))
            .subscribe(dirty => {
            if (this._formGroupDirective.form.dirty !== dirty) {
                if (dirty === true) {
                    this._formGroupDirective.form.markAsDirty();
                    this._cd.markForCheck();
                }
                else if (dirty === false) {
                    this._formGroupDirective.form.markAsPristine();
                    this._cd.markForCheck();
                }
            }
        });
        this._store
            .select(state => getValue(state, `${this.path}.disabled`))
            .pipe(takeUntil(this._destroy$))
            .subscribe(disabled => {
            if (this._formGroupDirective.form.disabled !== disabled) {
                if (disabled === true) {
                    this._formGroupDirective.form.disable();
                    this._cd.markForCheck();
                }
                else if (disabled === false) {
                    this._formGroupDirective.form.enable();
                    this._cd.markForCheck();
                }
            }
        });
        this._formGroupDirective.valueChanges.pipe(debounceTime(this.debounce), takeUntil(this._destroy$)).subscribe(() => {
            const value = this._formGroupDirective.control.getRawValue();
            this._updating = true;
            this._store
                .dispatch([
                new UpdateFormValue({
                    path: this.path,
                    value
                }),
                new UpdateFormDirty({
                    path: this.path,
                    dirty: this._formGroupDirective.dirty
                }),
                new UpdateFormErrors({
                    path: this.path,
                    errors: this._formGroupDirective.errors
                })
            ])
                .subscribe({
                error: () => (this._updating = false),
                complete: () => (this._updating = false)
            });
        });
        this._formGroupDirective.statusChanges
            .pipe(debounceTime(this.debounce), takeUntil(this._destroy$))
            .subscribe((status) => {
            this._store.dispatch(new UpdateFormStatus({
                status,
                path: this.path
            }));
        });
    }
    ngOnDestroy() {
        this._destroy$.next();
        this._destroy$.complete();
        if (this.clearDestroy) {
            this._store.dispatch(new UpdateForm({
                path: this.path,
                value: null,
                dirty: null,
                status: null,
                errors: null
            }));
        }
    }
}
FormDirective.decorators = [
    { type: Directive, args: [{ selector: '[ngxsForm]' },] },
];
/** @nocollapse */
FormDirective.ctorParameters = () => [
    { type: Store, },
    { type: FormGroupDirective, },
    { type: ChangeDetectorRef, },
];
FormDirective.propDecorators = {
    "path": [{ type: Input, args: ['ngxsForm',] },],
    "debounce": [{ type: Input, args: ['ngxsFormDebounce',] },],
    "clearDestroy": [{ type: Input, args: ['ngxsFormClearOnDestroy',] },],
};

class NgxsFormPluginModule {
    static forRoot() {
        return {
            ngModule: NgxsFormPluginModule,
            providers: [
                {
                    provide: NGXS_PLUGINS,
                    useClass: NgxsFormPlugin,
                    multi: true
                }
            ]
        };
    }
}
NgxsFormPluginModule.decorators = [
    { type: NgModule, args: [{
                imports: [ReactiveFormsModule],
                declarations: [FormDirective],
                exports: [FormDirective]
            },] },
];

/**
 * Generated bundle index. Do not edit.
 */

export { FormDirective as Éµa, NgxsFormPluginModule, NgxsFormPlugin, UpdateFormStatus, UpdateFormValue, UpdateForm, UpdateFormDirty, SetFormDirty, SetFormPristine, UpdateFormErrors, SetFormDisabled, SetFormEnabled };
//# sourceMappingURL=ngxs-form-plugin.js.map
