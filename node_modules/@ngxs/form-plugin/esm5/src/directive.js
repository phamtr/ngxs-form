import { Directive, Input, ChangeDetectorRef } from '@angular/core';
import { FormGroupDirective } from '@angular/forms';
import { Store, getValue } from '@ngxs/store';
import { Subject } from 'rxjs';
import { takeUntil, debounceTime, first } from 'rxjs/operators';
import { UpdateFormStatus, UpdateFormValue, UpdateFormDirty, UpdateFormErrors, UpdateForm } from './actions';
var FormDirective = /** @class */ (function () {
    function FormDirective(_store, _formGroupDirective, _cd) {
        this._store = _store;
        this._formGroupDirective = _formGroupDirective;
        this._cd = _cd;
        this.debounce = 100;
        this._destroy$ = new Subject();
        this._updating = false;
    }
    FormDirective.prototype.ngOnInit = function () {
        var _this = this;
        this._store
            .select(function (state) { return getValue(state, _this.path + ".model"); })
            .pipe(takeUntil(this._destroy$))
            .subscribe(function (model) {
            if (!_this._updating && model) {
                _this._formGroupDirective.form.patchValue(model);
                _this._cd.markForCheck();
            }
        });
        // On first state change, sync form model, status and dirty with state
        this._store
            .select(function (state) { return getValue(state, "" + _this.path); })
            .pipe(takeUntil(this._destroy$), first())
            .subscribe(function (state) {
            _this._store.dispatch([
                new UpdateFormValue({
                    path: _this.path,
                    value: _this._formGroupDirective.form.getRawValue()
                }),
                new UpdateFormStatus({
                    path: _this.path,
                    status: _this._formGroupDirective.form.status
                }),
                new UpdateFormDirty({
                    path: _this.path,
                    dirty: _this._formGroupDirective.form.dirty
                })
            ]);
        });
        this._store
            .select(function (state) { return getValue(state, _this.path + ".dirty"); })
            .pipe(takeUntil(this._destroy$))
            .subscribe(function (dirty) {
            if (_this._formGroupDirective.form.dirty !== dirty) {
                if (dirty === true) {
                    _this._formGroupDirective.form.markAsDirty();
                    _this._cd.markForCheck();
                }
                else if (dirty === false) {
                    _this._formGroupDirective.form.markAsPristine();
                    _this._cd.markForCheck();
                }
            }
        });
        this._store
            .select(function (state) { return getValue(state, _this.path + ".disabled"); })
            .pipe(takeUntil(this._destroy$))
            .subscribe(function (disabled) {
            if (_this._formGroupDirective.form.disabled !== disabled) {
                if (disabled === true) {
                    _this._formGroupDirective.form.disable();
                    _this._cd.markForCheck();
                }
                else if (disabled === false) {
                    _this._formGroupDirective.form.enable();
                    _this._cd.markForCheck();
                }
            }
        });
        this._formGroupDirective.valueChanges.pipe(debounceTime(this.debounce), takeUntil(this._destroy$)).subscribe(function () {
            var value = _this._formGroupDirective.control.getRawValue();
            _this._updating = true;
            _this._store
                .dispatch([
                new UpdateFormValue({
                    path: _this.path,
                    value: value
                }),
                new UpdateFormDirty({
                    path: _this.path,
                    dirty: _this._formGroupDirective.dirty
                }),
                new UpdateFormErrors({
                    path: _this.path,
                    errors: _this._formGroupDirective.errors
                })
            ])
                .subscribe({
                error: function () { return (_this._updating = false); },
                complete: function () { return (_this._updating = false); }
            });
        });
        this._formGroupDirective.statusChanges
            .pipe(debounceTime(this.debounce), takeUntil(this._destroy$))
            .subscribe(function (status) {
            _this._store.dispatch(new UpdateFormStatus({
                status: status,
                path: _this.path
            }));
        });
    };
    FormDirective.prototype.ngOnDestroy = function () {
        this._destroy$.next();
        this._destroy$.complete();
        if (this.clearDestroy) {
            this._store.dispatch(new UpdateForm({
                path: this.path,
                value: null,
                dirty: null,
                status: null,
                errors: null
            }));
        }
    };
    return FormDirective;
}());
export { FormDirective };
FormDirective.decorators = [
    { type: Directive, args: [{ selector: '[ngxsForm]' },] },
];
/** @nocollapse */
FormDirective.ctorParameters = function () { return [
    { type: Store, },
    { type: FormGroupDirective, },
    { type: ChangeDetectorRef, },
]; };
FormDirective.propDecorators = {
    "path": [{ type: Input, args: ['ngxsForm',] },],
    "debounce": [{ type: Input, args: ['ngxsFormDebounce',] },],
    "clearDestroy": [{ type: Input, args: ['ngxsFormClearOnDestroy',] },],
};
//# sourceMappingURL=directive.js.map
