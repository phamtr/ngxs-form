/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, Directive, ElementRef, EventEmitter, HostBinding, HostListener, Input, Output, ViewEncapsulation, ContentChildren, NgZone, ViewChild, NgModule } from '@angular/core';
import { EventRegistry, toBoolean } from '@angular-mdc/web/common';
import { MdcRipple } from '@angular-mdc/web/ripple';
import { defer, merge, Subject } from 'rxjs';
import { startWith, switchMap, take, takeUntil } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Change event that is fired whenever the selected state of an option changes.
 */
class MdcListSelectionChange {
    /**
     * @param {?} source
     */
    constructor(source) {
        this.source = source;
    }
}
let /** @type {?} */ uniqueIdCounter = 0;
class MdcListItemGraphic {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isHostClass = true;
        this.ariaHidden = 'true';
    }
}
MdcListItemGraphic.decorators = [
    { type: Directive, args: [{
                selector: '[mdcListItemGraphic], mdc-list-item-graphic',
                exportAs: 'mdcListItemGraphic',
            },] },
];
/** @nocollapse */
MdcListItemGraphic.ctorParameters = () => [
    { type: ElementRef }
];
MdcListItemGraphic.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-list-item__graphic',] }],
    ariaHidden: [{ type: HostBinding, args: ['attr.aria-hidden',] }]
};
class MdcListItemMeta {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isHostClass = true;
    }
}
MdcListItemMeta.decorators = [
    { type: Directive, args: [{
                selector: '[mdcListItemMeta], mdc-list-item-meta',
                exportAs: 'mdcListItemMeta',
            },] },
];
/** @nocollapse */
MdcListItemMeta.ctorParameters = () => [
    { type: ElementRef }
];
MdcListItemMeta.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-list-item__meta',] }]
};
class MdcListItemText {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isHostClass = true;
    }
}
MdcListItemText.decorators = [
    { type: Directive, args: [{
                selector: '[mdcListItemText], mdc-list-item-text',
                exportAs: 'mdcListItemText',
            },] },
];
/** @nocollapse */
MdcListItemText.ctorParameters = () => [
    { type: ElementRef }
];
MdcListItemText.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-list-item__text',] }]
};
class MdcListItemSecondary {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isHostClass = true;
    }
}
MdcListItemSecondary.decorators = [
    { type: Directive, args: [{
                selector: '[mdcListItemSecondary], mdc-list-item-secondary',
                exportAs: 'mdcListItemSecondary',
            },] },
];
/** @nocollapse */
MdcListItemSecondary.ctorParameters = () => [
    { type: ElementRef }
];
MdcListItemSecondary.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-list-item__secondary-text',] }]
};
class MdcListItem {
    /**
     * @param {?} ripple
     * @param {?} _changeDetector
     * @param {?} elementRef
     */
    constructor(ripple, _changeDetector, elementRef) {
        this.ripple = ripple;
        this._changeDetector = _changeDetector;
        this.elementRef = elementRef;
        this._id = `mdc-list-item-${uniqueIdCounter++}`;
        this.isHostClass = true;
        this.tabIndex = -1;
        this.role = 'listitem';
        this.selectionChange = new EventEmitter();
    }
    /**
     * The unique ID of the option.
     * @return {?}
     */
    get id() { return this._id; }
    /**
     * @return {?}
     */
    get classSelected() {
        return this.selected && this.ripple.isAttached() ? 'mdc-list-item--selected' : '';
    }
    /**
     * @return {?}
     */
    onclick() {
        this.setSelected(!this.selected);
        this._emitChangeEvent();
    }
    /**
     * Whether the option is selected.
     * @return {?}
     */
    get selected() { return this._selected; }
    /**
     * @param {?} value
     * @return {?}
     */
    set selected(value) {
        this.setSelected(value);
    }
    /**
     * Sets the selected state of the option.
     * @param {?} selected
     * @return {?}
     */
    setSelected(selected) {
        this._selected = selected;
        this._changeDetector.markForCheck();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.ripple.destroy();
    }
    /**
     * @param {?} interactive
     * @return {?}
     */
    setInteractive(interactive) {
        interactive ? this.ripple.attachTo(this.getListItemElement()) : this.ripple.destroy();
    }
    /**
     * @return {?}
     */
    getListItemElement() {
        return this.elementRef.nativeElement;
    }
    /**
     * Emits a change event if the selected state of an option changed.
     * @return {?}
     */
    _emitChangeEvent() {
        this.selectionChange.emit(new MdcListSelectionChange(this));
    }
}
MdcListItem.decorators = [
    { type: Component, args: [{selector: 'mdc-list-item, a[mdc-list-item]',
                exportAs: 'mdcListItem',
                host: {
                    '[id]': 'id',
                },
                template: '<ng-content></ng-content>',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    EventRegistry,
                    MdcRipple
                ]
            },] },
];
/** @nocollapse */
MdcListItem.ctorParameters = () => [
    { type: MdcRipple },
    { type: ChangeDetectorRef },
    { type: ElementRef }
];
MdcListItem.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-list-item',] }],
    tabIndex: [{ type: HostBinding, args: ['tabindex',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    classSelected: [{ type: HostBinding, args: ['class.mdc-list-item--selected',] }],
    onclick: [{ type: HostListener, args: ['click',] }],
    selectionChange: [{ type: Output }],
    listItemStart: [{ type: ContentChild, args: [MdcListItemGraphic,] }],
    selected: [{ type: Input }]
};

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @template A
 */
class MDCFoundation {
  /** @return enum{cssClasses} */
  static get cssClasses() {
    // Classes extending MDCFoundation should implement this method to return an object which exports every
    // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
    return {};
  }

  /** @return enum{strings} */
  static get strings() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
    return {};
  }

  /** @return enum{numbers} */
  static get numbers() {
    // Classes extending MDCFoundation should implement this method to return an object which exports all
    // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
    return {};
  }

  /** @return {!Object} */
  static get defaultAdapter() {
    // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
    // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
    // validation.
    return {};
  }

  /**
   * @param {A=} adapter
   */
  constructor(adapter = {}) {
    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  init() {
    // Subclasses should override this method to perform initialization routines (registering events, etc.)
  }

  destroy() {
    // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  }
}

/**
 * @license
 * Copyright 2018 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @enum {string} */
const cssClasses = {
  LIST_ITEM_CLASS: 'mdc-list-item',
};

/** @enum {string} */
const strings = {
  ARIA_ORIENTATION: 'aria-orientation',
  ARIA_ORIENTATION_VERTICAL: 'vertical',
  FOCUSABLE_CHILD_ELEMENTS: 'button:not(:disabled), a',
  ITEMS_SELECTOR: '.mdc-list-item',
};

/**
 * @license
 * Copyright 2018 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const ELEMENTS_KEY_ALLOWED_IN = ['input', 'button', 'textarea', 'select'];

class MDCListFoundation extends MDCFoundation {
  static get strings() {
    return strings;
  }

  static get cssClasses() {
    return cssClasses;
  }

  static get defaultAdapter() {
    return /** {MDCListAdapter */ ({
      getListItemCount: () => {},
      getFocusedElementIndex: () => {},
      getListItemIndex: () => {},
      focusItemAtIndex: () => {},
      setTabIndexForListItemChildren: () => {},
    });
  }

  constructor(adapter = /** @type {!MDCListFoundation} */ ({})) {
    super(Object.assign(MDCListFoundation.defaultAdapter, adapter));
    /** {boolean} */
    this.wrapFocus_ = false;
    /** {boolean} */
    this.isVertical_ = true;
  }

  /**
   * Sets the private wrapFocus_ variable.
   * @param {boolean} value
   */
  setWrapFocus(value) {
    this.wrapFocus_ = value;
  }

  /**
   * Sets the isVertical_ private variable.
   * @param {boolean} value
   */
  setVerticalOrientation(value) {
    this.isVertical_ = value;
  }

  /**
   * Focus in handler for the list items.
   * @param evt
   */
  handleFocusIn(evt) {
    const listItem = this.getListItem_(evt.target);
    if (!listItem) return;

    this.adapter_.setTabIndexForListItemChildren(this.adapter_.getListItemIndex(listItem), 0);
  }

  /**
   * Focus out handler for the list items.
   * @param {Event} evt
   */
  handleFocusOut(evt) {
    const listItem = this.getListItem_(evt.target);
    if (!listItem) return;

    this.adapter_.setTabIndexForListItemChildren(this.adapter_.getListItemIndex(listItem), -1);
  }

  /**
   * Key handler for the list.
   * @param {Event} evt
   */
  handleKeydown(evt) {
    const arrowLeft = evt.key === 'ArrowLeft' || evt.keyCode === 37;
    const arrowUp = evt.key === 'ArrowUp' || evt.keyCode === 38;
    const arrowRight = evt.key === 'ArrowRight' || evt.keyCode === 39;
    const arrowDown = evt.key === 'ArrowDown' || evt.keyCode === 40;
    const isHome = evt.key === 'Home' || evt.keyCode === 36;
    const isEnd = evt.key === 'End' || evt.keyCode === 35;
    let currentIndex = this.adapter_.getFocusedElementIndex();

    if (currentIndex === -1) {
      currentIndex = this.adapter_.getListItemIndex(this.getListItem_(evt.target));

      if (currentIndex < 0) {
        // If this event doesn't have a mdc-list-item ancestor from the
        // current list (not from a sublist), return early.
        return;
      }
    }

    if ((this.isVertical_ && arrowDown) || (!this.isVertical_ && arrowRight)) {
      this.preventDefaultEvent_(evt);
      this.focusNextElement(currentIndex);
    } else if ((this.isVertical_ && arrowUp) || (!this.isVertical_ && arrowLeft)) {
      this.preventDefaultEvent_(evt);
      this.focusPrevElement(currentIndex);
    } else if (isHome) {
      this.preventDefaultEvent_(evt);
      this.focusFirstElement();
    } else if (isEnd) {
      this.preventDefaultEvent_(evt);
      this.focusLastElement();
    }
  }

  /**
   * Ensures that preventDefault is only called if the containing element doesn't
   * consume the event, and it will cause an unintended scroll.
   * @param {Event} evt
   * @private
   */
  preventDefaultEvent_(evt) {
    const tagName = `${evt.target.tagName}`.toLowerCase();
    if (ELEMENTS_KEY_ALLOWED_IN.indexOf(tagName) === -1) {
      evt.preventDefault();
    }
  }

  /**
   * Focuses the next element on the list.
   * @param {Number} index
   */
  focusNextElement(index) {
    const count = this.adapter_.getListItemCount();
    let nextIndex = index + 1;
    if (nextIndex >= count) {
      if (this.wrapFocus_) {
        nextIndex = 0;
      } else {
        // Return early because last item is already focused.
        return;
      }
    }
    this.adapter_.focusItemAtIndex(nextIndex);
  }

  /**
   * Focuses the previous element on the list.
   * @param {Number} index
   */
  focusPrevElement(index) {
    let prevIndex = index - 1;
    if (prevIndex < 0) {
      if (this.wrapFocus_) {
        prevIndex = this.adapter_.getListItemCount() - 1;
      } else {
        // Return early because first item is already focused.
        return;
      }
    }
    this.adapter_.focusItemAtIndex(prevIndex);
  }

  focusFirstElement() {
    if (this.adapter_.getListItemCount() > 0) {
      this.adapter_.focusItemAtIndex(0);
    }
  }

  focusLastElement() {
    const lastIndex = this.adapter_.getListItemCount() - 1;
    if (lastIndex >= 0) {
      this.adapter_.focusItemAtIndex(lastIndex);
    }
  }

  /**
   * Utility method to find the first ancestor with the mdc-list-item class.
   * @param {EventTarget} target
   * @return {?Element}
   * @private
   */
  getListItem_(target) {
    while (!target.classList.contains(cssClasses.LIST_ITEM_CLASS)) {
      if (!target.parentElement) return null;
      target = target.parentElement;
    }
    return target;
  }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Change event that is being fired whenever the selected state of an option changes.
 */
class MdcListItemChange {
    /**
     * @param {?} source
     * @param {?} option
     */
    constructor(source, option) {
        this.source = source;
        this.option = option;
    }
}
class MdcListGroup {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isHostClass = true;
    }
}
MdcListGroup.decorators = [
    { type: Directive, args: [{
                selector: '[mdcListGroup], mdc-list-group',
                exportAs: 'mdcListGroup',
            },] },
];
/** @nocollapse */
MdcListGroup.ctorParameters = () => [
    { type: ElementRef }
];
MdcListGroup.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-list-group',] }]
};
class MdcListGroupSubheader {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.isHostClass = true;
    }
}
MdcListGroupSubheader.decorators = [
    { type: Directive, args: [{
                selector: '[mdcListGroupSubheader], mdc-list-group-subheader',
                exportAs: 'mdcListGroupSubheader',
            },] },
];
/** @nocollapse */
MdcListGroupSubheader.ctorParameters = () => [
    { type: ElementRef }
];
MdcListGroupSubheader.propDecorators = {
    isHostClass: [{ type: HostBinding, args: ['class.mdc-list-group__subheader',] }]
};
class MdcListDivider {
    constructor() {
        this._inset = false;
        this._padded = false;
    }
    /**
     * @return {?}
     */
    get inset() { return this._inset; }
    /**
     * @param {?} value
     * @return {?}
     */
    set inset(value) {
        this._inset = toBoolean(value);
        this._inset ? this._divider.nativeElement.classList.add('mdc-list-divider--inset')
            : this._divider.nativeElement.classList.remove('mdc-list-divider--inset');
    }
    /**
     * @return {?}
     */
    get padded() { return this._padded; }
    /**
     * @param {?} value
     * @return {?}
     */
    set padded(value) {
        this._padded = toBoolean(value);
        this._padded ? this._divider.nativeElement.classList.add('mdc-list-divider--padded')
            : this._divider.nativeElement.classList.remove('mdc-list-divider--padded');
    }
}
MdcListDivider.decorators = [
    { type: Component, args: [{selector: '[mdcListDivider], mdc-list-divider',
                exportAs: 'mdcListDivider',
                template: '<div #divider class="mdc-list-divider" role="seperator"></div>',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
MdcListDivider.propDecorators = {
    inset: [{ type: Input }],
    padded: [{ type: Input }],
    _divider: [{ type: ViewChild, args: ['divider',] }]
};
class MdcList {
    /**
     * @param {?} _changeDetectorRef
     * @param {?} _ngZone
     * @param {?} elementRef
     */
    constructor(_changeDetectorRef, _ngZone, elementRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this._ngZone = _ngZone;
        this.elementRef = elementRef;
        /**
         * Emits whenever the component is destroyed.
         */
        this._destroy = new Subject();
        this.dense = false;
        this.lines = 1;
        this.border = false;
        this._interactive = true;
        this.isHostClass = true;
        this.role = 'list';
        this.ariaOrientation = 'vertical';
        /**
         * Emits a change event whenever the selected state of an option changes.
         */
        this.selectionChange = new EventEmitter();
        this._mdcAdapter = {
            getListItemCount: () => this._listItems.length,
            getFocusedElementIndex: () => this._listItems.toArray().findIndex((_) => _.getListItemElement() === document.activeElement),
            getListItemIndex: (node) => this._listItems.toArray().findIndex((_) => _.getListItemElement() === node),
            focusItemAtIndex: (ndx) => this._listItems.toArray()[ndx].getListItemElement().focus(),
            setTabIndexForListItemChildren: (listItemIndex, tabIndexValue) => {
                const /** @type {?} */ listItemChildren = [].slice.call(this._listItems.toArray()[listItemIndex].getListItemElement()
                    .querySelectorAll('button:not(:disabled), a'));
                listItemChildren.forEach((ele) => ele.setAttribute('tabindex', tabIndexValue));
            }
        };
        this._foundation = new MDCListFoundation(this._mdcAdapter);
        /**
         * Combined stream of all of the child options' change events.
         */
        this.optionSelectionChanges = defer(() => {
            if (this._listItems) {
                return merge(...this._listItems.map(option => option.selectionChange));
            }
            return this._ngZone.onStable
                .asObservable()
                .pipe(take(1), switchMap(() => this.optionSelectionChanges));
        });
    }
    /**
     * @return {?}
     */
    get avatar() { return this._avatar; }
    /**
     * @param {?} value
     * @return {?}
     */
    set avatar(value) {
        this._avatar = toBoolean(value);
    }
    /**
     * @return {?}
     */
    get interactive() { return this._interactive; }
    /**
     * @param {?} value
     * @return {?}
     */
    set interactive(value) {
        if (value !== this._interactive) {
            this.setInteractive(value);
        }
    }
    /**
     * @return {?}
     */
    get multiple() { return this._multiple; }
    /**
     * @param {?} value
     * @return {?}
     */
    set multiple(value) {
        this.setMultiple(value);
    }
    /**
     * @return {?}
     */
    get classDense() {
        return this.dense ? 'mdc-list--dense' : '';
    }
    /**
     * @return {?}
     */
    get classLines() {
        return this.lines === 2 ? 'mdc-list--two-line' : '';
    }
    /**
     * @return {?}
     */
    get classAvatar() {
        return this.avatar ? 'mdc-list--avatar-list' : '';
    }
    /**
     * @return {?}
     */
    get classBorder() {
        return this.border ? 'ng-mdc-list--border' : '';
    }
    /**
     * @return {?}
     */
    get classInteractive() {
        return !this.interactive ? 'mdc-list--non-interactive' : '';
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    onkeydown(evt) {
        this._foundation.handleKeydown(evt);
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    onfocusin(evt) {
        this._foundation.handleFocusIn(evt);
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    onfocusout(evt) {
        this._foundation.handleFocusOut(evt);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._foundation.init();
        this._foundation.setVerticalOrientation(true);
        this.optionSelectionChanges.pipe(takeUntil(merge(this._destroy, this._listItems.changes))).subscribe(event => {
            this.selectionChange.emit(new MdcListItemChange(this, event.source));
        });
        this._listItems.changes.pipe(startWith(null), takeUntil(this._destroy)).subscribe(() => {
            Promise.resolve().then(() => {
                this.setInteractive(this.interactive);
                if (!this.multiple) {
                    this._resetOptions();
                }
            });
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._destroy.next();
        this._destroy.complete();
    }
    /**
     * Drops current option subscriptions and IDs and resets from scratch.
     * @return {?}
     */
    _resetOptions() {
        const /** @type {?} */ changedOrDestroyed = merge(this._listItems.changes, this._destroy);
        this.optionSelectionChanges
            .pipe(takeUntil(changedOrDestroyed)).subscribe(event => {
            if (!this.multiple) {
                this.clearSelected(event.source);
            }
        });
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setInteractive(value) {
        this._interactive = toBoolean(value);
        if (!this._listItems) {
            return;
        }
        this._listItems.forEach(option => {
            option.setInteractive(value);
        });
    }
    /**
     * @param {?} multiple
     * @return {?}
     */
    setMultiple(multiple) {
        this._multiple = multiple;
        this.clearSelected();
        this._changeDetectorRef.markForCheck();
    }
    /**
     * @param {?=} skip
     * @return {?}
     */
    clearSelected(skip) {
        if (!this._listItems) {
            return;
        }
        this._listItems.forEach(option => {
            if (option !== skip) {
                option.setSelected(false);
            }
        });
    }
}
MdcList.decorators = [
    { type: Component, args: [{selector: 'mdc-list',
                exportAs: 'mdcList',
                template: '<ng-content></ng-content>',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/** @nocollapse */
MdcList.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: ElementRef }
];
MdcList.propDecorators = {
    dense: [{ type: Input }],
    lines: [{ type: Input }],
    border: [{ type: Input }],
    avatar: [{ type: Input }],
    interactive: [{ type: Input }],
    multiple: [{ type: Input }],
    isHostClass: [{ type: HostBinding, args: ['class.mdc-list',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    ariaOrientation: [{ type: HostBinding, args: ['attr.aria-orientation',] }],
    classDense: [{ type: HostBinding, args: ['class.mdc-list--dense',] }],
    classLines: [{ type: HostBinding, args: ['class.mdc-list--two-line',] }],
    classAvatar: [{ type: HostBinding, args: ['class.mdc-list--avatar-list',] }],
    classBorder: [{ type: HostBinding, args: ['class.ng-mdc-list--border',] }],
    classInteractive: [{ type: HostBinding, args: ['class.mdc-list--non-interactive',] }],
    onkeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }],
    onfocusin: [{ type: HostListener, args: ['focusin', ['$event'],] }],
    onfocusout: [{ type: HostListener, args: ['focusout', ['$event'],] }],
    _listItems: [{ type: ContentChildren, args: [MdcListItem, { descendants: true },] }],
    selectionChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ LIST_DECLARATIONS = [
    MdcList,
    MdcListDivider,
    MdcListGroup,
    MdcListGroupSubheader,
    MdcListItem,
    MdcListItemGraphic,
    MdcListItemMeta,
    MdcListItemSecondary,
    MdcListItemText,
];
class MdcListModule {
}
MdcListModule.decorators = [
    { type: NgModule, args: [{
                exports: LIST_DECLARATIONS,
                declarations: LIST_DECLARATIONS,
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { MdcListModule, MdcListSelectionChange, MdcListItemGraphic, MdcListItemMeta, MdcListItemText, MdcListItemSecondary, MdcListItem, MdcListItemChange, MdcListGroup, MdcListGroupSubheader, MdcListDivider, MdcList };
