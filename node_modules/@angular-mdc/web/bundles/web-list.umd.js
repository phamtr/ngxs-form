/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular-mdc/web/common'), require('@angular-mdc/web/ripple'), require('rxjs'), require('rxjs/operators')) :
  typeof define === 'function' && define.amd ? define('@angular-mdc/web/list', ['exports', '@angular/core', '@angular-mdc/web/common', '@angular-mdc/web/ripple', 'rxjs', 'rxjs/operators'], factory) :
  (factory((global.ng = global.ng || {}, global.ng.web = global.ng.web || {}, global.ng.web.list = {}),global.ng.core,global.ng.web.common,global.ng.web.ripple,global.Rx,global.Rx.operators));
}(this, (function (exports,core,common,ripple,rxjs,operators) { 'use strict';

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes} checked by tsc
   */
  /**
   * Change event that is fired whenever the selected state of an option changes.
   */
  var   /**
   * Change event that is fired whenever the selected state of an option changes.
   */
  MdcListSelectionChange = /** @class */ (function () {
      function MdcListSelectionChange(source) {
          this.source = source;
      }
      return MdcListSelectionChange;
  }());
  var /** @type {?} */ uniqueIdCounter = 0;
  var MdcListItemGraphic = /** @class */ (function () {
      function MdcListItemGraphic(elementRef) {
          this.elementRef = elementRef;
          this.isHostClass = true;
          this.ariaHidden = 'true';
      }
      MdcListItemGraphic.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mdcListItemGraphic], mdc-list-item-graphic',
                      exportAs: 'mdcListItemGraphic',
                  },] },
      ];
      /** @nocollapse */
      MdcListItemGraphic.ctorParameters = function () { return [
          { type: core.ElementRef }
      ]; };
      MdcListItemGraphic.propDecorators = {
          isHostClass: [{ type: core.HostBinding, args: ['class.mdc-list-item__graphic',] }],
          ariaHidden: [{ type: core.HostBinding, args: ['attr.aria-hidden',] }]
      };
      return MdcListItemGraphic;
  }());
  var MdcListItemMeta = /** @class */ (function () {
      function MdcListItemMeta(elementRef) {
          this.elementRef = elementRef;
          this.isHostClass = true;
      }
      MdcListItemMeta.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mdcListItemMeta], mdc-list-item-meta',
                      exportAs: 'mdcListItemMeta',
                  },] },
      ];
      /** @nocollapse */
      MdcListItemMeta.ctorParameters = function () { return [
          { type: core.ElementRef }
      ]; };
      MdcListItemMeta.propDecorators = {
          isHostClass: [{ type: core.HostBinding, args: ['class.mdc-list-item__meta',] }]
      };
      return MdcListItemMeta;
  }());
  var MdcListItemText = /** @class */ (function () {
      function MdcListItemText(elementRef) {
          this.elementRef = elementRef;
          this.isHostClass = true;
      }
      MdcListItemText.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mdcListItemText], mdc-list-item-text',
                      exportAs: 'mdcListItemText',
                  },] },
      ];
      /** @nocollapse */
      MdcListItemText.ctorParameters = function () { return [
          { type: core.ElementRef }
      ]; };
      MdcListItemText.propDecorators = {
          isHostClass: [{ type: core.HostBinding, args: ['class.mdc-list-item__text',] }]
      };
      return MdcListItemText;
  }());
  var MdcListItemSecondary = /** @class */ (function () {
      function MdcListItemSecondary(elementRef) {
          this.elementRef = elementRef;
          this.isHostClass = true;
      }
      MdcListItemSecondary.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mdcListItemSecondary], mdc-list-item-secondary',
                      exportAs: 'mdcListItemSecondary',
                  },] },
      ];
      /** @nocollapse */
      MdcListItemSecondary.ctorParameters = function () { return [
          { type: core.ElementRef }
      ]; };
      MdcListItemSecondary.propDecorators = {
          isHostClass: [{ type: core.HostBinding, args: ['class.mdc-list-item__secondary-text',] }]
      };
      return MdcListItemSecondary;
  }());
  var MdcListItem = /** @class */ (function () {
      function MdcListItem(ripple$$1, _changeDetector, elementRef) {
          this.ripple = ripple$$1;
          this._changeDetector = _changeDetector;
          this.elementRef = elementRef;
          this._id = "mdc-list-item-" + uniqueIdCounter++;
          this.isHostClass = true;
          this.tabIndex = -1;
          this.role = 'listitem';
          this.selectionChange = new core.EventEmitter();
      }
      Object.defineProperty(MdcListItem.prototype, "id", {
          /** The unique ID of the option. */
          get: /**
           * The unique ID of the option.
           * @return {?}
           */
          function () { return this._id; },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcListItem.prototype, "classSelected", {
          get: /**
           * @return {?}
           */
          function () {
              return this.selected && this.ripple.isAttached() ? 'mdc-list-item--selected' : '';
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @return {?}
       */
      MdcListItem.prototype.onclick = /**
       * @return {?}
       */
      function () {
          this.setSelected(!this.selected);
          this._emitChangeEvent();
      };
      Object.defineProperty(MdcListItem.prototype, "selected", {
          /** Whether the option is selected. */
          get: /**
           * Whether the option is selected.
           * @return {?}
           */
          function () { return this._selected; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this.setSelected(value);
          },
          enumerable: true,
          configurable: true
      });
      /** Sets the selected state of the option. */
      /**
       * Sets the selected state of the option.
       * @param {?} selected
       * @return {?}
       */
      MdcListItem.prototype.setSelected = /**
       * Sets the selected state of the option.
       * @param {?} selected
       * @return {?}
       */
      function (selected) {
          this._selected = selected;
          this._changeDetector.markForCheck();
      };
      /**
       * @return {?}
       */
      MdcListItem.prototype.ngOnDestroy = /**
       * @return {?}
       */
      function () {
          this.ripple.destroy();
      };
      /**
       * @param {?} interactive
       * @return {?}
       */
      MdcListItem.prototype.setInteractive = /**
       * @param {?} interactive
       * @return {?}
       */
      function (interactive) {
          interactive ? this.ripple.attachTo(this.getListItemElement()) : this.ripple.destroy();
      };
      /**
       * @return {?}
       */
      MdcListItem.prototype.getListItemElement = /**
       * @return {?}
       */
      function () {
          return this.elementRef.nativeElement;
      };
      /**
       * Emits a change event if the selected state of an option changed.
       * @return {?}
       */
      MdcListItem.prototype._emitChangeEvent = /**
       * Emits a change event if the selected state of an option changed.
       * @return {?}
       */
      function () {
          this.selectionChange.emit(new MdcListSelectionChange(this));
      };
      MdcListItem.decorators = [
          { type: core.Component, args: [{selector: 'mdc-list-item, a[mdc-list-item]',
                      exportAs: 'mdcListItem',
                      host: {
                          '[id]': 'id',
                      },
                      template: '<ng-content></ng-content>',
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush,
                      providers: [
                          common.EventRegistry,
                          ripple.MdcRipple
                      ]
                  },] },
      ];
      /** @nocollapse */
      MdcListItem.ctorParameters = function () { return [
          { type: ripple.MdcRipple },
          { type: core.ChangeDetectorRef },
          { type: core.ElementRef }
      ]; };
      MdcListItem.propDecorators = {
          isHostClass: [{ type: core.HostBinding, args: ['class.mdc-list-item',] }],
          tabIndex: [{ type: core.HostBinding, args: ['tabindex',] }],
          role: [{ type: core.HostBinding, args: ['attr.role',] }],
          classSelected: [{ type: core.HostBinding, args: ['class.mdc-list-item--selected',] }],
          onclick: [{ type: core.HostListener, args: ['click',] }],
          selectionChange: [{ type: core.Output }],
          listItemStart: [{ type: core.ContentChild, args: [MdcListItemGraphic,] }],
          selected: [{ type: core.Input }]
      };
      return MdcListItem;
  }());

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @template A
   */
  var MDCFoundation =
  /*#__PURE__*/
  function () {
    _createClass(MDCFoundation, null, [{
      key: "cssClasses",

      /** @return enum{cssClasses} */
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports every
        // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
        return {};
      }
      /** @return enum{strings} */

    }, {
      key: "strings",
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
        return {};
      }
      /** @return enum{numbers} */

    }, {
      key: "numbers",
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
        return {};
      }
      /** @return {!Object} */

    }, {
      key: "defaultAdapter",
      get: function get() {
        // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
        // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
        // validation.
        return {};
      }
      /**
       * @param {A=} adapter
       */

    }]);

    function MDCFoundation() {
      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, MDCFoundation);

      /** @protected {!A} */
      this.adapter_ = adapter;
    }

    _createClass(MDCFoundation, [{
      key: "init",
      value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
      }
    }, {
      key: "destroy",
      value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
      }
    }]);

    return MDCFoundation;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses = {
    LIST_ITEM_CLASS: 'mdc-list-item'
  };
  /** @enum {string} */

  var strings = {
    ARIA_ORIENTATION: 'aria-orientation',
    ARIA_ORIENTATION_VERTICAL: 'vertical',
    FOCUSABLE_CHILD_ELEMENTS: 'button:not(:disabled), a',
    ITEMS_SELECTOR: '.mdc-list-item'
  };

  var ELEMENTS_KEY_ALLOWED_IN = ['input', 'button', 'textarea', 'select'];

  var MDCListFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCListFoundation, _MDCFoundation);

    _createClass(MDCListFoundation, null, [{
      key: "strings",
      get: function get() {
        return strings;
      }
    }, {
      key: "cssClasses",
      get: function get() {
        return cssClasses;
      }
    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** {MDCListAdapter */
          {
            getListItemCount: function getListItemCount() {},
            getFocusedElementIndex: function getFocusedElementIndex() {},
            getListItemIndex: function getListItemIndex() {},
            focusItemAtIndex: function focusItemAtIndex() {},
            setTabIndexForListItemChildren: function setTabIndexForListItemChildren() {}
          }
        );
      }
    }]);

    function MDCListFoundation() {
      var _this;

      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] :
      /** @type {!MDCListFoundation} */
      {};

      _classCallCheck(this, MDCListFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCListFoundation).call(this, Object.assign(MDCListFoundation.defaultAdapter, adapter)));
      /** {boolean} */

      _this.wrapFocus_ = false;
      /** {boolean} */

      _this.isVertical_ = true;
      return _this;
    }
    /**
     * Sets the private wrapFocus_ variable.
     * @param {boolean} value
     */


    _createClass(MDCListFoundation, [{
      key: "setWrapFocus",
      value: function setWrapFocus(value) {
        this.wrapFocus_ = value;
      }
      /**
       * Sets the isVertical_ private variable.
       * @param {boolean} value
       */

    }, {
      key: "setVerticalOrientation",
      value: function setVerticalOrientation(value) {
        this.isVertical_ = value;
      }
      /**
       * Focus in handler for the list items.
       * @param evt
       */

    }, {
      key: "handleFocusIn",
      value: function handleFocusIn(evt) {
        var listItem = this.getListItem_(evt.target);
        if (!listItem) return;
        this.adapter_.setTabIndexForListItemChildren(this.adapter_.getListItemIndex(listItem), 0);
      }
      /**
       * Focus out handler for the list items.
       * @param {Event} evt
       */

    }, {
      key: "handleFocusOut",
      value: function handleFocusOut(evt) {
        var listItem = this.getListItem_(evt.target);
        if (!listItem) return;
        this.adapter_.setTabIndexForListItemChildren(this.adapter_.getListItemIndex(listItem), -1);
      }
      /**
       * Key handler for the list.
       * @param {Event} evt
       */

    }, {
      key: "handleKeydown",
      value: function handleKeydown(evt) {
        var arrowLeft = evt.key === 'ArrowLeft' || evt.keyCode === 37;
        var arrowUp = evt.key === 'ArrowUp' || evt.keyCode === 38;
        var arrowRight = evt.key === 'ArrowRight' || evt.keyCode === 39;
        var arrowDown = evt.key === 'ArrowDown' || evt.keyCode === 40;
        var isHome = evt.key === 'Home' || evt.keyCode === 36;
        var isEnd = evt.key === 'End' || evt.keyCode === 35;
        var currentIndex = this.adapter_.getFocusedElementIndex();

        if (currentIndex === -1) {
          currentIndex = this.adapter_.getListItemIndex(this.getListItem_(evt.target));

          if (currentIndex < 0) {
            // If this event doesn't have a mdc-list-item ancestor from the
            // current list (not from a sublist), return early.
            return;
          }
        }

        if (this.isVertical_ && arrowDown || !this.isVertical_ && arrowRight) {
          this.preventDefaultEvent_(evt);
          this.focusNextElement(currentIndex);
        } else if (this.isVertical_ && arrowUp || !this.isVertical_ && arrowLeft) {
          this.preventDefaultEvent_(evt);
          this.focusPrevElement(currentIndex);
        } else if (isHome) {
          this.preventDefaultEvent_(evt);
          this.focusFirstElement();
        } else if (isEnd) {
          this.preventDefaultEvent_(evt);
          this.focusLastElement();
        }
      }
      /**
       * Ensures that preventDefault is only called if the containing element doesn't
       * consume the event, and it will cause an unintended scroll.
       * @param {Event} evt
       * @private
       */

    }, {
      key: "preventDefaultEvent_",
      value: function preventDefaultEvent_(evt) {
        var tagName = "".concat(evt.target.tagName).toLowerCase();

        if (ELEMENTS_KEY_ALLOWED_IN.indexOf(tagName) === -1) {
          evt.preventDefault();
        }
      }
      /**
       * Focuses the next element on the list.
       * @param {Number} index
       */

    }, {
      key: "focusNextElement",
      value: function focusNextElement(index) {
        var count = this.adapter_.getListItemCount();
        var nextIndex = index + 1;

        if (nextIndex >= count) {
          if (this.wrapFocus_) {
            nextIndex = 0;
          } else {
            // Return early because last item is already focused.
            return;
          }
        }

        this.adapter_.focusItemAtIndex(nextIndex);
      }
      /**
       * Focuses the previous element on the list.
       * @param {Number} index
       */

    }, {
      key: "focusPrevElement",
      value: function focusPrevElement(index) {
        var prevIndex = index - 1;

        if (prevIndex < 0) {
          if (this.wrapFocus_) {
            prevIndex = this.adapter_.getListItemCount() - 1;
          } else {
            // Return early because first item is already focused.
            return;
          }
        }

        this.adapter_.focusItemAtIndex(prevIndex);
      }
    }, {
      key: "focusFirstElement",
      value: function focusFirstElement() {
        if (this.adapter_.getListItemCount() > 0) {
          this.adapter_.focusItemAtIndex(0);
        }
      }
    }, {
      key: "focusLastElement",
      value: function focusLastElement() {
        var lastIndex = this.adapter_.getListItemCount() - 1;

        if (lastIndex >= 0) {
          this.adapter_.focusItemAtIndex(lastIndex);
        }
      }
      /**
       * Utility method to find the first ancestor with the mdc-list-item class.
       * @param {EventTarget} target
       * @return {?Element}
       * @private
       */

    }, {
      key: "getListItem_",
      value: function getListItem_(target) {
        while (!target.classList.contains(cssClasses.LIST_ITEM_CLASS)) {
          if (!target.parentElement) return null;
          target = target.parentElement;
        }

        return target;
      }
    }]);

    return MDCListFoundation;
  }(MDCFoundation);

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes} checked by tsc
   */
  /**
   * Change event that is being fired whenever the selected state of an option changes.
   */
  var   /**
   * Change event that is being fired whenever the selected state of an option changes.
   */
  MdcListItemChange = /** @class */ (function () {
      function MdcListItemChange(source, option) {
          this.source = source;
          this.option = option;
      }
      return MdcListItemChange;
  }());
  var MdcListGroup = /** @class */ (function () {
      function MdcListGroup(elementRef) {
          this.elementRef = elementRef;
          this.isHostClass = true;
      }
      MdcListGroup.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mdcListGroup], mdc-list-group',
                      exportAs: 'mdcListGroup',
                  },] },
      ];
      /** @nocollapse */
      MdcListGroup.ctorParameters = function () { return [
          { type: core.ElementRef }
      ]; };
      MdcListGroup.propDecorators = {
          isHostClass: [{ type: core.HostBinding, args: ['class.mdc-list-group',] }]
      };
      return MdcListGroup;
  }());
  var MdcListGroupSubheader = /** @class */ (function () {
      function MdcListGroupSubheader(elementRef) {
          this.elementRef = elementRef;
          this.isHostClass = true;
      }
      MdcListGroupSubheader.decorators = [
          { type: core.Directive, args: [{
                      selector: '[mdcListGroupSubheader], mdc-list-group-subheader',
                      exportAs: 'mdcListGroupSubheader',
                  },] },
      ];
      /** @nocollapse */
      MdcListGroupSubheader.ctorParameters = function () { return [
          { type: core.ElementRef }
      ]; };
      MdcListGroupSubheader.propDecorators = {
          isHostClass: [{ type: core.HostBinding, args: ['class.mdc-list-group__subheader',] }]
      };
      return MdcListGroupSubheader;
  }());
  var MdcListDivider = /** @class */ (function () {
      function MdcListDivider() {
          this._inset = false;
          this._padded = false;
      }
      Object.defineProperty(MdcListDivider.prototype, "inset", {
          get: /**
           * @return {?}
           */
          function () { return this._inset; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this._inset = common.toBoolean(value);
              this._inset ? this._divider.nativeElement.classList.add('mdc-list-divider--inset')
                  : this._divider.nativeElement.classList.remove('mdc-list-divider--inset');
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcListDivider.prototype, "padded", {
          get: /**
           * @return {?}
           */
          function () { return this._padded; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this._padded = common.toBoolean(value);
              this._padded ? this._divider.nativeElement.classList.add('mdc-list-divider--padded')
                  : this._divider.nativeElement.classList.remove('mdc-list-divider--padded');
          },
          enumerable: true,
          configurable: true
      });
      MdcListDivider.decorators = [
          { type: core.Component, args: [{selector: '[mdcListDivider], mdc-list-divider',
                      exportAs: 'mdcListDivider',
                      template: '<div #divider class="mdc-list-divider" role="seperator"></div>',
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush
                  },] },
      ];
      MdcListDivider.propDecorators = {
          inset: [{ type: core.Input }],
          padded: [{ type: core.Input }],
          _divider: [{ type: core.ViewChild, args: ['divider',] }]
      };
      return MdcListDivider;
  }());
  var MdcList = /** @class */ (function () {
      function MdcList(_changeDetectorRef, _ngZone, elementRef) {
          var _this = this;
          this._changeDetectorRef = _changeDetectorRef;
          this._ngZone = _ngZone;
          this.elementRef = elementRef;
          /**
           * Emits whenever the component is destroyed.
           */
          this._destroy = new rxjs.Subject();
          this.dense = false;
          this.lines = 1;
          this.border = false;
          this._interactive = true;
          this.isHostClass = true;
          this.role = 'list';
          this.ariaOrientation = 'vertical';
          /**
           * Emits a change event whenever the selected state of an option changes.
           */
          this.selectionChange = new core.EventEmitter();
          this._mdcAdapter = {
              getListItemCount: function () { return _this._listItems.length; },
              getFocusedElementIndex: function () { return _this._listItems.toArray().findIndex(function (_) { return _.getListItemElement() === document.activeElement; }); },
              getListItemIndex: function (node) { return _this._listItems.toArray().findIndex(function (_) { return _.getListItemElement() === node; }); },
              focusItemAtIndex: function (ndx) { return _this._listItems.toArray()[ndx].getListItemElement().focus(); },
              setTabIndexForListItemChildren: function (listItemIndex, tabIndexValue) {
                  var /** @type {?} */ listItemChildren = [].slice.call(_this._listItems.toArray()[listItemIndex].getListItemElement()
                      .querySelectorAll('button:not(:disabled), a'));
                  listItemChildren.forEach(function (ele) { return ele.setAttribute('tabindex', tabIndexValue); });
              }
          };
          this._foundation = new MDCListFoundation(this._mdcAdapter);
          /**
           * Combined stream of all of the child options' change events.
           */
          this.optionSelectionChanges = rxjs.defer(function () {
              if (_this._listItems) {
                  return rxjs.merge.apply(void 0, _this._listItems.map(function (option) { return option.selectionChange; }));
              }
              return _this._ngZone.onStable
                  .asObservable()
                  .pipe(operators.take(1), operators.switchMap(function () { return _this.optionSelectionChanges; }));
          });
      }
      Object.defineProperty(MdcList.prototype, "avatar", {
          get: /**
           * @return {?}
           */
          function () { return this._avatar; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this._avatar = common.toBoolean(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcList.prototype, "interactive", {
          get: /**
           * @return {?}
           */
          function () { return this._interactive; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              if (value !== this._interactive) {
                  this.setInteractive(value);
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcList.prototype, "multiple", {
          get: /**
           * @return {?}
           */
          function () { return this._multiple; },
          set: /**
           * @param {?} value
           * @return {?}
           */
          function (value) {
              this.setMultiple(value);
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcList.prototype, "classDense", {
          get: /**
           * @return {?}
           */
          function () {
              return this.dense ? 'mdc-list--dense' : '';
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcList.prototype, "classLines", {
          get: /**
           * @return {?}
           */
          function () {
              return this.lines === 2 ? 'mdc-list--two-line' : '';
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcList.prototype, "classAvatar", {
          get: /**
           * @return {?}
           */
          function () {
              return this.avatar ? 'mdc-list--avatar-list' : '';
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcList.prototype, "classBorder", {
          get: /**
           * @return {?}
           */
          function () {
              return this.border ? 'ng-mdc-list--border' : '';
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(MdcList.prototype, "classInteractive", {
          get: /**
           * @return {?}
           */
          function () {
              return !this.interactive ? 'mdc-list--non-interactive' : '';
          },
          enumerable: true,
          configurable: true
      });
      /**
       * @param {?} evt
       * @return {?}
       */
      MdcList.prototype.onkeydown = /**
       * @param {?} evt
       * @return {?}
       */
      function (evt) {
          this._foundation.handleKeydown(evt);
      };
      /**
       * @param {?} evt
       * @return {?}
       */
      MdcList.prototype.onfocusin = /**
       * @param {?} evt
       * @return {?}
       */
      function (evt) {
          this._foundation.handleFocusIn(evt);
      };
      /**
       * @param {?} evt
       * @return {?}
       */
      MdcList.prototype.onfocusout = /**
       * @param {?} evt
       * @return {?}
       */
      function (evt) {
          this._foundation.handleFocusOut(evt);
      };
      /**
       * @return {?}
       */
      MdcList.prototype.ngAfterContentInit = /**
       * @return {?}
       */
      function () {
          var _this = this;
          this._foundation.init();
          this._foundation.setVerticalOrientation(true);
          this.optionSelectionChanges.pipe(operators.takeUntil(rxjs.merge(this._destroy, this._listItems.changes))).subscribe(function (event) {
              _this.selectionChange.emit(new MdcListItemChange(_this, event.source));
          });
          this._listItems.changes.pipe(operators.startWith(null), operators.takeUntil(this._destroy)).subscribe(function () {
              Promise.resolve().then(function () {
                  _this.setInteractive(_this.interactive);
                  if (!_this.multiple) {
                      _this._resetOptions();
                  }
              });
          });
      };
      /**
       * @return {?}
       */
      MdcList.prototype.ngOnDestroy = /**
       * @return {?}
       */
      function () {
          this._destroy.next();
          this._destroy.complete();
      };
      /**
       * Drops current option subscriptions and IDs and resets from scratch.
       * @return {?}
       */
      MdcList.prototype._resetOptions = /**
       * Drops current option subscriptions and IDs and resets from scratch.
       * @return {?}
       */
      function () {
          var _this = this;
          var /** @type {?} */ changedOrDestroyed = rxjs.merge(this._listItems.changes, this._destroy);
          this.optionSelectionChanges
              .pipe(operators.takeUntil(changedOrDestroyed)).subscribe(function (event) {
              if (!_this.multiple) {
                  _this.clearSelected(event.source);
              }
          });
      };
      /**
       * @param {?} value
       * @return {?}
       */
      MdcList.prototype.setInteractive = /**
       * @param {?} value
       * @return {?}
       */
      function (value) {
          this._interactive = common.toBoolean(value);
          if (!this._listItems) {
              return;
          }
          this._listItems.forEach(function (option) {
              option.setInteractive(value);
          });
      };
      /**
       * @param {?} multiple
       * @return {?}
       */
      MdcList.prototype.setMultiple = /**
       * @param {?} multiple
       * @return {?}
       */
      function (multiple) {
          this._multiple = multiple;
          this.clearSelected();
          this._changeDetectorRef.markForCheck();
      };
      /**
       * @param {?=} skip
       * @return {?}
       */
      MdcList.prototype.clearSelected = /**
       * @param {?=} skip
       * @return {?}
       */
      function (skip) {
          if (!this._listItems) {
              return;
          }
          this._listItems.forEach(function (option) {
              if (option !== skip) {
                  option.setSelected(false);
              }
          });
      };
      MdcList.decorators = [
          { type: core.Component, args: [{selector: 'mdc-list',
                      exportAs: 'mdcList',
                      template: '<ng-content></ng-content>',
                      encapsulation: core.ViewEncapsulation.None,
                      changeDetection: core.ChangeDetectionStrategy.OnPush
                  },] },
      ];
      /** @nocollapse */
      MdcList.ctorParameters = function () { return [
          { type: core.ChangeDetectorRef },
          { type: core.NgZone },
          { type: core.ElementRef }
      ]; };
      MdcList.propDecorators = {
          dense: [{ type: core.Input }],
          lines: [{ type: core.Input }],
          border: [{ type: core.Input }],
          avatar: [{ type: core.Input }],
          interactive: [{ type: core.Input }],
          multiple: [{ type: core.Input }],
          isHostClass: [{ type: core.HostBinding, args: ['class.mdc-list',] }],
          role: [{ type: core.HostBinding, args: ['attr.role',] }],
          ariaOrientation: [{ type: core.HostBinding, args: ['attr.aria-orientation',] }],
          classDense: [{ type: core.HostBinding, args: ['class.mdc-list--dense',] }],
          classLines: [{ type: core.HostBinding, args: ['class.mdc-list--two-line',] }],
          classAvatar: [{ type: core.HostBinding, args: ['class.mdc-list--avatar-list',] }],
          classBorder: [{ type: core.HostBinding, args: ['class.ng-mdc-list--border',] }],
          classInteractive: [{ type: core.HostBinding, args: ['class.mdc-list--non-interactive',] }],
          onkeydown: [{ type: core.HostListener, args: ['keydown', ['$event'],] }],
          onfocusin: [{ type: core.HostListener, args: ['focusin', ['$event'],] }],
          onfocusout: [{ type: core.HostListener, args: ['focusout', ['$event'],] }],
          _listItems: [{ type: core.ContentChildren, args: [MdcListItem, { descendants: true },] }],
          selectionChange: [{ type: core.Output }]
      };
      return MdcList;
  }());

  /**
   * @fileoverview added by tsickle
   * @suppress {checkTypes} checked by tsc
   */
  var /** @type {?} */ LIST_DECLARATIONS = [
      MdcList,
      MdcListDivider,
      MdcListGroup,
      MdcListGroupSubheader,
      MdcListItem,
      MdcListItemGraphic,
      MdcListItemMeta,
      MdcListItemSecondary,
      MdcListItemText,
  ];
  var MdcListModule = /** @class */ (function () {
      function MdcListModule() {
      }
      MdcListModule.decorators = [
          { type: core.NgModule, args: [{
                      exports: LIST_DECLARATIONS,
                      declarations: LIST_DECLARATIONS,
                  },] },
      ];
      return MdcListModule;
  }());

  exports.MdcListModule = MdcListModule;
  exports.MdcListSelectionChange = MdcListSelectionChange;
  exports.MdcListItemGraphic = MdcListItemGraphic;
  exports.MdcListItemMeta = MdcListItemMeta;
  exports.MdcListItemText = MdcListItemText;
  exports.MdcListItemSecondary = MdcListItemSecondary;
  exports.MdcListItem = MdcListItem;
  exports.MdcListItemChange = MdcListItemChange;
  exports.MdcListGroup = MdcListGroup;
  exports.MdcListGroupSubheader = MdcListGroupSubheader;
  exports.MdcListDivider = MdcListDivider;
  exports.MdcList = MdcList;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
