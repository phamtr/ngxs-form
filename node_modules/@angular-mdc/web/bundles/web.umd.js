/**
 * @license
 * Copyright (c) 2018 Dominic Carretto
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/trimox/angular-mdc-web/blob/master/LICENSE
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/router'), require('rxjs/operators'), require('rxjs'), require('@angular/common'), require('@angular/forms')) :
    typeof define === 'function' && define.amd ? define('@angular-mdc/web', ['exports', '@angular/core', '@angular/router', 'rxjs/operators', 'rxjs', '@angular/common', '@angular/forms'], factory) :
    (factory((global.ng = global.ng || {}, global.ng.web = {}),global.ng.core,global.ng.router,global.Rx.operators,global.Rx,global.ng.common,global.ng.forms));
}(this, (function (exports,core,router,operators,rxjs,common,forms) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @param {?} value
     * @return {?}
     */
    function toBoolean(value) {
        return value != null && "" + value !== 'false';
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var EventRegistry = /** @class */ (function () {
        function EventRegistry() {
            this.unlisteners = new Map();
        }
        /**
         * @param {?} type
         * @param {?} listener
         * @param {?} target
         * @param {?=} passive
         * @return {?}
         */
        EventRegistry.prototype.listen = /**
         * @param {?} type
         * @param {?} listener
         * @param {?} target
         * @param {?=} passive
         * @return {?}
         */
        function (type, listener, target, passive) {
            if (!this.unlisteners.has(type)) {
                this.unlisteners.set(type, new WeakMap());
            }
            target.addEventListener(type, listener, passive);
            this.unlisteners.get(type).set(listener, function () { target.removeEventListener(type, listener, passive); });
        };
        /**
         * @param {?} type
         * @param {?} listener
         * @return {?}
         */
        EventRegistry.prototype.unlisten = /**
         * @param {?} type
         * @param {?} listener
         * @return {?}
         */
        function (type, listener) {
            if (!this.unlisteners.has(type)) {
                return;
            }
            var /** @type {?} */ unlisteners = this.unlisteners.get(type);
            if (!unlisteners.has(listener)) {
                return;
            }
            unlisteners.get(listener)();
            unlisteners.delete(listener);
        };
        EventRegistry.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        EventRegistry.ctorParameters = function () { return []; };
        return EventRegistry;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @param {?} event
     * @return {?}
     */
    function isSpaceKey(event) {
        // NB: keyCode does not work on Firefox, returning `0` for the space key.
        return event.keyCode !== 0 ? event.keyCode === 32 : event.key === ' ';
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var /** @type {?} */ UP_ARROW = 38;
    var /** @type {?} */ DOWN_ARROW = 40;
    var /** @type {?} */ RIGHT_ARROW = 39;
    var /** @type {?} */ LEFT_ARROW = 37;
    var /** @type {?} */ PAGE_UP = 33;
    var /** @type {?} */ PAGE_DOWN = 34;
    var /** @type {?} */ HOME = 36;
    var /** @type {?} */ END = 35;
    var /** @type {?} */ ENTER = 13;
    var /** @type {?} */ SPACE = 32;
    var /** @type {?} */ TAB = 9;
    var /** @type {?} */ ESCAPE = 27;
    var /** @type {?} */ BACKSPACE = 8;
    var /** @type {?} */ DELETE = 46;
    var /** @type {?} */ A = 65;
    var /** @type {?} */ Z = 90;
    var /** @type {?} */ ZERO = 48;
    var /** @type {?} */ NINE = 57;
    var /** @type {?} */ COMMA = 188;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @param {?} value
     * @param {?=} fallbackValue
     * @return {?}
     */
    function toNumber(value, fallbackValue) {
        if (fallbackValue === void 0) { fallbackValue = 0; }
        return _isNumberValue(value) ? Number(value) : fallbackValue;
    }
    /**
     * Whether the provided value is considered a number.
     * @param {?} value
     * @return {?}
     */
    function _isNumberValue(value) {
        // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,
        // and other non-number values as NaN, where Number just uses 0) but it considers the string
        // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.
        return !isNaN(parseFloat(/** @type {?} */ (value))) && !isNaN(Number(value));
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @return {?}
     */
    function isBrowser() {
        return typeof document === 'object' && !!document;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcRouter = /** @class */ (function () {
        function MdcRouter(_router) {
            var _this = this;
            this._router = _router;
            /**
             * Emits whenever the component is destroyed.
             */
            this._destroy = new rxjs.Subject();
            /**
             * Event emitted when the link is set active.
             */
            this.routeChange = new core.EventEmitter();
            this._router.events
                .pipe(operators.takeUntil(this._destroy), operators.filter(function (event) { return event instanceof router.NavigationEnd; })).subscribe(function (_) {
                _this._refreshActiveLink();
            });
        }
        /**
         * @return {?}
         */
        MdcRouter.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            this._listenToLinkChanges();
            this._listenToHrefLinkChanges();
            this._refreshActiveLink();
        };
        /**
         * @return {?}
         */
        MdcRouter.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroy.next();
            this._destroy.complete();
        };
        /**
         * @return {?}
         */
        MdcRouter.prototype._listenToLinkChanges = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this._routerlinks.changes
                .pipe(operators.takeUntil(this._destroy))
                .subscribe(function () {
                _this._refreshActiveLink();
            });
        };
        /**
         * @return {?}
         */
        MdcRouter.prototype._listenToHrefLinkChanges = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this._routerHrefLinks.changes
                .pipe(operators.takeUntil(this._destroy))
                .subscribe(function () {
                _this._refreshActiveLink();
            });
        };
        /**
         * @return {?}
         */
        MdcRouter.prototype._refreshActiveLink = /**
         * @return {?}
         */
        function () {
            if (!this._isRouterActivated()) {
                return;
            }
            this._emitActivated(this._linkState());
        };
        /**
         * @return {?}
         */
        MdcRouter.prototype._isRouterActivated = /**
         * @return {?}
         */
        function () {
            return (!this._routerlinks || !this._routerHrefLinks
                || !this._router.navigated) ? false : true;
        };
        /**
         * @return {?}
         */
        MdcRouter.prototype._linkState = /**
         * @return {?}
         */
        function () {
            return this._routerlinks.some(this.isLinkActive())
                || this._routerHrefLinks.some(this.isLinkActive());
        };
        /**
         * @return {?}
         */
        MdcRouter.prototype.isLinkActive = /**
         * @return {?}
         */
        function () {
            var _this = this;
            return function (route) { return _this._router.isActive(route.urlTree, false); };
        };
        /**
         * Emits an activated link event.
         * @param {?} active
         * @return {?}
         */
        MdcRouter.prototype._emitActivated = /**
         * Emits an activated link event.
         * @param {?} active
         * @return {?}
         */
        function (active) {
            this.routeChange.emit({ active: active });
        };
        MdcRouter.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcRouter]',
                        exportAs: 'mdcRouter'
                    },] },
        ];
        /** @nocollapse */
        MdcRouter.ctorParameters = function () { return [
            { type: router.Router }
        ]; };
        MdcRouter.propDecorators = {
            routeChange: [{ type: core.Output }],
            _routerlinks: [{ type: core.ContentChildren, args: [router.RouterLink, { descendants: true },] }],
            _routerHrefLinks: [{ type: core.ContentChildren, args: [router.RouterLinkWithHref, { descendants: true },] }]
        };
        return MdcRouter;
    }());
    var MdcRouterModule = /** @class */ (function () {
        function MdcRouterModule() {
        }
        MdcRouterModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [MdcRouter],
                        declarations: [MdcRouter],
                    },] },
        ];
        return MdcRouterModule;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    /* global Reflect, Promise */
    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) {
          if (b.hasOwnProperty(p)) d[p] = b[p];
        }
      };

      return _extendStatics(d, b);
    };

    function __extends(d, b) {
      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var _assign = function __assign() {
      _assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];

          for (var p in s) {
            if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
        }

        return t;
      };

      return _assign.apply(this, arguments);
    };

    function _classCallCheck$1(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$1(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$1(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$1(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$1(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$1(subClass, superClass);
    }

    function _getPrototypeOf$1(o) {
      _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$1(o);
    }

    function _setPrototypeOf$1(o, p) {
      _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$1(o, p);
    }

    function _assertThisInitialized$1(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$1(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$1(self);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @template A
     */
    var MDCFoundation =
    /*#__PURE__*/
    function () {
      _createClass$1(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$1(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$1(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent =
    /*#__PURE__*/
    function () {
      _createClass$1(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$1(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$1(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Ripple. Provides an interface for managing
     * - classes
     * - dom
     * - CSS variables
     * - position
     * - dimensions
     * - scroll position
     * - event handlers
     * - unbounded, active and disabled states
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCRippleAdapter =
    /*#__PURE__*/
    function () {
      function MDCRippleAdapter() {
        _classCallCheck$1(this, MDCRippleAdapter);
      }

      _createClass$1(MDCRippleAdapter, [{
        key: "browserSupportsCssVars",

        /** @return {boolean} */
        value: function browserSupportsCssVars() {}
        /** @return {boolean} */

      }, {
        key: "isUnbounded",
        value: function isUnbounded() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceActive",
        value: function isSurfaceActive() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceDisabled",
        value: function isSurfaceDisabled() {}
        /** @param {string} className */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @param {!EventTarget} target */

      }, {
        key: "containsEventTarget",
        value: function containsEventTarget(target) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerDocumentInteractionHandler",
        value: function registerDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterDocumentInteractionHandler",
        value: function deregisterDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /**
         * @param {string} varName
         * @param {?number|string} value
         */

      }, {
        key: "updateCssVariable",
        value: function updateCssVariable(varName, value) {}
        /** @return {!ClientRect} */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}
        /** @return {{x: number, y: number}} */

      }, {
        key: "getWindowPageOffset",
        value: function getWindowPageOffset() {}
      }]);

      return MDCRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var cssClasses = {
      // Ripple is a special case where the "root" component is really a "mixin" of sorts,
      // given that it's an 'upgrade' to an existing component. That being said it is the root
      // CSS class that all other CSS classes derive from.
      ROOT: 'mdc-ripple-upgraded',
      UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
      BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
      FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
      FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
    };
    var strings = {
      VAR_LEFT: '--mdc-ripple-left',
      VAR_TOP: '--mdc-ripple-top',
      VAR_FG_SIZE: '--mdc-ripple-fg-size',
      VAR_FG_SCALE: '--mdc-ripple-fg-scale',
      VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
      VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
    };
    var numbers = {
      PADDING: 10,
      INITIAL_ORIGIN_SCALE: 0.6,
      DEACTIVATION_TIMEOUT_MS: 225,
      // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
      FG_DEACTIVATION_MS: 150,
      // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
      TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

    };

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
     * @private {boolean|undefined}
     */
    var supportsCssVariables_;
    /**
     * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
     * @private {boolean|undefined}
     */

    var supportsPassive_;
    /**
     * @param {!Window} windowObj
     * @return {boolean}
     */

    function detectEdgePseudoVarBug(windowObj) {
      // Detect versions of Edge with buggy var() support
      // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
      var document = windowObj.document;
      var node = document.createElement('div');
      node.className = 'mdc-ripple-surface--test-edge-var-bug';
      document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
      // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
      // but Firefox is known to support CSS custom properties correctly.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

      var computedStyle = windowObj.getComputedStyle(node);
      var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
      node.remove();
      return hasPseudoVarBug;
    }
    /**
     * @param {!Window} windowObj
     * @param {boolean=} forceRefresh
     * @return {boolean|undefined}
     */


    function supportsCssVariables(windowObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var supportsCssVariables = supportsCssVariables_;

      if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {
        return supportsCssVariables;
      }

      var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

      if (!supportsFunctionPresent) {
        return;
      }

      var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
      // See: README section on Safari

      var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

      if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVariables = !detectEdgePseudoVarBug(windowObj);
      } else {
        supportsCssVariables = false;
      }

      if (!forceRefresh) {
        supportsCssVariables_ = supportsCssVariables;
      }

      return supportsCssVariables;
    } //

    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|{passive: boolean}}
     */


    function applyPassive() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_ === undefined || forceRefresh) {
        var isSupported = false;

        try {
          globalObj.document.addEventListener('test', null, {
            get passive() {
              isSupported = true;
            }

          });
        } catch (e) {}

        supportsPassive_ = isSupported;
      }

      return supportsPassive_ ? {
        passive: true
      } : false;
    }
    /**
     * @param {!Object} HTMLElementPrototype
     * @return {!Array<string>}
     */


    function getMatchesProperty(HTMLElementPrototype) {
      return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(function (p) {
        return p in HTMLElementPrototype;
      }).pop();
    }
    /**
     * @param {!Event} ev
     * @param {{x: number, y: number}} pageOffset
     * @param {!ClientRect} clientRect
     * @return {{x: number, y: number}}
     */


    function getNormalizedEventCoords(ev, pageOffset, clientRect) {
      var x = pageOffset.x,
          y = pageOffset.y;
      var documentX = x + clientRect.left;
      var documentY = y + clientRect.top;
      var normalizedX;
      var normalizedY; // Determine touch point relative to the ripple container.

      if (ev.type === 'touchstart') {
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
      } else {
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
      }

      return {
        x: normalizedX,
        y: normalizedY
      };
    }

    var ACTIVATION_EVENT_TYPES = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

    var POINTER_DEACTIVATION_EVENT_TYPES = ['touchend', 'pointerup', 'mouseup']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

    /** @type {!Array<!EventTarget>} */

    var activatedTargets = [];
    /**
     * @extends {MDCFoundation<!MDCRippleAdapter>}
     */

    var MDCRippleFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$1(MDCRippleFoundation, _MDCFoundation);

      _createClass$1(MDCRippleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            browserSupportsCssVars: function browserSupportsCssVars()
            /* boolean - cached */
            {},
            isUnbounded: function isUnbounded()
            /* boolean */
            {},
            isSurfaceActive: function isSurfaceActive()
            /* boolean */
            {},
            isSurfaceDisabled: function isSurfaceDisabled()
            /* boolean */
            {},
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            containsEventTarget: function containsEventTarget()
            /* target: !EventTarget */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            updateCssVariable: function updateCssVariable()
            /* varName: string, value: string */
            {},
            computeBoundingRect: function computeBoundingRect()
            /* ClientRect */
            {},
            getWindowPageOffset: function getWindowPageOffset()
            /* {x: number, y: number} */
            {}
          };
        }
      }]);

      function MDCRippleFoundation(adapter) {
        var _this;

        _classCallCheck$1(this, MDCRippleFoundation);

        _this = _possibleConstructorReturn$1(this, _getPrototypeOf$1(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
        /** @private {number} */

        _this.layoutFrame_ = 0;
        /** @private {!ClientRect} */

        _this.frame_ =
        /** @type {!ClientRect} */
        {
          width: 0,
          height: 0
        };
        /** @private {!ActivationStateType} */

        _this.activationState_ = _this.defaultActivationState_();
        /** @private {number} */

        _this.initialSize_ = 0;
        /** @private {number} */

        _this.maxRadius_ = 0;
        /** @private {function(!Event)} */

        _this.activateHandler_ = function (e) {
          return _this.activate_(e);
        };
        /** @private {function(!Event)} */


        _this.deactivateHandler_ = function (e) {
          return _this.deactivate_(e);
        };
        /** @private {function(?Event=)} */


        _this.focusHandler_ = function () {
          return _this.handleFocus();
        };
        /** @private {function(?Event=)} */


        _this.blurHandler_ = function () {
          return _this.handleBlur();
        };
        /** @private {!Function} */


        _this.resizeHandler_ = function () {
          return _this.layout();
        };
        /** @private {{left: number, top:number}} */


        _this.unboundedCoords_ = {
          left: 0,
          top: 0
        };
        /** @private {number} */

        _this.fgScale_ = 0;
        /** @private {number} */

        _this.activationTimer_ = 0;
        /** @private {number} */

        _this.fgDeactivationRemovalTimer_ = 0;
        /** @private {boolean} */

        _this.activationAnimationHasEnded_ = false;
        /** @private {!Function} */

        _this.activationTimerCallback_ = function () {
          _this.activationAnimationHasEnded_ = true;

          _this.runDeactivationUXLogicIfReady_();
        };
        /** @private {?Event} */


        _this.previousActivationEvent_ = null;
        return _this;
      }
      /**
       * We compute this property so that we are not querying information about the client
       * until the point in time where the foundation requests it. This prevents scenarios where
       * client-side feature-detection may happen too early, such as when components are rendered on the server
       * and then initialized at mount time on the client.
       * @return {boolean}
       * @private
       */


      _createClass$1(MDCRippleFoundation, [{
        key: "isSupported_",
        value: function isSupported_() {
          return this.adapter_.browserSupportsCssVars();
        }
        /**
         * @return {!ActivationStateType}
         */

      }, {
        key: "defaultActivationState_",
        value: function defaultActivationState_() {
          return {
            isActivated: false,
            hasDeactivationUXRun: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
            activationEvent: null,
            isProgrammatic: false
          };
        }
        /** @override */

      }, {
        key: "init",
        value: function init() {
          var _this2 = this;

          if (!this.isSupported_()) {
            return;
          }

          this.registerRootHandlers_();
          var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$.ROOT,
              UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
          requestAnimationFrame(function () {
            _this2.adapter_.addClass(ROOT);

            if (_this2.adapter_.isUnbounded()) {
              _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


              _this2.layoutInternal_();
            }
          });
        }
        /** @override */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          if (!this.isSupported_()) {
            return;
          }

          if (this.activationTimer_) {
            clearTimeout(this.activationTimer_);
            this.activationTimer_ = 0;
            var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
            this.adapter_.removeClass(FG_ACTIVATION);
          }

          this.deregisterRootHandlers_();
          this.deregisterDeactivationHandlers_();
          var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$2.ROOT,
              UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
          requestAnimationFrame(function () {
            _this3.adapter_.removeClass(ROOT);

            _this3.adapter_.removeClass(UNBOUNDED);

            _this3.removeCssVars_();
          });
        }
        /** @private */

      }, {
        key: "registerRootHandlers_",
        value: function registerRootHandlers_() {
          var _this4 = this;

          ACTIVATION_EVENT_TYPES.forEach(function (type) {
            _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
          });
          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.registerResizeHandler(this.resizeHandler_);
          }
        }
        /**
         * @param {!Event} e
         * @private
         */

      }, {
        key: "registerDeactivationHandlers_",
        value: function registerDeactivationHandlers_(e) {
          var _this5 = this;

          if (e.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
          } else {
            POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
              _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
            });
          }
        }
        /** @private */

      }, {
        key: "deregisterRootHandlers_",
        value: function deregisterRootHandlers_() {
          var _this6 = this;

          ACTIVATION_EVENT_TYPES.forEach(function (type) {
            _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
          });
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          }
        }
        /** @private */

      }, {
        key: "deregisterDeactivationHandlers_",
        value: function deregisterDeactivationHandlers_() {
          var _this7 = this;

          this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
          POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
            _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
          });
        }
        /** @private */

      }, {
        key: "removeCssVars_",
        value: function removeCssVars_() {
          var _this8 = this;

          var strings$$1 = MDCRippleFoundation.strings;
          Object.keys(strings$$1).forEach(function (k) {
            if (k.indexOf('VAR_') === 0) {
              _this8.adapter_.updateCssVariable(strings$$1[k], null);
            }
          });
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "activate_",
        value: function activate_(e) {
          var _this9 = this;

          if (this.adapter_.isSurfaceDisabled()) {
            return;
          }

          var activationState = this.activationState_;

          if (activationState.isActivated) {
            return;
          } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


          var previousActivationEvent = this.previousActivationEvent_;
          var isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;

          if (isSameInteraction) {
            return;
          }

          activationState.isActivated = true;
          activationState.isProgrammatic = e === null;
          activationState.activationEvent = e;
          activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';
          var hasActivatedChild = e && activatedTargets.length > 0 && activatedTargets.some(function (target) {
            return _this9.adapter_.containsEventTarget(target);
          });

          if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
          }

          if (e) {
            activatedTargets.push(
            /** @type {!EventTarget} */
            e.target);
            this.registerDeactivationHandlers_(e);
          }

          activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

          if (activationState.wasElementMadeActive) {
            this.animateActivation_();
          }

          requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets = [];

            if (!activationState.wasElementMadeActive && (e.key === ' ' || e.keyCode === 32)) {
              // If space was pressed, try again within an rAF call to detect :active, because different UAs report
              // active states inconsistently when they're called within event handling code:
              // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
              // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
              // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
              // variable is set within a rAF callback for a submit button interaction (#2241).
              activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

              if (activationState.wasElementMadeActive) {
                _this9.animateActivation_();
              }
            }

            if (!activationState.wasElementMadeActive) {
              // Reset activation state immediately if element was not made active.
              _this9.activationState_ = _this9.defaultActivationState_();
            }
          });
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "checkElementMadeActive_",
        value: function checkElementMadeActive_(e) {
          return e && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
        }
        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: "activate",
        value: function activate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          this.activate_(event);
        }
        /** @private */

      }, {
        key: "animateActivation_",
        value: function animateActivation_() {
          var _this10 = this;

          var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
              VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
              VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
          var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
              FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
              FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
          var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
          this.layoutInternal_();
          var translateStart = '';
          var translateEnd = '';

          if (!this.adapter_.isUnbounded()) {
            var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
                startPoint = _this$getFgTranslatio.startPoint,
                endPoint = _this$getFgTranslatio.endPoint;

            translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
            translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
          }

          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

          clearTimeout(this.activationTimer_);
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.rmBoundedActivationClasses_();
          this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

          this.adapter_.computeBoundingRect();
          this.adapter_.addClass(FG_ACTIVATION);
          this.activationTimer_ = setTimeout(function () {
            return _this10.activationTimerCallback_();
          }, DEACTIVATION_TIMEOUT_MS);
        }
        /**
         * @private
         * @return {{startPoint: PointType, endPoint: PointType}}
         */

      }, {
        key: "getFgTranslationCoordinates_",
        value: function getFgTranslationCoordinates_() {
          var _this$activationState = this.activationState_,
              activationEvent = _this$activationState.activationEvent,
              wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
          var startPoint;

          if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords(
            /** @type {!Event} */
            activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
          } else {
            startPoint = {
              x: this.frame_.width / 2,
              y: this.frame_.height / 2
            };
          } // Center the element around the start point.


          startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
          };
          var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
          };
          return {
            startPoint: startPoint,
            endPoint: endPoint
          };
        }
        /** @private */

      }, {
        key: "runDeactivationUXLogicIfReady_",
        value: function runDeactivationUXLogicIfReady_() {
          var _this11 = this;

          // This method is called both when a pointing device is released, and when the activation animation ends.
          // The deactivation animation should only run after both of those occur.
          var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
          var _this$activationState2 = this.activationState_,
              hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
              isActivated = _this$activationState2.isActivated;
          var activationHasEnded = hasDeactivationUXRun || !isActivated;

          if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
              _this11.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers.FG_DEACTIVATION_MS);
          }
        }
        /** @private */

      }, {
        key: "rmBoundedActivationClasses_",
        value: function rmBoundedActivationClasses_() {
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
          this.adapter_.removeClass(FG_ACTIVATION);
          this.activationAnimationHasEnded_ = false;
          this.adapter_.computeBoundingRect();
        }
      }, {
        key: "resetActivationState_",
        value: function resetActivationState_() {
          var _this12 = this;

          this.previousActivationEvent_ = this.activationState_.activationEvent;
          this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
          // Store the previous event until it's safe to assume that subsequent events are for new interactions.

          setTimeout(function () {
            return _this12.previousActivationEvent_ = null;
          }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "deactivate_",
        value: function deactivate_(e) {
          var _this13 = this;

          var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

          if (!activationState.isActivated) {
            return;
          }

          var state =
          /** @type {!ActivationStateType} */
          Object.assign({}, activationState);

          if (activationState.isProgrammatic) {
            var evtObject = null;
            requestAnimationFrame(function () {
              return _this13.animateDeactivation_(evtObject, state);
            });
            this.resetActivationState_();
          } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
              _this13.activationState_.hasDeactivationUXRun = true;

              _this13.animateDeactivation_(e, state);

              _this13.resetActivationState_();
            });
          }
        }
        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          this.deactivate_(event);
        }
        /**
         * @param {Event} e
         * @param {!ActivationStateType} options
         * @private
         */

      }, {
        key: "animateDeactivation_",
        value: function animateDeactivation_(e, _ref) {
          var wasActivatedByPointer = _ref.wasActivatedByPointer,
              wasElementMadeActive = _ref.wasElementMadeActive;

          if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this14 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }

          this.layoutFrame_ = requestAnimationFrame(function () {
            _this14.layoutInternal_();

            _this14.layoutFrame_ = 0;
          });
        }
        /** @private */

      }, {
        key: "layoutInternal_",
        value: function layoutInternal_() {
          var _this15 = this;

          this.frame_ = this.adapter_.computeBoundingRect();
          var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
          // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
          // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
          // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
          // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
          // `overflow: hidden`.

          var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
          };

          this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

          this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;
          this.fgScale_ = this.maxRadius_ / this.initialSize_;
          this.updateLayoutCssVars_();
        }
        /** @private */

      }, {
        key: "updateLayoutCssVars_",
        value: function updateLayoutCssVars_() {
          var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
              VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
              VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
              VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
              VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
          this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
          this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

          if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
              left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
              top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };
            this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
            this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
          }
        }
        /** @param {boolean} unbounded */

      }, {
        key: "setUnbounded",
        value: function setUnbounded(unbounded) {
          var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

          if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
          } else {
            this.adapter_.removeClass(UNBOUNDED);
          }
        }
      }, {
        key: "handleFocus",
        value: function handleFocus() {
          var _this16 = this;

          requestAnimationFrame(function () {
            return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }, {
        key: "handleBlur",
        value: function handleBlur() {
          var _this17 = this;

          requestAnimationFrame(function () {
            return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }]);

      return MDCRippleFoundation;
    }(MDCFoundation);

    /**
     * @extends MDCComponent<!MDCRippleFoundation>
     */

    var MDCRipple =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$1(MDCRipple, _MDCComponent);

      /** @param {...?} args */
      function MDCRipple() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$1(this, MDCRipple);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$1(this, (_getPrototypeOf2 = _getPrototypeOf$1(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {boolean} */

        _this.disabled = false;
        /** @private {boolean} */

        _this.unbounded_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @param {{isUnbounded: (boolean|undefined)}=} options
       * @return {!MDCRipple}
       */


      _createClass$1(MDCRipple, [{
        key: "setUnbounded_",

        /**
         * Closure Compiler throws an access control error when directly accessing a
         * protected or private property inside a getter/setter, like unbounded above.
         * By accessing the protected property inside a method, we solve that problem.
         * That's why this function exists.
         * @private
         */
        value: function setUnbounded_() {
          this.foundation_.setUnbounded(this.unbounded_);
        }
      }, {
        key: "activate",
        value: function activate() {
          this.foundation_.activate();
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
        /**
         * @return {!MDCRippleFoundation}
         * @override
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          return new MDCRippleFoundation(MDCRipple.createAdapter(this));
        }
        /** @override */

      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
        }
      }, {
        key: "unbounded",

        /** @return {boolean} */
        get: function get() {
          return this.unbounded_;
        }
        /** @param {boolean} unbounded */
        ,
        set: function set(unbounded) {
          this.unbounded_ = Boolean(unbounded);
          this.setUnbounded_();
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref$isUnbounded = _ref.isUnbounded,
              isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

          var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

          if (isUnbounded !== undefined) {
            ripple.unbounded =
            /** @type {boolean} */
            isUnbounded;
          }

          return ripple;
        }
        /**
         * @param {!RippleCapableSurface} instance
         * @return {!MDCRippleAdapter}
         */

      }, {
        key: "createAdapter",
        value: function createAdapter(instance) {
          var MATCHES = getMatchesProperty(HTMLElement.prototype);
          return {
            browserSupportsCssVars: function browserSupportsCssVars() {
              return supportsCssVariables(window);
            },
            isUnbounded: function isUnbounded() {
              return instance.unbounded;
            },
            isSurfaceActive: function isSurfaceActive() {
              return instance.root_[MATCHES](':active');
            },
            isSurfaceDisabled: function isSurfaceDisabled() {
              return instance.disabled;
            },
            addClass: function addClass(className) {
              return instance.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return instance.root_.classList.remove(className);
            },
            containsEventTarget: function containsEventTarget(target) {
              return instance.root_.contains(target);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return instance.root_.addEventListener(evtType, handler, applyPassive());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return instance.root_.removeEventListener(evtType, handler, applyPassive());
            },
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.addEventListener(evtType, handler, applyPassive());
            },
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.removeEventListener(evtType, handler, applyPassive());
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return instance.root_.style.setProperty(varName, value);
            },
            computeBoundingRect: function computeBoundingRect() {
              return instance.root_.getBoundingClientRect();
            },
            getWindowPageOffset: function getWindowPageOffset() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            }
          };
        }
      }]);

      return MDCRipple;
    }(MDCComponent);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcRipple = /** @class */ (function () {
        function MdcRipple(_registry, elementRef) {
            var _this = this;
            this._registry = _registry;
            this.elementRef = elementRef;
            this._unbounded = false;
            this._surfaceActive = false;
            this._mdcAdapter = {
                browserSupportsCssVars: function () { return (typeof window !== 'undefined') ? supportsCssVariables(window) : false; },
                isUnbounded: function () { return _this._unbounded; },
                isSurfaceActive: function () { return _this.isSurfaceActive(); },
                isSurfaceDisabled: function () { return _this.isSurfaceDisabled(); },
                addClass: function (className) { return _this._root.classList.add(className); },
                removeClass: function (className) { return _this._root.classList.remove(className); },
                containsEventTarget: function (target) { return _this._root.contains(target); },
                registerInteractionHandler: function (evtType, handler) {
                    return _this._registry.listen(evtType, handler, _this._interactionElement ? _this._interactionElement : _this._root, applyPassive());
                },
                deregisterInteractionHandler: function (evtType, handler) {
                    return _this._registry.unlisten(evtType, handler);
                },
                registerDocumentInteractionHandler: function (evtType, handler) {
                    return _this._registry.listen(evtType, handler, document, applyPassive());
                },
                deregisterDocumentInteractionHandler: function (evtType, handler) {
                    return _this._registry.unlisten(evtType, handler);
                },
                registerResizeHandler: function (handler) {
                    if (isBrowser()) {
                        _this._registry.listen('resize', handler, window);
                    }
                },
                deregisterResizeHandler: function (handler) { return _this._registry.unlisten('resize', handler); },
                updateCssVariable: function (varName, value) { return _this._root.style.setProperty(varName, value); },
                computeBoundingRect: function () { return _this._root.getBoundingClientRect(); },
                getWindowPageOffset: function () {
                    return {
                        x: (typeof window !== 'undefined') ? window.pageXOffset : 0,
                        y: (typeof window !== 'undefined') ? window.pageYOffset : 0
                    };
                }
            };
        }
        /**
         * @param {?} root
         * @param {?=} unbounded
         * @param {?=} interactionElement
         * @return {?}
         */
        MdcRipple.prototype.attachTo = /**
         * @param {?} root
         * @param {?=} unbounded
         * @param {?=} interactionElement
         * @return {?}
         */
        function (root, unbounded, interactionElement) {
            if (unbounded === void 0) { unbounded = false; }
            this._root = root;
            if (interactionElement) {
                this._interactionElement = interactionElement;
            }
            this._foundation = new MDCRippleFoundation(this._mdcAdapter);
            this.setUnbounded(unbounded);
            this._foundation.init();
        };
        /**
         * @return {?}
         */
        MdcRipple.prototype.init = /**
         * @return {?}
         */
        function () {
            this._foundation = new MDCRippleFoundation(this._mdcAdapter);
            this._foundation.init();
        };
        /**
         * @return {?}
         */
        MdcRipple.prototype.destroy = /**
         * @return {?}
         */
        function () {
            if (this._foundation) {
                this._foundation.destroy();
                this._foundation = null;
            }
        };
        /**
         * @param {?=} event
         * @return {?}
         */
        MdcRipple.prototype.activate = /**
         * @param {?=} event
         * @return {?}
         */
        function (event) {
            this._foundation.activate(event);
        };
        /**
         * @param {?=} event
         * @return {?}
         */
        MdcRipple.prototype.deactivate = /**
         * @param {?=} event
         * @return {?}
         */
        function (event) {
            this._foundation.deactivate(event);
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MdcRipple.prototype.setUnbounded = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._unbounded = value;
            this._foundation.setUnbounded(value);
        };
        /**
         * @return {?}
         */
        MdcRipple.prototype.layout = /**
         * @return {?}
         */
        function () {
            this._foundation.layout();
        };
        /**
         * @deprecated
         * @deletion-target in-tracker
         */
        /**
         * @deprecated
         * \@deletion-target in-tracker
         * @param {?} active
         * @return {?}
         */
        MdcRipple.prototype.setSurfaceActive = /**
         * @deprecated
         * \@deletion-target in-tracker
         * @param {?} active
         * @return {?}
         */
        function (active) {
            this._surfaceActive = active;
        };
        /**
         * @return {?}
         */
        MdcRipple.prototype.isSurfaceDisabled = /**
         * @return {?}
         */
        function () {
            return this._interactionElement ? this._interactionElement.attributes.getNamedItem('disabled') ? true : false :
                this._root.attributes.getNamedItem('disabled') ? true : false;
        };
        /**
         * @return {?}
         */
        MdcRipple.prototype.isSurfaceActive = /**
         * @return {?}
         */
        function () {
            return this._surfaceActive || this._root[getMatchesProperty(HTMLElement.prototype)](':active');
        };
        /**
         * @return {?}
         */
        MdcRipple.prototype.isAttached = /**
         * @return {?}
         */
        function () {
            return !!this._foundation;
        };
        MdcRipple.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        MdcRipple.ctorParameters = function () { return [
            { type: EventRegistry },
            { type: core.ElementRef }
        ]; };
        return MdcRipple;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcRippleComponent = /** @class */ (function () {
        function MdcRippleComponent(_ngZone, _changeDetectorRef, _ripple, _renderer, elementRef) {
            this._ngZone = _ngZone;
            this._changeDetectorRef = _changeDetectorRef;
            this._ripple = _ripple;
            this._renderer = _renderer;
            this.elementRef = elementRef;
            this._unbounded = false;
        }
        Object.defineProperty(MdcRippleComponent.prototype, "ripple", {
            get: /**
             * @return {?}
             */
            function () {
                return this._ripple;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcRippleComponent.prototype, "primary", {
            get: /**
             * @return {?}
             */
            function () { return this._primary; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setPrimary(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcRippleComponent.prototype, "secondary", {
            get: /**
             * @return {?}
             */
            function () { return this._secondary; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setSecondary(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcRippleComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._disabled = toBoolean(value);
                this._disabled ? this.ripple.destroy() : this.ripple.init();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcRippleComponent.prototype, "attachTo", {
            get: /**
             * @return {?}
             */
            function () { return this._attachTo; },
            set: /**
             * @param {?} element
             * @return {?}
             */
            function (element) {
                if (this._attachTo !== element) {
                    this.setAttachTo(element);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcRippleComponent.prototype, "unbounded", {
            get: /**
             * @return {?}
             */
            function () { return this._unbounded; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setUnbounded(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcRippleComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this._ngZone.runOutsideAngular(function () { return setTimeout(function () {
                _this.setAttachTo(_this.attachTo ? _this.attachTo : _this._getHostElement());
            }, 10); });
        };
        /**
         * @return {?}
         */
        MdcRippleComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.ripple.destroy();
        };
        /**
         * @param {?} unbounded
         * @return {?}
         */
        MdcRippleComponent.prototype.setUnbounded = /**
         * @param {?} unbounded
         * @return {?}
         */
        function (unbounded) {
            this._unbounded = unbounded;
            if (this.ripple.isAttached()) {
                this.ripple.setUnbounded(unbounded);
            }
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} element
         * @param {?=} unbounded
         * @return {?}
         */
        MdcRippleComponent.prototype.setAttachTo = /**
         * @param {?} element
         * @param {?=} unbounded
         * @return {?}
         */
        function (element, unbounded) {
            this._attachTo = element;
            this._renderer.addClass(this.attachTo, 'mdc-ripple-surface');
            this.ripple.attachTo(element, this.unbounded);
            this.setUnbounded(unbounded ? unbounded : this.unbounded);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} primary
         * @return {?}
         */
        MdcRippleComponent.prototype.setPrimary = /**
         * @param {?} primary
         * @return {?}
         */
        function (primary) {
            this._primary = primary;
            this._primary ? this._renderer.addClass(this.attachTo, 'mdc-ripple-surface--primary')
                : this._renderer.removeClass(this.attachTo, 'mdc-ripple-surface--primary');
        };
        /**
         * @param {?} secondary
         * @return {?}
         */
        MdcRippleComponent.prototype.setSecondary = /**
         * @param {?} secondary
         * @return {?}
         */
        function (secondary) {
            this._secondary = secondary;
            this._secondary ? this._renderer.addClass(this.attachTo, 'mdc-ripple-surface--accent')
                : this._renderer.removeClass(this.attachTo, 'mdc-ripple-surface--accent');
        };
        /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        MdcRippleComponent.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcRippleComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'mdc-ripple, [mdc-ripple]',
                        template: '<ng-content></ng-content>',
                        providers: [
                            MdcRipple,
                            EventRegistry
                        ],
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcRippleComponent.ctorParameters = function () { return [
            { type: core.NgZone },
            { type: core.ChangeDetectorRef },
            { type: MdcRipple },
            { type: core.Renderer2 },
            { type: core.ElementRef }
        ]; };
        MdcRippleComponent.propDecorators = {
            primary: [{ type: core.Input }],
            secondary: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            attachTo: [{ type: core.Input }],
            unbounded: [{ type: core.Input }]
        };
        return MdcRippleComponent;
    }());
    var MdcRippleDirective = /** @class */ (function (_super) {
        __extends(MdcRippleDirective, _super);
        function MdcRippleDirective(_ngZone, _changeDetectorRef, _ripple, _renderer, elementRef) {
            var _this = _super.call(this, _ngZone, _changeDetectorRef, _ripple, _renderer, elementRef) || this;
            _this._renderer.setAttribute(_this.elementRef.nativeElement, 'data-mdc-ripple-is-unbounded', '');
            _this.setUnbounded(true);
            return _this;
        }
        MdcRippleDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcRipple]',
                        providers: [
                            MdcRipple,
                            EventRegistry
                        ],
                    },] },
        ];
        /** @nocollapse */
        MdcRippleDirective.ctorParameters = function () { return [
            { type: core.NgZone },
            { type: core.ChangeDetectorRef },
            { type: MdcRipple },
            { type: core.Renderer2 },
            { type: core.ElementRef }
        ]; };
        return MdcRippleDirective;
    }(MdcRippleComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcRippleModule = /** @class */ (function () {
        function MdcRippleModule() {
        }
        MdcRippleModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [MdcRippleComponent, MdcRippleDirective],
                        declarations: [MdcRippleComponent, MdcRippleDirective],
                    },] },
        ];
        return MdcRippleModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcAppBarRow = /** @class */ (function () {
        function MdcAppBarRow(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcAppBarRow.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-app-bar-row, [mdcAppBarRow]',
                        exportAs: 'mdcAppBarRow'
                    },] },
        ];
        /** @nocollapse */
        MdcAppBarRow.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcAppBarRow.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-top-app-bar__row',] }]
        };
        return MdcAppBarRow;
    }());
    var MdcAppBarSection = /** @class */ (function () {
        function MdcAppBarSection(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
            this.role = 'toolbar';
        }
        Object.defineProperty(MdcAppBarSection.prototype, "classAlignStart", {
            get: /**
             * @return {?}
             */
            function () {
                return this.align === 'start' ? 'mdc-top-app-bar__section--align-start' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcAppBarSection.prototype, "classAlignEnd", {
            get: /**
             * @return {?}
             */
            function () {
                return this.align === 'end' ? 'mdc-top-app-bar__section--align-end' : '';
            },
            enumerable: true,
            configurable: true
        });
        MdcAppBarSection.decorators = [
            { type: core.Component, args: [{selector: 'mdc-app-bar-section, [mdcAppBarSection]',
                        exportAs: 'mdcAppBarSection',
                        template: "\n  <ng-content></ng-content>\n  <span class=\"mdc-top-app-bar__title\" *ngIf=\"title\">{{title}}</span>\n  ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcAppBarSection.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcAppBarSection.propDecorators = {
            title: [{ type: core.Input }],
            align: [{ type: core.Input }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-top-app-bar__section',] }],
            role: [{ type: core.HostBinding, args: ['attr.role',] }],
            classAlignStart: [{ type: core.HostBinding, args: ['class.mdc-top-app-bar__section--align-start',] }],
            classAlignEnd: [{ type: core.HostBinding, args: ['class.mdc-top-app-bar__section--align-end',] }]
        };
        return MdcAppBarSection;
    }());
    var MdcAppBarActionItem = /** @class */ (function () {
        function MdcAppBarActionItem(elementRef, _ripple) {
            this.elementRef = elementRef;
            this._ripple = _ripple;
            this.role = 'button';
            this.isHostClass = true;
            _ripple.attachTo(this.elementRef.nativeElement, true);
        }
        MdcAppBarActionItem.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-icon[mdcAppBarActionItem], [mdcAppBarActionItem], mdc-app-bar-action-item',
                        exportAs: 'mdcAppBarActionItem',
                        providers: [MdcRipple]
                    },] },
        ];
        /** @nocollapse */
        MdcAppBarActionItem.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: MdcRipple }
        ]; };
        MdcAppBarActionItem.propDecorators = {
            role: [{ type: core.HostBinding, args: ['attr.role',] }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-top-app-bar__action-item',] }]
        };
        return MdcAppBarActionItem;
    }());
    var MdcAppBarNavigationIcon = /** @class */ (function () {
        function MdcAppBarNavigationIcon(elementRef, _ripple) {
            this.elementRef = elementRef;
            this._ripple = _ripple;
            this.role = 'button';
            this.isHostClass = true;
            _ripple.attachTo(this.getHostElement(), true);
        }
        /** Retrieves the DOM element of the directive. */
        /**
         * Retrieves the DOM element of the directive.
         * @return {?}
         */
        MdcAppBarNavigationIcon.prototype.getHostElement = /**
         * Retrieves the DOM element of the directive.
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcAppBarNavigationIcon.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-icon[mdcAppBarNavIcon], [mdcAppBarNavIcon], mdc-icon[mdcAppBarNavigationIcon]',
                        exportAs: 'mdcAppBarNavigationIcon',
                        providers: [MdcRipple]
                    },] },
        ];
        /** @nocollapse */
        MdcAppBarNavigationIcon.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: MdcRipple }
        ]; };
        MdcAppBarNavigationIcon.propDecorators = {
            role: [{ type: core.HostBinding, args: ['attr.role',] }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-top-app-bar__navigation-icon',] }]
        };
        return MdcAppBarNavigationIcon;
    }());
    var MdcAppBarTitle = /** @class */ (function () {
        function MdcAppBarTitle(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcAppBarTitle.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-app-bar-title, [mdcAppBarTitle]',
                        exportAs: 'mdcAppBarTitle'
                    },] },
        ];
        /** @nocollapse */
        MdcAppBarTitle.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcAppBarTitle.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-top-app-bar__title',] }]
        };
        return MdcAppBarTitle;
    }());

    function _classCallCheck$2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$2(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$2(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$2(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$2(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$2(subClass, superClass);
    }

    function _getPrototypeOf$2(o) {
      _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$2(o);
    }

    function _setPrototypeOf$2(o, p) {
      _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$2(o, p);
    }

    function _assertThisInitialized$2(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$2(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$2(self);
    }

    function _superPropBase$1(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$2(object);
        if (object === null) break;
      }

      return object;
    }

    function _get$1(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$1 = Reflect.get;
      } else {
        _get$1 = function _get(target, property, receiver) {
          var base = _superPropBase$1(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get$1(target, property, receiver || target);
    }

    /**
     * @license
     * Copyright 2018 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Top App Bar
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Top App Bar into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCTopAppBarAdapter =
    /*#__PURE__*/
    function () {
      function MDCTopAppBarAdapter() {
        _classCallCheck$2(this, MDCTopAppBarAdapter);
      }

      _createClass$2(MDCTopAppBarAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the root Element.
         * @param {string} className
         */
        value: function addClass(className) {}
        /**
         * Removes a class from the root Element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Returns true if the root Element contains the given class.
         * @param {string} className
         * @return {boolean}
         */

      }, {
        key: "hasClass",
        value: function hasClass(className) {}
        /**
         * Sets the specified inline style property on the root Element to the given value.
         * @param {string} property
         * @param {string} value
         */

      }, {
        key: "setStyle",
        value: function setStyle(property, value) {}
        /**
         * Gets the height of the top app bar.
         * @return {number}
         */

      }, {
        key: "getTopAppBarHeight",
        value: function getTopAppBarHeight() {}
        /**
         * Registers an event handler on the navigation icon element for a given event.
         * @param {string} type
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerNavigationIconInteractionHandler",
        value: function registerNavigationIconInteractionHandler(type, handler) {}
        /**
         * Deregisters an event handler on the navigation icon element for a given event.
         * @param {string} type
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterNavigationIconInteractionHandler",
        value: function deregisterNavigationIconInteractionHandler(type, handler) {}
        /**
         * Emits an event when the navigation icon is clicked.
         */

      }, {
        key: "notifyNavigationIconClicked",
        value: function notifyNavigationIconClicked() {}
        /** @param {function(!Event)} handler */

      }, {
        key: "registerScrollHandler",
        value: function registerScrollHandler(handler) {}
        /** @param {function(!Event)} handler */

      }, {
        key: "deregisterScrollHandler",
        value: function deregisterScrollHandler(handler) {}
        /** @param {function(!Event)} handler */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /** @param {function(!Event)} handler */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /** @return {number} */

      }, {
        key: "getViewportScrollY",
        value: function getViewportScrollY() {}
        /** @return {number} */

      }, {
        key: "getTotalActionItems",
        value: function getTotalActionItems() {}
      }]);

      return MDCTopAppBarAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @template A
     */
    var MDCFoundation$1 =
    /*#__PURE__*/
    function () {
      _createClass$2(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$2(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$2(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$1 =
    /*#__PURE__*/
    function () {
      _createClass$2(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$1());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$2(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$2(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Ripple. Provides an interface for managing
     * - classes
     * - dom
     * - CSS variables
     * - position
     * - dimensions
     * - scroll position
     * - event handlers
     * - unbounded, active and disabled states
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCRippleAdapter$1 =
    /*#__PURE__*/
    function () {
      function MDCRippleAdapter() {
        _classCallCheck$2(this, MDCRippleAdapter);
      }

      _createClass$2(MDCRippleAdapter, [{
        key: "browserSupportsCssVars",

        /** @return {boolean} */
        value: function browserSupportsCssVars() {}
        /** @return {boolean} */

      }, {
        key: "isUnbounded",
        value: function isUnbounded() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceActive",
        value: function isSurfaceActive() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceDisabled",
        value: function isSurfaceDisabled() {}
        /** @param {string} className */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @param {!EventTarget} target */

      }, {
        key: "containsEventTarget",
        value: function containsEventTarget(target) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerDocumentInteractionHandler",
        value: function registerDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterDocumentInteractionHandler",
        value: function deregisterDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /**
         * @param {string} varName
         * @param {?number|string} value
         */

      }, {
        key: "updateCssVariable",
        value: function updateCssVariable(varName, value) {}
        /** @return {!ClientRect} */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}
        /** @return {{x: number, y: number}} */

      }, {
        key: "getWindowPageOffset",
        value: function getWindowPageOffset() {}
      }]);

      return MDCRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var cssClasses$1 = {
      // Ripple is a special case where the "root" component is really a "mixin" of sorts,
      // given that it's an 'upgrade' to an existing component. That being said it is the root
      // CSS class that all other CSS classes derive from.
      ROOT: 'mdc-ripple-upgraded',
      UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
      BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
      FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
      FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
    };
    var strings$1 = {
      VAR_LEFT: '--mdc-ripple-left',
      VAR_TOP: '--mdc-ripple-top',
      VAR_FG_SIZE: '--mdc-ripple-fg-size',
      VAR_FG_SCALE: '--mdc-ripple-fg-scale',
      VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
      VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
    };
    var numbers$1 = {
      PADDING: 10,
      INITIAL_ORIGIN_SCALE: 0.6,
      DEACTIVATION_TIMEOUT_MS: 225,
      // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
      FG_DEACTIVATION_MS: 150,
      // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
      TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

    };

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
     * @private {boolean|undefined}
     */
    var supportsCssVariables_$1;
    /**
     * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
     * @private {boolean|undefined}
     */

    var supportsPassive_$1;
    /**
     * @param {!Window} windowObj
     * @return {boolean}
     */

    function detectEdgePseudoVarBug$1(windowObj) {
      // Detect versions of Edge with buggy var() support
      // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
      var document = windowObj.document;
      var node = document.createElement('div');
      node.className = 'mdc-ripple-surface--test-edge-var-bug';
      document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
      // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
      // but Firefox is known to support CSS custom properties correctly.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

      var computedStyle = windowObj.getComputedStyle(node);
      var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
      node.remove();
      return hasPseudoVarBug;
    }
    /**
     * @param {!Window} windowObj
     * @param {boolean=} forceRefresh
     * @return {boolean|undefined}
     */


    function supportsCssVariables$1(windowObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var supportsCssVariables = supportsCssVariables_$1;

      if (typeof supportsCssVariables_$1 === 'boolean' && !forceRefresh) {
        return supportsCssVariables;
      }

      var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

      if (!supportsFunctionPresent) {
        return;
      }

      var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
      // See: README section on Safari

      var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

      if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVariables = !detectEdgePseudoVarBug$1(windowObj);
      } else {
        supportsCssVariables = false;
      }

      if (!forceRefresh) {
        supportsCssVariables_$1 = supportsCssVariables;
      }

      return supportsCssVariables;
    } //

    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|{passive: boolean}}
     */


    function applyPassive$1() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_$1 === undefined || forceRefresh) {
        var isSupported = false;

        try {
          globalObj.document.addEventListener('test', null, {
            get passive() {
              isSupported = true;
            }

          });
        } catch (e) {}

        supportsPassive_$1 = isSupported;
      }

      return supportsPassive_$1 ? {
        passive: true
      } : false;
    }
    /**
     * @param {!Object} HTMLElementPrototype
     * @return {!Array<string>}
     */


    function getMatchesProperty$1(HTMLElementPrototype) {
      return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(function (p) {
        return p in HTMLElementPrototype;
      }).pop();
    }
    /**
     * @param {!Event} ev
     * @param {{x: number, y: number}} pageOffset
     * @param {!ClientRect} clientRect
     * @return {{x: number, y: number}}
     */


    function getNormalizedEventCoords$1(ev, pageOffset, clientRect) {
      var x = pageOffset.x,
          y = pageOffset.y;
      var documentX = x + clientRect.left;
      var documentY = y + clientRect.top;
      var normalizedX;
      var normalizedY; // Determine touch point relative to the ripple container.

      if (ev.type === 'touchstart') {
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
      } else {
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
      }

      return {
        x: normalizedX,
        y: normalizedY
      };
    }

    var ACTIVATION_EVENT_TYPES$1 = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

    var POINTER_DEACTIVATION_EVENT_TYPES$1 = ['touchend', 'pointerup', 'mouseup']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

    /** @type {!Array<!EventTarget>} */

    var activatedTargets$1 = [];
    /**
     * @extends {MDCFoundation<!MDCRippleAdapter>}
     */

    var MDCRippleFoundation$1 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$2(MDCRippleFoundation, _MDCFoundation);

      _createClass$2(MDCRippleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$1;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$1;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers$1;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            browserSupportsCssVars: function browserSupportsCssVars()
            /* boolean - cached */
            {},
            isUnbounded: function isUnbounded()
            /* boolean */
            {},
            isSurfaceActive: function isSurfaceActive()
            /* boolean */
            {},
            isSurfaceDisabled: function isSurfaceDisabled()
            /* boolean */
            {},
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            containsEventTarget: function containsEventTarget()
            /* target: !EventTarget */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            updateCssVariable: function updateCssVariable()
            /* varName: string, value: string */
            {},
            computeBoundingRect: function computeBoundingRect()
            /* ClientRect */
            {},
            getWindowPageOffset: function getWindowPageOffset()
            /* {x: number, y: number} */
            {}
          };
        }
      }]);

      function MDCRippleFoundation(adapter) {
        var _this;

        _classCallCheck$2(this, MDCRippleFoundation);

        _this = _possibleConstructorReturn$2(this, _getPrototypeOf$2(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
        /** @private {number} */

        _this.layoutFrame_ = 0;
        /** @private {!ClientRect} */

        _this.frame_ =
        /** @type {!ClientRect} */
        {
          width: 0,
          height: 0
        };
        /** @private {!ActivationStateType} */

        _this.activationState_ = _this.defaultActivationState_();
        /** @private {number} */

        _this.initialSize_ = 0;
        /** @private {number} */

        _this.maxRadius_ = 0;
        /** @private {function(!Event)} */

        _this.activateHandler_ = function (e) {
          return _this.activate_(e);
        };
        /** @private {function(!Event)} */


        _this.deactivateHandler_ = function (e) {
          return _this.deactivate_(e);
        };
        /** @private {function(?Event=)} */


        _this.focusHandler_ = function () {
          return _this.handleFocus();
        };
        /** @private {function(?Event=)} */


        _this.blurHandler_ = function () {
          return _this.handleBlur();
        };
        /** @private {!Function} */


        _this.resizeHandler_ = function () {
          return _this.layout();
        };
        /** @private {{left: number, top:number}} */


        _this.unboundedCoords_ = {
          left: 0,
          top: 0
        };
        /** @private {number} */

        _this.fgScale_ = 0;
        /** @private {number} */

        _this.activationTimer_ = 0;
        /** @private {number} */

        _this.fgDeactivationRemovalTimer_ = 0;
        /** @private {boolean} */

        _this.activationAnimationHasEnded_ = false;
        /** @private {!Function} */

        _this.activationTimerCallback_ = function () {
          _this.activationAnimationHasEnded_ = true;

          _this.runDeactivationUXLogicIfReady_();
        };
        /** @private {?Event} */


        _this.previousActivationEvent_ = null;
        return _this;
      }
      /**
       * We compute this property so that we are not querying information about the client
       * until the point in time where the foundation requests it. This prevents scenarios where
       * client-side feature-detection may happen too early, such as when components are rendered on the server
       * and then initialized at mount time on the client.
       * @return {boolean}
       * @private
       */


      _createClass$2(MDCRippleFoundation, [{
        key: "isSupported_",
        value: function isSupported_() {
          return this.adapter_.browserSupportsCssVars();
        }
        /**
         * @return {!ActivationStateType}
         */

      }, {
        key: "defaultActivationState_",
        value: function defaultActivationState_() {
          return {
            isActivated: false,
            hasDeactivationUXRun: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
            activationEvent: null,
            isProgrammatic: false
          };
        }
        /** @override */

      }, {
        key: "init",
        value: function init() {
          var _this2 = this;

          if (!this.isSupported_()) {
            return;
          }

          this.registerRootHandlers_();
          var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$.ROOT,
              UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
          requestAnimationFrame(function () {
            _this2.adapter_.addClass(ROOT);

            if (_this2.adapter_.isUnbounded()) {
              _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


              _this2.layoutInternal_();
            }
          });
        }
        /** @override */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          if (!this.isSupported_()) {
            return;
          }

          if (this.activationTimer_) {
            clearTimeout(this.activationTimer_);
            this.activationTimer_ = 0;
            var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
            this.adapter_.removeClass(FG_ACTIVATION);
          }

          this.deregisterRootHandlers_();
          this.deregisterDeactivationHandlers_();
          var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$2.ROOT,
              UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
          requestAnimationFrame(function () {
            _this3.adapter_.removeClass(ROOT);

            _this3.adapter_.removeClass(UNBOUNDED);

            _this3.removeCssVars_();
          });
        }
        /** @private */

      }, {
        key: "registerRootHandlers_",
        value: function registerRootHandlers_() {
          var _this4 = this;

          ACTIVATION_EVENT_TYPES$1.forEach(function (type) {
            _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
          });
          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.registerResizeHandler(this.resizeHandler_);
          }
        }
        /**
         * @param {!Event} e
         * @private
         */

      }, {
        key: "registerDeactivationHandlers_",
        value: function registerDeactivationHandlers_(e) {
          var _this5 = this;

          if (e.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
          } else {
            POINTER_DEACTIVATION_EVENT_TYPES$1.forEach(function (type) {
              _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
            });
          }
        }
        /** @private */

      }, {
        key: "deregisterRootHandlers_",
        value: function deregisterRootHandlers_() {
          var _this6 = this;

          ACTIVATION_EVENT_TYPES$1.forEach(function (type) {
            _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
          });
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          }
        }
        /** @private */

      }, {
        key: "deregisterDeactivationHandlers_",
        value: function deregisterDeactivationHandlers_() {
          var _this7 = this;

          this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
          POINTER_DEACTIVATION_EVENT_TYPES$1.forEach(function (type) {
            _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
          });
        }
        /** @private */

      }, {
        key: "removeCssVars_",
        value: function removeCssVars_() {
          var _this8 = this;

          var strings$$1 = MDCRippleFoundation.strings;
          Object.keys(strings$$1).forEach(function (k) {
            if (k.indexOf('VAR_') === 0) {
              _this8.adapter_.updateCssVariable(strings$$1[k], null);
            }
          });
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "activate_",
        value: function activate_(e) {
          var _this9 = this;

          if (this.adapter_.isSurfaceDisabled()) {
            return;
          }

          var activationState = this.activationState_;

          if (activationState.isActivated) {
            return;
          } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


          var previousActivationEvent = this.previousActivationEvent_;
          var isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;

          if (isSameInteraction) {
            return;
          }

          activationState.isActivated = true;
          activationState.isProgrammatic = e === null;
          activationState.activationEvent = e;
          activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';
          var hasActivatedChild = e && activatedTargets$1.length > 0 && activatedTargets$1.some(function (target) {
            return _this9.adapter_.containsEventTarget(target);
          });

          if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
          }

          if (e) {
            activatedTargets$1.push(
            /** @type {!EventTarget} */
            e.target);
            this.registerDeactivationHandlers_(e);
          }

          activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

          if (activationState.wasElementMadeActive) {
            this.animateActivation_();
          }

          requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets$1 = [];

            if (!activationState.wasElementMadeActive && (e.key === ' ' || e.keyCode === 32)) {
              // If space was pressed, try again within an rAF call to detect :active, because different UAs report
              // active states inconsistently when they're called within event handling code:
              // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
              // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
              // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
              // variable is set within a rAF callback for a submit button interaction (#2241).
              activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

              if (activationState.wasElementMadeActive) {
                _this9.animateActivation_();
              }
            }

            if (!activationState.wasElementMadeActive) {
              // Reset activation state immediately if element was not made active.
              _this9.activationState_ = _this9.defaultActivationState_();
            }
          });
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "checkElementMadeActive_",
        value: function checkElementMadeActive_(e) {
          return e && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
        }
        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: "activate",
        value: function activate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          this.activate_(event);
        }
        /** @private */

      }, {
        key: "animateActivation_",
        value: function animateActivation_() {
          var _this10 = this;

          var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
              VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
              VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
          var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
              FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
              FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
          var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
          this.layoutInternal_();
          var translateStart = '';
          var translateEnd = '';

          if (!this.adapter_.isUnbounded()) {
            var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
                startPoint = _this$getFgTranslatio.startPoint,
                endPoint = _this$getFgTranslatio.endPoint;

            translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
            translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
          }

          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

          clearTimeout(this.activationTimer_);
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.rmBoundedActivationClasses_();
          this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

          this.adapter_.computeBoundingRect();
          this.adapter_.addClass(FG_ACTIVATION);
          this.activationTimer_ = setTimeout(function () {
            return _this10.activationTimerCallback_();
          }, DEACTIVATION_TIMEOUT_MS);
        }
        /**
         * @private
         * @return {{startPoint: PointType, endPoint: PointType}}
         */

      }, {
        key: "getFgTranslationCoordinates_",
        value: function getFgTranslationCoordinates_() {
          var _this$activationState = this.activationState_,
              activationEvent = _this$activationState.activationEvent,
              wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
          var startPoint;

          if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords$1(
            /** @type {!Event} */
            activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
          } else {
            startPoint = {
              x: this.frame_.width / 2,
              y: this.frame_.height / 2
            };
          } // Center the element around the start point.


          startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
          };
          var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
          };
          return {
            startPoint: startPoint,
            endPoint: endPoint
          };
        }
        /** @private */

      }, {
        key: "runDeactivationUXLogicIfReady_",
        value: function runDeactivationUXLogicIfReady_() {
          var _this11 = this;

          // This method is called both when a pointing device is released, and when the activation animation ends.
          // The deactivation animation should only run after both of those occur.
          var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
          var _this$activationState2 = this.activationState_,
              hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
              isActivated = _this$activationState2.isActivated;
          var activationHasEnded = hasDeactivationUXRun || !isActivated;

          if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
              _this11.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers$1.FG_DEACTIVATION_MS);
          }
        }
        /** @private */

      }, {
        key: "rmBoundedActivationClasses_",
        value: function rmBoundedActivationClasses_() {
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
          this.adapter_.removeClass(FG_ACTIVATION);
          this.activationAnimationHasEnded_ = false;
          this.adapter_.computeBoundingRect();
        }
      }, {
        key: "resetActivationState_",
        value: function resetActivationState_() {
          var _this12 = this;

          this.previousActivationEvent_ = this.activationState_.activationEvent;
          this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
          // Store the previous event until it's safe to assume that subsequent events are for new interactions.

          setTimeout(function () {
            return _this12.previousActivationEvent_ = null;
          }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "deactivate_",
        value: function deactivate_(e) {
          var _this13 = this;

          var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

          if (!activationState.isActivated) {
            return;
          }

          var state =
          /** @type {!ActivationStateType} */
          Object.assign({}, activationState);

          if (activationState.isProgrammatic) {
            var evtObject = null;
            requestAnimationFrame(function () {
              return _this13.animateDeactivation_(evtObject, state);
            });
            this.resetActivationState_();
          } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
              _this13.activationState_.hasDeactivationUXRun = true;

              _this13.animateDeactivation_(e, state);

              _this13.resetActivationState_();
            });
          }
        }
        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          this.deactivate_(event);
        }
        /**
         * @param {Event} e
         * @param {!ActivationStateType} options
         * @private
         */

      }, {
        key: "animateDeactivation_",
        value: function animateDeactivation_(e, _ref) {
          var wasActivatedByPointer = _ref.wasActivatedByPointer,
              wasElementMadeActive = _ref.wasElementMadeActive;

          if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this14 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }

          this.layoutFrame_ = requestAnimationFrame(function () {
            _this14.layoutInternal_();

            _this14.layoutFrame_ = 0;
          });
        }
        /** @private */

      }, {
        key: "layoutInternal_",
        value: function layoutInternal_() {
          var _this15 = this;

          this.frame_ = this.adapter_.computeBoundingRect();
          var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
          // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
          // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
          // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
          // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
          // `overflow: hidden`.

          var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
          };

          this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

          this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;
          this.fgScale_ = this.maxRadius_ / this.initialSize_;
          this.updateLayoutCssVars_();
        }
        /** @private */

      }, {
        key: "updateLayoutCssVars_",
        value: function updateLayoutCssVars_() {
          var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
              VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
              VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
              VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
              VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
          this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
          this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

          if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
              left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
              top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };
            this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
            this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
          }
        }
        /** @param {boolean} unbounded */

      }, {
        key: "setUnbounded",
        value: function setUnbounded(unbounded) {
          var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

          if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
          } else {
            this.adapter_.removeClass(UNBOUNDED);
          }
        }
      }, {
        key: "handleFocus",
        value: function handleFocus() {
          var _this16 = this;

          requestAnimationFrame(function () {
            return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }, {
        key: "handleBlur",
        value: function handleBlur() {
          var _this17 = this;

          requestAnimationFrame(function () {
            return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }]);

      return MDCRippleFoundation;
    }(MDCFoundation$1);

    /**
     * @extends MDCComponent<!MDCRippleFoundation>
     */

    var MDCRipple$1 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$2(MDCRipple, _MDCComponent);

      /** @param {...?} args */
      function MDCRipple() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$2(this, MDCRipple);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$2(this, (_getPrototypeOf2 = _getPrototypeOf$2(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {boolean} */

        _this.disabled = false;
        /** @private {boolean} */

        _this.unbounded_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @param {{isUnbounded: (boolean|undefined)}=} options
       * @return {!MDCRipple}
       */


      _createClass$2(MDCRipple, [{
        key: "setUnbounded_",

        /**
         * Closure Compiler throws an access control error when directly accessing a
         * protected or private property inside a getter/setter, like unbounded above.
         * By accessing the protected property inside a method, we solve that problem.
         * That's why this function exists.
         * @private
         */
        value: function setUnbounded_() {
          this.foundation_.setUnbounded(this.unbounded_);
        }
      }, {
        key: "activate",
        value: function activate() {
          this.foundation_.activate();
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
        /**
         * @return {!MDCRippleFoundation}
         * @override
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          return new MDCRippleFoundation$1(MDCRipple.createAdapter(this));
        }
        /** @override */

      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
        }
      }, {
        key: "unbounded",

        /** @return {boolean} */
        get: function get() {
          return this.unbounded_;
        }
        /** @param {boolean} unbounded */
        ,
        set: function set(unbounded) {
          this.unbounded_ = Boolean(unbounded);
          this.setUnbounded_();
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref$isUnbounded = _ref.isUnbounded,
              isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

          var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

          if (isUnbounded !== undefined) {
            ripple.unbounded =
            /** @type {boolean} */
            isUnbounded;
          }

          return ripple;
        }
        /**
         * @param {!RippleCapableSurface} instance
         * @return {!MDCRippleAdapter}
         */

      }, {
        key: "createAdapter",
        value: function createAdapter(instance) {
          var MATCHES = getMatchesProperty$1(HTMLElement.prototype);
          return {
            browserSupportsCssVars: function browserSupportsCssVars() {
              return supportsCssVariables$1(window);
            },
            isUnbounded: function isUnbounded() {
              return instance.unbounded;
            },
            isSurfaceActive: function isSurfaceActive() {
              return instance.root_[MATCHES](':active');
            },
            isSurfaceDisabled: function isSurfaceDisabled() {
              return instance.disabled;
            },
            addClass: function addClass(className) {
              return instance.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return instance.root_.classList.remove(className);
            },
            containsEventTarget: function containsEventTarget(target) {
              return instance.root_.contains(target);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return instance.root_.addEventListener(evtType, handler, applyPassive$1());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return instance.root_.removeEventListener(evtType, handler, applyPassive$1());
            },
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.addEventListener(evtType, handler, applyPassive$1());
            },
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.removeEventListener(evtType, handler, applyPassive$1());
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return instance.root_.style.setProperty(varName, value);
            },
            computeBoundingRect: function computeBoundingRect() {
              return instance.root_.getBoundingClientRect();
            },
            getWindowPageOffset: function getWindowPageOffset() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            }
          };
        }
      }]);

      return MDCRipple;
    }(MDCComponent$1);

    /**
     * @license
     * Copyright 2018 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var cssClasses$1$1 = {
      FIXED_CLASS: 'mdc-top-app-bar--fixed',
      FIXED_SCROLLED_CLASS: 'mdc-top-app-bar--fixed-scrolled',
      SHORT_CLASS: 'mdc-top-app-bar--short',
      SHORT_HAS_ACTION_ITEM_CLASS: 'mdc-top-app-bar--short-has-action-item',
      SHORT_COLLAPSED_CLASS: 'mdc-top-app-bar--short-collapsed'
    };
    /** @enum {number} */

    var numbers$1$1 = {
      DEBOUNCE_THROTTLE_RESIZE_TIME_MS: 100,
      MAX_TOP_APP_BAR_HEIGHT: 128
    };
    /** @enum {string} */

    var strings$1$1 = {
      ACTION_ITEM_SELECTOR: '.mdc-top-app-bar__action-item',
      NAVIGATION_EVENT: 'MDCTopAppBar:nav',
      NAVIGATION_ICON_SELECTOR: '.mdc-top-app-bar__navigation-icon',
      ROOT_SELECTOR: '.mdc-top-app-bar',
      TITLE_SELECTOR: '.mdc-top-app-bar__title'
    };

    /**
     * @extends {MDCFoundation<!MDCTopAppBarAdapter>}
     */

    var MDCTopAppBarBaseFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$2(MDCTopAppBarBaseFoundation, _MDCFoundation);

      _createClass$2(MDCTopAppBarBaseFoundation, null, [{
        key: "strings",

        /** @return enum {string} */
        get: function get() {
          return strings$1$1;
        }
        /** @return enum {string} */

      }, {
        key: "cssClasses",
        get: function get() {
          return cssClasses$1$1;
        }
        /** @return enum {number} */

      }, {
        key: "numbers",
        get: function get() {
          return numbers$1$1;
        }
        /**
         * {@see MDCTopAppBarAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCTopAppBarAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCTopAppBarAdapter} */
            {
              hasClass: function hasClass()
              /* className: string */
              {},
              addClass: function addClass()
              /* className: string */
              {},
              removeClass: function removeClass()
              /* className: string */
              {},
              setStyle: function setStyle()
              /* property: string, value: string */
              {},
              getTopAppBarHeight: function getTopAppBarHeight() {},
              registerNavigationIconInteractionHandler: function registerNavigationIconInteractionHandler()
              /* type: string, handler: EventListener */
              {},
              deregisterNavigationIconInteractionHandler: function deregisterNavigationIconInteractionHandler()
              /* type: string, handler: EventListener */
              {},
              notifyNavigationIconClicked: function notifyNavigationIconClicked() {},
              registerScrollHandler: function registerScrollHandler()
              /* handler: EventListener */
              {},
              deregisterScrollHandler: function deregisterScrollHandler()
              /* handler: EventListener */
              {},
              registerResizeHandler: function registerResizeHandler()
              /* handler: EventListener */
              {},
              deregisterResizeHandler: function deregisterResizeHandler()
              /* handler: EventListener */
              {},
              getViewportScrollY: function getViewportScrollY() {
                return (
                  /* number */
                  0
                );
              },
              getTotalActionItems: function getTotalActionItems() {
                return (
                  /* number */
                  0
                );
              }
            }
          );
        }
        /**
         * @param {!MDCTopAppBarAdapter} adapter
         */

      }]);

      function MDCTopAppBarBaseFoundation(
      /** @type {!MDCTopAppBarAdapter} */
      adapter) {
        var _this;

        _classCallCheck$2(this, MDCTopAppBarBaseFoundation);

        _this = _possibleConstructorReturn$2(this, _getPrototypeOf$2(MDCTopAppBarBaseFoundation).call(this, Object.assign(MDCTopAppBarBaseFoundation.defaultAdapter, adapter)));

        _this.navClickHandler_ = function () {
          return _this.adapter_.notifyNavigationIconClicked();
        };

        return _this;
      }

      _createClass$2(MDCTopAppBarBaseFoundation, [{
        key: "init",
        value: function init() {
          this.adapter_.registerNavigationIconInteractionHandler('click', this.navClickHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.adapter_.deregisterNavigationIconInteractionHandler('click', this.navClickHandler_);
        }
      }]);

      return MDCTopAppBarBaseFoundation;
    }(MDCFoundation$1);

    /**
     * @extends {MDCTopAppBarFoundation<!MDCFixedTopAppBarFoundation>}
     * @final
     */

    var MDCFixedTopAppBarFoundation =
    /*#__PURE__*/
    function (_MDCTopAppBarFoundati) {
      _inherits$2(MDCFixedTopAppBarFoundation, _MDCTopAppBarFoundati);

      /**
       * @param {!MDCTopAppBarAdapter} adapter
       */
      function MDCFixedTopAppBarFoundation(adapter) {
        var _this;

        _classCallCheck$2(this, MDCFixedTopAppBarFoundation);

        _this = _possibleConstructorReturn$2(this, _getPrototypeOf$2(MDCFixedTopAppBarFoundation).call(this, adapter));
        /** State variable for the previous scroll iteration top app bar state */

        _this.wasScrolled_ = false;

        _this.scrollHandler_ = function () {
          return _this.fixedScrollHandler_();
        };

        return _this;
      }

      _createClass$2(MDCFixedTopAppBarFoundation, [{
        key: "init",
        value: function init() {
          _get$1(_getPrototypeOf$2(MDCFixedTopAppBarFoundation.prototype), "init", this).call(this);

          this.adapter_.registerScrollHandler(this.scrollHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          _get$1(_getPrototypeOf$2(MDCFixedTopAppBarFoundation.prototype), "destroy", this).call(this);

          this.adapter_.deregisterScrollHandler(this.scrollHandler_);
        }
        /**
         * Scroll handler for applying/removing the modifier class
         * on the fixed top app bar.
         */

      }, {
        key: "fixedScrollHandler_",
        value: function fixedScrollHandler_() {
          var currentScroll = this.adapter_.getViewportScrollY();

          if (currentScroll <= 0) {
            if (this.wasScrolled_) {
              this.adapter_.removeClass(cssClasses$1$1.FIXED_SCROLLED_CLASS);
              this.wasScrolled_ = false;
            }
          } else {
            if (!this.wasScrolled_) {
              this.adapter_.addClass(cssClasses$1$1.FIXED_SCROLLED_CLASS);
              this.wasScrolled_ = true;
            }
          }
        }
      }]);

      return MDCFixedTopAppBarFoundation;
    }(MDCTopAppBarBaseFoundation);

    /**
     * @extends {MDCTopAppBarBaseFoundation<!MDCShortTopAppBarFoundation>}
     * @final
     */

    var MDCShortTopAppBarFoundation =
    /*#__PURE__*/
    function (_MDCTopAppBarBaseFoun) {
      _inherits$2(MDCShortTopAppBarFoundation, _MDCTopAppBarBaseFoun);

      /**
       * @param {!MDCTopAppBarAdapter} adapter
       */
      function MDCShortTopAppBarFoundation(adapter) {
        var _this;

        _classCallCheck$2(this, MDCShortTopAppBarFoundation);

        _this = _possibleConstructorReturn$2(this, _getPrototypeOf$2(MDCShortTopAppBarFoundation).call(this, adapter)); // State variable for the current top app bar state

        _this.isCollapsed = false;

        _this.scrollHandler_ = function () {
          return _this.shortAppBarScrollHandler_();
        };

        return _this;
      }

      _createClass$2(MDCShortTopAppBarFoundation, [{
        key: "init",
        value: function init() {
          _get$1(_getPrototypeOf$2(MDCShortTopAppBarFoundation.prototype), "init", this).call(this);

          var isAlwaysCollapsed = this.adapter_.hasClass(cssClasses$1$1.SHORT_COLLAPSED_CLASS);

          if (this.adapter_.getTotalActionItems() > 0) {
            this.adapter_.addClass(cssClasses$1$1.SHORT_HAS_ACTION_ITEM_CLASS);
          }

          if (!isAlwaysCollapsed) {
            this.adapter_.registerScrollHandler(this.scrollHandler_);
            this.shortAppBarScrollHandler_();
          }
        }
      }, {
        key: "destroy",
        value: function destroy() {
          _get$1(_getPrototypeOf$2(MDCShortTopAppBarFoundation.prototype), "destroy", this).call(this);

          this.adapter_.deregisterScrollHandler(this.scrollHandler_);
        }
        /**
         * Scroll handler for applying/removing the collapsed modifier class
         * on the short top app bar.
         * @private
         */

      }, {
        key: "shortAppBarScrollHandler_",
        value: function shortAppBarScrollHandler_() {
          var currentScroll = this.adapter_.getViewportScrollY();

          if (currentScroll <= 0) {
            if (this.isCollapsed) {
              this.adapter_.removeClass(cssClasses$1$1.SHORT_COLLAPSED_CLASS);
              this.isCollapsed = false;
            }
          } else {
            if (!this.isCollapsed) {
              this.adapter_.addClass(cssClasses$1$1.SHORT_COLLAPSED_CLASS);
              this.isCollapsed = true;
            }
          }
        }
      }]);

      return MDCShortTopAppBarFoundation;
    }(MDCTopAppBarBaseFoundation);

    var INITIAL_VALUE = 0;
    /**
     * @extends {MDCTopAppBarBaseFoundation<!MDCTopAppBarFoundation>}
     * @final
     */

    var MDCTopAppBarFoundation =
    /*#__PURE__*/
    function (_MDCTopAppBarBaseFoun) {
      _inherits$2(MDCTopAppBarFoundation, _MDCTopAppBarBaseFoun);

      /**
       * @param {!MDCTopAppBarAdapter} adapter
       */
      function MDCTopAppBarFoundation(adapter) {
        var _this;

        _classCallCheck$2(this, MDCTopAppBarFoundation);

        _this = _possibleConstructorReturn$2(this, _getPrototypeOf$2(MDCTopAppBarFoundation).call(this, adapter));
        /**
         * Used for diffs of current scroll position vs previous scroll position
         * @private {number}
         */

        _this.lastScrollPosition_ = _this.adapter_.getViewportScrollY();
        /**
         * Used to verify when the top app bar is completely showing or completely hidden
         * @private {number}
         */

        _this.topAppBarHeight_ = _this.adapter_.getTopAppBarHeight();
        /**
         * wasDocked_ is used to indicate if the top app bar was docked in the previous
         * scroll handler iteration.
         * @private {boolean}
         */

        _this.wasDocked_ = true;
        /**
         * isDockedShowing_ is used to indicate if the top app bar is docked in the fully
         * shown position.
         * @private {boolean}
         */

        _this.isDockedShowing_ = true;
        /**
         * Variable for current scroll position of the top app bar
         * @private {number}
         */

        _this.currentAppBarOffsetTop_ = 0;
        /**
         * Used to prevent the top app bar from being scrolled out of view during resize events
         * @private {boolean} */

        _this.isCurrentlyBeingResized_ = false;
        /**
         * The timeout that's used to throttle the resize events
         * @private {number}
         */

        _this.resizeThrottleId_ = INITIAL_VALUE;
        /**
         * The timeout that's used to debounce toggling the isCurrentlyBeingResized_ variable after a resize
         * @private {number}
         */

        _this.resizeDebounceId_ = INITIAL_VALUE;

        _this.scrollHandler_ = function () {
          return _this.topAppBarScrollHandler_();
        };

        _this.resizeHandler_ = function () {
          return _this.topAppBarResizeHandler_();
        };

        return _this;
      }

      _createClass$2(MDCTopAppBarFoundation, [{
        key: "init",
        value: function init() {
          _get$1(_getPrototypeOf$2(MDCTopAppBarFoundation.prototype), "init", this).call(this);

          this.adapter_.registerScrollHandler(this.scrollHandler_);
          this.adapter_.registerResizeHandler(this.resizeHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          _get$1(_getPrototypeOf$2(MDCTopAppBarFoundation.prototype), "destroy", this).call(this);

          this.adapter_.deregisterScrollHandler(this.scrollHandler_);
          this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          this.adapter_.setStyle('top', '');
        }
        /**
         * Function to determine if the DOM needs to update.
         * @return {boolean}
         * @private
         */

      }, {
        key: "checkForUpdate_",
        value: function checkForUpdate_() {
          var offscreenBoundaryTop = -this.topAppBarHeight_;
          var hasAnyPixelsOffscreen = this.currentAppBarOffsetTop_ < 0;
          var hasAnyPixelsOnscreen = this.currentAppBarOffsetTop_ > offscreenBoundaryTop;
          var partiallyShowing = hasAnyPixelsOffscreen && hasAnyPixelsOnscreen; // If it's partially showing, it can't be docked.

          if (partiallyShowing) {
            this.wasDocked_ = false;
          } else {
            // Not previously docked and not partially showing, it's now docked.
            if (!this.wasDocked_) {
              this.wasDocked_ = true;
              return true;
            } else if (this.isDockedShowing_ !== hasAnyPixelsOnscreen) {
              this.isDockedShowing_ = hasAnyPixelsOnscreen;
              return true;
            }
          }

          return partiallyShowing;
        }
        /**
         * Function to move the top app bar if needed.
         * @private
         */

      }, {
        key: "moveTopAppBar_",
        value: function moveTopAppBar_() {
          if (this.checkForUpdate_()) {
            // Once the top app bar is fully hidden we use the max potential top app bar height as our offset
            // so the top app bar doesn't show if the window resizes and the new height > the old height.
            var offset = this.currentAppBarOffsetTop_;

            if (Math.abs(offset) >= this.topAppBarHeight_) {
              offset = -numbers$1$1.MAX_TOP_APP_BAR_HEIGHT;
            }

            this.adapter_.setStyle('top', offset + 'px');
          }
        }
        /**
         * Scroll handler for the default scroll behavior of the top app bar.
         * @private
         */

      }, {
        key: "topAppBarScrollHandler_",
        value: function topAppBarScrollHandler_() {
          var currentScrollPosition = Math.max(this.adapter_.getViewportScrollY(), 0);
          var diff = currentScrollPosition - this.lastScrollPosition_;
          this.lastScrollPosition_ = currentScrollPosition; // If the window is being resized the lastScrollPosition_ needs to be updated but the
          // current scroll of the top app bar should stay in the same position.

          if (!this.isCurrentlyBeingResized_) {
            this.currentAppBarOffsetTop_ -= diff;

            if (this.currentAppBarOffsetTop_ > 0) {
              this.currentAppBarOffsetTop_ = 0;
            } else if (Math.abs(this.currentAppBarOffsetTop_) > this.topAppBarHeight_) {
              this.currentAppBarOffsetTop_ = -this.topAppBarHeight_;
            }

            this.moveTopAppBar_();
          }
        }
        /**
         * Top app bar resize handler that throttle/debounce functions that execute updates.
         * @private
         */

      }, {
        key: "topAppBarResizeHandler_",
        value: function topAppBarResizeHandler_() {
          var _this2 = this;

          // Throttle resize events 10 p/s
          if (!this.resizeThrottleId_) {
            this.resizeThrottleId_ = setTimeout(function () {
              _this2.resizeThrottleId_ = INITIAL_VALUE;

              _this2.throttledResizeHandler_();
            }, numbers$1$1.DEBOUNCE_THROTTLE_RESIZE_TIME_MS);
          }

          this.isCurrentlyBeingResized_ = true;

          if (this.resizeDebounceId_) {
            clearTimeout(this.resizeDebounceId_);
          }

          this.resizeDebounceId_ = setTimeout(function () {
            _this2.topAppBarScrollHandler_();

            _this2.isCurrentlyBeingResized_ = false;
            _this2.resizeDebounceId_ = INITIAL_VALUE;
          }, numbers$1$1.DEBOUNCE_THROTTLE_RESIZE_TIME_MS);
        }
        /**
         * Throttled function that updates the top app bar scrolled values if the
         * top app bar height changes.
         * @private
         */

      }, {
        key: "throttledResizeHandler_",
        value: function throttledResizeHandler_() {
          var currentHeight = this.adapter_.getTopAppBarHeight();

          if (this.topAppBarHeight_ !== currentHeight) {
            this.wasDocked_ = false; // Since the top app bar has a different height depending on the screen width, this
            // will ensure that the top app bar remains in the correct location if
            // completely hidden and a resize makes the top app bar a different height.

            this.currentAppBarOffsetTop_ -= this.topAppBarHeight_ - currentHeight;
            this.topAppBarHeight_ = currentHeight;
          }

          this.topAppBarScrollHandler_();
        }
      }]);

      return MDCTopAppBarFoundation;
    }(MDCTopAppBarBaseFoundation);

    /**
     * @extends {MDCComponent<!MDCTopAppBarBaseFoundation>}
     * @final
     */

    var MDCTopAppBar =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$2(MDCTopAppBar, _MDCComponent);

      /**
       * @param {...?} args
       */
      function MDCTopAppBar() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$2(this, MDCTopAppBar);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$2(this, (_getPrototypeOf2 = _getPrototypeOf$2(MDCTopAppBar)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {?Element} */

        _this.navIcon_;
        /** @type {?Array<MDCRipple>} */

        _this.iconRipples_;
        return _this;
      }

      _createClass$2(MDCTopAppBar, [{
        key: "initialize",
        value: function initialize() {
          var rippleFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (el) {
            return MDCRipple$1.attachTo(el);
          };
          this.navIcon_ = this.root_.querySelector(strings$1$1.NAVIGATION_ICON_SELECTOR); // Get all icons in the toolbar and instantiate the ripples

          var icons = [].slice.call(this.root_.querySelectorAll(strings$1$1.ACTION_ITEM_SELECTOR));

          if (this.navIcon_) {
            icons.push(this.navIcon_);
          }

          this.iconRipples_ = icons.map(function (icon) {
            var ripple = rippleFactory(icon);
            ripple.unbounded = true;
            return ripple;
          });
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.iconRipples_.forEach(function (iconRipple) {
            return iconRipple.destroy();
          });

          _get$1(_getPrototypeOf$2(MDCTopAppBar.prototype), "destroy", this).call(this);
        }
        /**
         * @param {!Element} root
         * @return {!MDCTopAppBar}
         */

      }, {
        key: "getDefaultFoundation",

        /**
         * @return {!MDCTopAppBarBaseFoundation}
         */
        value: function getDefaultFoundation() {
          var _this2 = this;

          /** @type {!MDCTopAppBarAdapter} */
          var adapter =
          /** @type {!MDCTopAppBarAdapter} */
          Object.assign({
            hasClass: function hasClass(className) {
              return _this2.root_.classList.contains(className);
            },
            addClass: function addClass(className) {
              return _this2.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this2.root_.classList.remove(className);
            },
            setStyle: function setStyle(property, value) {
              return _this2.root_.style.setProperty(property, value);
            },
            getTopAppBarHeight: function getTopAppBarHeight() {
              return _this2.root_.clientHeight;
            },
            registerNavigationIconInteractionHandler: function registerNavigationIconInteractionHandler(evtType, handler) {
              if (_this2.navIcon_) {
                _this2.navIcon_.addEventListener(evtType, handler);
              }
            },
            deregisterNavigationIconInteractionHandler: function deregisterNavigationIconInteractionHandler(evtType, handler) {
              if (_this2.navIcon_) {
                _this2.navIcon_.removeEventListener(evtType, handler);
              }
            },
            notifyNavigationIconClicked: function notifyNavigationIconClicked() {
              _this2.emit(strings$1$1.NAVIGATION_EVENT, {});
            },
            registerScrollHandler: function registerScrollHandler(handler) {
              return window.addEventListener('scroll', handler);
            },
            deregisterScrollHandler: function deregisterScrollHandler(handler) {
              return window.removeEventListener('scroll', handler);
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            getViewportScrollY: function getViewportScrollY() {
              return window.pageYOffset;
            },
            getTotalActionItems: function getTotalActionItems() {
              return _this2.root_.querySelectorAll(strings$1$1.ACTION_ITEM_SELECTOR).length;
            }
          });
          /** @type {!MDCTopAppBarBaseFoundation} */

          var foundation;

          if (this.root_.classList.contains(cssClasses$1$1.SHORT_CLASS)) {
            foundation = new MDCShortTopAppBarFoundation(adapter);
          } else if (this.root_.classList.contains(cssClasses$1$1.FIXED_CLASS)) {
            foundation = new MDCFixedTopAppBarFoundation(adapter);
          } else {
            foundation = new MDCTopAppBarFoundation(adapter);
          }

          return foundation;
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCTopAppBar(root);
        }
      }]);

      return MDCTopAppBar;
    }(MDCComponent$1);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Event object emitted by MdcAppBar navigation icon selected.
     */
    var   /**
     * Event object emitted by MdcAppBar navigation icon selected.
     */
    MdcAppBarNavSelected = /** @class */ (function () {
        function MdcAppBarNavSelected(source) {
            this.source = source;
        }
        return MdcAppBarNavSelected;
    }());
    var MdcAppBar = /** @class */ (function () {
        function MdcAppBar(_changeDetectorRef, elementRef, _registry) {
            var _this = this;
            this._changeDetectorRef = _changeDetectorRef;
            this.elementRef = elementRef;
            this._registry = _registry;
            /**
             * Emits whenever the component is destroyed.
             */
            this._destroy = new rxjs.Subject();
            /**
             * Event emitted when the navigation icon is selected.
             */
            this.navigationSelected = new core.EventEmitter();
            this.isHostClass = true;
            this._mdcAdapter = {
                hasClass: function (className) { return _this._getHostElement().classList.contains(className); },
                addClass: function (className) { return _this._getHostElement().classList.add(className); },
                removeClass: function (className) {
                    if (className === 'mdc-top-app-bar--short-collapsed' && _this.shortCollapsed) {
                        return;
                    }
                    _this._getHostElement().classList.remove(className);
                },
                setStyle: function (property, value) { return _this._getHostElement().style.setProperty(property, value); },
                getTopAppBarHeight: function () { return _this._getHostElement().clientHeight; },
                notifyNavigationIconClicked: function () { return _this.navigationSelected.emit({ source: _this }); },
                registerScrollHandler: function (handler) {
                    if (!isBrowser()) {
                        return;
                    }
                    _this._registry.listen('scroll', handler, window);
                },
                deregisterScrollHandler: function (handler) {
                    if (!isBrowser()) {
                        return;
                    }
                    _this._registry.unlisten('scroll', handler);
                },
                registerResizeHandler: function (handler) {
                    if (!isBrowser()) {
                        return;
                    }
                    _this._registry.listen('resize', handler, window);
                },
                deregisterResizeHandler: function (handler) {
                    if (!isBrowser()) {
                        return;
                    }
                    _this._registry.unlisten('resize', handler);
                },
                getViewportScrollY: function () {
                    if (!isBrowser()) {
                        return 0;
                    }
                    return window.pageYOffset;
                },
                getTotalActionItems: function () { return _this.actions ? _this.actions.length : 0; }
            };
            this._foundation = new MDCTopAppBarFoundation(this._mdcAdapter);
        }
        Object.defineProperty(MdcAppBar.prototype, "fixed", {
            get: /**
             * @return {?}
             */
            function () { return this._fixed; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._fixed) {
                    this.setFixed(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcAppBar.prototype, "prominent", {
            get: /**
             * @return {?}
             */
            function () { return this._prominent; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._prominent) {
                    this.setProminent(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcAppBar.prototype, "short", {
            get: /**
             * @return {?}
             */
            function () { return this._short; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._short) {
                    this.setShort(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcAppBar.prototype, "shortCollapsed", {
            get: /**
             * @return {?}
             */
            function () { return this._shortCollapsed; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._shortCollapsed) {
                    this.setShortCollapsed(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcAppBar.prototype, "dense", {
            get: /**
             * @return {?}
             */
            function () { return this._dense; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._dense) {
                    this.setDense(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcAppBar.prototype, "fixedAdjustElement", {
            get: /**
             * @return {?}
             */
            function () { return this._fixedAdjustElement; },
            set: /**
             * @param {?} element
             * @return {?}
             */
            function (element) {
                if (this._fixedAdjustElement !== element) {
                    this.setFixedAdjustElement(element);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcAppBar.prototype, "classProminent", {
            get: /**
             * @return {?}
             */
            function () {
                return this.prominent ? 'mdc-top-app-bar--prominent' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcAppBar.prototype, "classDense", {
            get: /**
             * @return {?}
             */
            function () {
                return this.dense ? 'mdc-top-app-bar--dense' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcAppBar.prototype, "classShort", {
            get: /**
             * @return {?}
             */
            function () {
                return this.short ? 'mdc-top-app-bar--short' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcAppBar.prototype, "classFixed", {
            get: /**
             * @return {?}
             */
            function () {
                return this.fixed ? 'mdc-top-app-bar--fixed' : '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcAppBar.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.actions.changes.pipe(operators.startWith(null), operators.takeUntil(this._destroy)).subscribe(function () {
                if (_this.short) {
                    _this.actions.length > 0 && _this.short ? _this._mdcAdapter.addClass('mdc-top-app-bar--short-has-action-item')
                        : _this._mdcAdapter.removeClass('mdc-top-app-bar--short-has-action-item');
                }
            });
        };
        /**
         * @return {?}
         */
        MdcAppBar.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            if (!this._isFoundationInit) {
                this.initializeFoundation();
            }
        };
        /**
         * @return {?}
         */
        MdcAppBar.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroy.next();
            this._destroy.complete();
            this._foundation.destroy();
        };
        /**
         * @param {?} element
         * @return {?}
         */
        MdcAppBar.prototype.setFixedAdjustElement = /**
         * @param {?} element
         * @return {?}
         */
        function (element) {
            this._fixedAdjustElement = element;
            this._initAppBar();
        };
        /** Sets the top app bar to fixed or not. */
        /**
         * Sets the top app bar to fixed or not.
         * @param {?} fixed
         * @param {?=} isUserInput
         * @return {?}
         */
        MdcAppBar.prototype.setFixed = /**
         * Sets the top app bar to fixed or not.
         * @param {?} fixed
         * @param {?=} isUserInput
         * @return {?}
         */
        function (fixed, isUserInput) {
            if (isUserInput === void 0) { isUserInput = true; }
            this._fixed = toBoolean(fixed);
            if (this.fixed && this.short) {
                this.setShort(false, false);
            }
            if (isUserInput) {
                this.initializeFoundation();
            }
        };
        /** Sets the top app bar to prominent or not. */
        /**
         * Sets the top app bar to prominent or not.
         * @param {?} prominent
         * @param {?=} isUserInput
         * @return {?}
         */
        MdcAppBar.prototype.setProminent = /**
         * Sets the top app bar to prominent or not.
         * @param {?} prominent
         * @param {?=} isUserInput
         * @return {?}
         */
        function (prominent, isUserInput) {
            if (isUserInput === void 0) { isUserInput = true; }
            this._prominent = toBoolean(prominent);
            if (this.prominent && this.short) {
                this.setShort(false, false);
            }
            if (isUserInput) {
                this.initializeFoundation();
            }
        };
        /** Sets the top app bar to dense variant. */
        /**
         * Sets the top app bar to dense variant.
         * @param {?} dense
         * @param {?=} isUserInput
         * @return {?}
         */
        MdcAppBar.prototype.setDense = /**
         * Sets the top app bar to dense variant.
         * @param {?} dense
         * @param {?=} isUserInput
         * @return {?}
         */
        function (dense, isUserInput) {
            if (isUserInput === void 0) { isUserInput = true; }
            this._dense = toBoolean(dense);
            if (this.dense && this.short) {
                this.setShort(false, false);
            }
            if (isUserInput) {
                this.initializeFoundation();
            }
        };
        /** Sets the top app bar to short or not. */
        /**
         * Sets the top app bar to short or not.
         * @param {?} short
         * @param {?=} isUserInput
         * @return {?}
         */
        MdcAppBar.prototype.setShort = /**
         * Sets the top app bar to short or not.
         * @param {?} short
         * @param {?=} isUserInput
         * @return {?}
         */
        function (short, isUserInput) {
            if (isUserInput === void 0) { isUserInput = true; }
            this._short = toBoolean(short);
            if (this.short) {
                this.setProminent(false, false);
                this.setDense(false, false);
                this.setFixed(false, false);
            }
            else {
                this.setShortCollapsed(false, false);
            }
            if (isUserInput) {
                this.initializeFoundation();
            }
        };
        /** Sets the top app bar to short-collapsed or not. */
        /**
         * Sets the top app bar to short-collapsed or not.
         * @param {?} shortCollapsed
         * @param {?=} isUserInput
         * @return {?}
         */
        MdcAppBar.prototype.setShortCollapsed = /**
         * Sets the top app bar to short-collapsed or not.
         * @param {?} shortCollapsed
         * @param {?=} isUserInput
         * @return {?}
         */
        function (shortCollapsed, isUserInput) {
            if (isUserInput === void 0) { isUserInput = true; }
            this._shortCollapsed = toBoolean(shortCollapsed);
            if (this.shortCollapsed && !this.short) {
                this.setShort(true, false);
            }
            if (isUserInput) {
                this.initializeFoundation();
            }
        };
        /**
         * @return {?}
         */
        MdcAppBar.prototype.initializeFoundation = /**
         * @return {?}
         */
        function () {
            this._foundation.destroy();
            this._getHostElement().style.top = '0px';
            this._resetFixedShort();
            if (this.short) {
                this._foundation = new MDCShortTopAppBarFoundation(this._mdcAdapter);
            }
            else if (this.fixed) {
                this._foundation = new MDCFixedTopAppBarFoundation(this._mdcAdapter);
            }
            else {
                this._foundation = new MDCTopAppBarFoundation(this._mdcAdapter);
            }
            this._foundation.init();
            this._isFoundationInit = true;
            this._initAppBar();
        };
        /**
         * @return {?}
         */
        MdcAppBar.prototype._resetFixedShort = /**
         * @return {?}
         */
        function () {
            this._getHostElement().classList.remove('mdc-top-app-bar--short-has-action-item');
            this._getHostElement().classList.remove('mdc-top-app-bar--short-collapsed');
            this._getHostElement().classList.remove('mdc-top-app-bar--fixed-scrolled');
        };
        /**
         * @return {?}
         */
        MdcAppBar.prototype._initAppBar = /**
         * @return {?}
         */
        function () {
            if (!this.fixed) {
                this._getHostElement().classList.remove('mdc-top-app-bar--fixed-scrolled');
            }
            if (this.fixed && this._getScrollOffset() > 0) {
                this._getHostElement().classList.add('mdc-top-app-bar--fixed-scrolled');
            }
            if (!this.short) {
                this._getHostElement().classList.remove('mdc-top-app-bar--short-has-action-item');
                this._getHostElement().classList.remove('mdc-top-app-bar--short-collapsed');
            }
            if (this.short && this._getScrollOffset() > 0) {
                this._getHostElement().classList.add('mdc-top-app-bar--short-collapsed');
            }
            if (this.shortCollapsed) {
                this._getHostElement().classList.add('mdc-top-app-bar--short-collapsed');
            }
            if (this.fixedAdjustElement) {
                this.fixedAdjustElement.classList.remove('mdc-top-app-bar--short-fixed-adjust');
                this.fixedAdjustElement.classList.remove('mdc-top-app-bar--fixed-adjust');
                this.fixedAdjustElement.classList.remove('mdc-top-app-bar--dense-fixed-adjust');
                this.fixedAdjustElement.classList.remove('mdc-top-app-bar--prominent-fixed-adjust');
                this.fixedAdjustElement.classList.remove('mdc-top-app-bar--dense-prominent-fixed-adjust');
                if (this._short) {
                    this.fixedAdjustElement.classList.add('mdc-top-app-bar--short-fixed-adjust');
                }
                else if (this._dense && this._prominent) {
                    this.fixedAdjustElement.classList.add('mdc-top-app-bar--dense-prominent-fixed-adjust');
                }
                else if (this._dense) {
                    this.fixedAdjustElement.classList.add('mdc-top-app-bar--dense-fixed-adjust');
                }
                else if (this._prominent) {
                    this.fixedAdjustElement.classList.add('mdc-top-app-bar--prominent-fixed-adjust');
                }
                else {
                    this.fixedAdjustElement.classList.add('mdc-top-app-bar--fixed-adjust');
                }
            }
        };
        /**
         * @return {?}
         */
        MdcAppBar.prototype._getScrollOffset = /**
         * @return {?}
         */
        function () {
            return window.pageYOffset;
        };
        /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        MdcAppBar.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcAppBar.decorators = [
            { type: core.Component, args: [{
                        selector: '[mdc-app-bar], mdc-app-bar',
                        template: '<ng-content></ng-content>',
                        exportAs: 'mdcAppBar',
                        providers: [EventRegistry],
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcAppBar.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: EventRegistry }
        ]; };
        MdcAppBar.propDecorators = {
            fixed: [{ type: core.Input }],
            prominent: [{ type: core.Input }],
            short: [{ type: core.Input }],
            shortCollapsed: [{ type: core.Input }],
            dense: [{ type: core.Input }],
            fixedAdjustElement: [{ type: core.Input }],
            navigationSelected: [{ type: core.Output }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-top-app-bar',] }],
            classProminent: [{ type: core.HostBinding, args: ['class.mdc-top-app-bar--prominent',] }],
            classDense: [{ type: core.HostBinding, args: ['class.mdc-top-app-bar--dense',] }],
            classShort: [{ type: core.HostBinding, args: ['class.mdc-top-app-bar--short',] }],
            classFixed: [{ type: core.HostBinding, args: ['class.mdc-top-app-bar--fixed',] }],
            navigationIcon: [{ type: core.ContentChild, args: [MdcAppBarNavigationIcon,] }],
            actions: [{ type: core.ContentChildren, args: [MdcAppBarActionItem, { descendants: true },] }]
        };
        return MdcAppBar;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ APPBAR_DECLARATIONS = [
        MdcAppBar,
        MdcAppBarActionItem,
        MdcAppBarNavigationIcon,
        MdcAppBarRow,
        MdcAppBarSection,
        MdcAppBarTitle
    ];
    var MdcAppBarModule = /** @class */ (function () {
        function MdcAppBarModule() {
        }
        MdcAppBarModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: APPBAR_DECLARATIONS,
                        declarations: APPBAR_DECLARATIONS
                    },] },
        ];
        return MdcAppBarModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcIcon = /** @class */ (function () {
        function MdcIcon(_changeDetectorRef, _renderer, elementRef, ariaHidden) {
            this._changeDetectorRef = _changeDetectorRef;
            this._renderer = _renderer;
            this.elementRef = elementRef;
            this.ariaHidden = ariaHidden;
            this._defaultFontSetClass = 'material-icons';
            this.isHostClass = true;
            if (!ariaHidden) {
                _renderer.setAttribute(elementRef.nativeElement, 'aria-hidden', 'true');
            }
        }
        Object.defineProperty(MdcIcon.prototype, "fontSet", {
            /** Font set that the icon is a part of. */
            get: /**
             * Font set that the icon is a part of.
             * @return {?}
             */
            function () { return this._fontSet; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._fontSet = this._cleanupFontValue(value);
                this._updateFontIconClasses();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIcon.prototype, "fontIcon", {
            /** Name of an icon within a font set. */
            get: /**
             * Name of an icon within a font set.
             * @return {?}
             */
            function () { return this._fontIcon; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._fontIcon = value;
                this._updateFontIconClasses();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIcon.prototype, "fontSize", {
            get: /**
             * @return {?}
             */
            function () { return this._fontSize; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setFontSize(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIcon.prototype, "leading", {
            get: /**
             * @return {?}
             */
            function () { return this._leading; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._leading = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIcon.prototype, "trailing", {
            get: /**
             * @return {?}
             */
            function () { return this._trailing; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._trailing = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIcon.prototype, "clickable", {
            get: /**
             * @return {?}
             */
            function () { return this._clickable; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setClickable(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcIcon.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this._updateFontIconClasses();
        };
        /**
         * @return {?}
         */
        MdcIcon.prototype._updateFontIconClasses = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ el = this._getHostElement();
            var /** @type {?} */ fontSetClass = this.fontSet ? this.fontSet : this._getDefaultFontSetClass();
            if (fontSetClass !== this._previousFontSetClass) {
                if (this._previousFontSetClass) {
                    this._renderer.removeClass(el, this._previousFontSetClass);
                }
                if (fontSetClass) {
                    this._renderer.addClass(el, fontSetClass);
                }
                this._previousFontSetClass = fontSetClass;
            }
            if (this.fontIcon !== this._previousFontIconClass) {
                if (this._previousFontIconClass) {
                    this._renderer.removeClass(el, this._previousFontIconClass);
                }
                if (this.fontIcon) {
                    for (var _i = 0, _a = this.fontIcon.split(' '); _i < _a.length; _i++) {
                        var iconClass = _a[_i];
                        this._renderer.addClass(el, iconClass);
                    }
                }
                this._previousFontIconClass = this.fontIcon;
            }
            if (this.fontSize !== this._previousFontSize) {
                if (this._previousFontSize) {
                    this._renderer.removeStyle(el, "font-size: " + this.fontSize + "px");
                }
                if (this.fontSize) {
                    this._renderer.setStyle(el, 'font-size', this.fontSize + "px");
                }
                this._previousFontSize = this.fontSize;
            }
        };
        /**
         * @return {?}
         */
        MdcIcon.prototype._getDefaultFontSetClass = /**
         * @return {?}
         */
        function () {
            return this._defaultFontSetClass;
        };
        /**
         * Cleans up a value to be used as a fontIcon or fontSet.
         * Since the value ends up being assigned as a CSS class, we
         * have to trim the value and omit space-separated values.
         * @param {?} value
         * @return {?}
         */
        MdcIcon.prototype._cleanupFontValue = /**
         * Cleans up a value to be used as a fontIcon or fontSet.
         * Since the value ends up being assigned as a CSS class, we
         * have to trim the value and omit space-separated values.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            return typeof value === 'string' ? value.trim().split(' ')[0] : value;
        };
        /** Retrieves the DOM element of the component host. */
        /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        MdcIcon.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        /**
         * @return {?}
         */
        MdcIcon.prototype.isLeading = /**
         * @return {?}
         */
        function () {
            return this.leading;
        };
        /**
         * @return {?}
         */
        MdcIcon.prototype.isTrailing = /**
         * @return {?}
         */
        function () {
            return this.trailing;
        };
        /**
         * @param {?} content
         * @return {?}
         */
        MdcIcon.prototype.setIcon = /**
         * @param {?} content
         * @return {?}
         */
        function (content) {
            this.fontIcon ? this.fontIcon = content : this._getHostElement().textContent = content;
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @return {?}
         */
        MdcIcon.prototype.getIcon = /**
         * @return {?}
         */
        function () {
            return this.fontIcon ? this.fontIcon : this._getHostElement().textContent;
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MdcIcon.prototype.setFontSize = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._fontSize = value;
            this._updateFontIconClasses();
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} clickable
         * @return {?}
         */
        MdcIcon.prototype.setClickable = /**
         * @param {?} clickable
         * @return {?}
         */
        function (clickable) {
            this._clickable = toBoolean(clickable);
            if (this.clickable) {
                this._renderer.setAttribute(this._getHostElement(), 'tabindex', '0');
                this._renderer.addClass(this._getHostElement(), 'ng-mdc-icon--clickable');
                this._renderer.setAttribute(this._getHostElement(), 'role', 'button');
            }
            else {
                this._renderer.setAttribute(this._getHostElement(), 'tabindex', '-1');
                this._renderer.removeClass(this._getHostElement(), 'ng-mdc-icon--clickable');
                this._renderer.removeAttribute(this._getHostElement(), 'role');
            }
        };
        MdcIcon.decorators = [
            { type: core.Component, args: [{selector: 'mdc-icon, [mdcIcon]',
                        template: '<ng-content></ng-content>',
                        exportAs: 'mdcIcon',
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcIcon.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.Renderer2 },
            { type: core.ElementRef },
            { type: String, decorators: [{ type: core.Attribute, args: ['aria-hidden',] }] }
        ]; };
        MdcIcon.propDecorators = {
            fontSet: [{ type: core.Input }],
            fontIcon: [{ type: core.Input }],
            fontSize: [{ type: core.Input }],
            leading: [{ type: core.Input }],
            trailing: [{ type: core.Input }],
            clickable: [{ type: core.Input }],
            isHostClass: [{ type: core.HostBinding, args: ['class.ng-mdc-icon',] }]
        };
        return MdcIcon;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcIconModule = /** @class */ (function () {
        function MdcIconModule() {
        }
        MdcIconModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [MdcIcon],
                        declarations: [MdcIcon],
                    },] },
        ];
        return MdcIconModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcButton = /** @class */ (function () {
        function MdcButton(_elementRef, _ripple) {
            this._elementRef = _elementRef;
            this._ripple = _ripple;
            this._raised = false;
            this._primary = false;
            this._dense = false;
            this._secondary = false;
            this._unelevated = false;
            this._outlined = false;
            this._disabled = false;
            this.isHostClass = true;
        }
        Object.defineProperty(MdcButton.prototype, "raised", {
            get: /**
             * @return {?}
             */
            function () { return this._raised; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setRaised(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcButton.prototype, "primary", {
            get: /**
             * @return {?}
             */
            function () { return this._primary; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setPrimary(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcButton.prototype, "dense", {
            get: /**
             * @return {?}
             */
            function () { return this._dense; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setDense(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcButton.prototype, "secondary", {
            get: /**
             * @return {?}
             */
            function () { return this._secondary; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setSecondary(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcButton.prototype, "unelevated", {
            get: /**
             * @return {?}
             */
            function () { return this._unelevated; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setUnelevated(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcButton.prototype, "outlined", {
            get: /**
             * @return {?}
             */
            function () { return this._outlined; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setOutlined(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcButton.prototype, "icon", {
            get: /**
             * @return {?}
             */
            function () { return this._icon; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setIcon(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcButton.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setDisabled(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcButton.prototype, "tabindex", {
            get: /**
             * @return {?}
             */
            function () {
                return this.disabled ? -1 : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcButton.prototype, "classRaised", {
            get: /**
             * @return {?}
             */
            function () {
                return this.raised ? 'mdc-button--raised' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcButton.prototype, "classPrimary", {
            get: /**
             * @return {?}
             */
            function () {
                return this.primary ? 'ng-mdc-button--primary' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcButton.prototype, "classSecondary", {
            get: /**
             * @return {?}
             */
            function () {
                return this.secondary ? 'ng-mdc-button--secondary' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcButton.prototype, "classDense", {
            get: /**
             * @return {?}
             */
            function () {
                return this.dense ? 'mdc-button--dense' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcButton.prototype, "classUnelevated", {
            get: /**
             * @return {?}
             */
            function () {
                return this.unelevated ? 'mdc-button--unelevated' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcButton.prototype, "classOutlined", {
            get: /**
             * @return {?}
             */
            function () {
                return this.outlined ? 'mdc-button--outlined' : '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcButton.prototype.onclick = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            this._onClick(evt);
        };
        /**
         * @return {?}
         */
        MdcButton.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            this._ripple.attachTo(this.getHostElement());
        };
        /**
         * @return {?}
         */
        MdcButton.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._ripple.destroy();
        };
        /**
         * @param {?} disabled
         * @return {?}
         */
        MdcButton.prototype.setDisabled = /**
         * @param {?} disabled
         * @return {?}
         */
        function (disabled) {
            this._disabled = disabled;
            if (disabled) {
                this.getHostElement().setAttribute('disabled', 'true');
                this.getHostElement().setAttribute('aria-disabled', 'true');
            }
            else {
                this.getHostElement().removeAttribute('disabled');
                this.getHostElement().removeAttribute('aria-disabled');
            }
        };
        /**
         * @param {?} raised
         * @return {?}
         */
        MdcButton.prototype.setRaised = /**
         * @param {?} raised
         * @return {?}
         */
        function (raised) {
            this._raised = raised;
        };
        /**
         * @param {?} primary
         * @return {?}
         */
        MdcButton.prototype.setPrimary = /**
         * @param {?} primary
         * @return {?}
         */
        function (primary) {
            this._primary = primary;
        };
        /**
         * @param {?} dense
         * @return {?}
         */
        MdcButton.prototype.setDense = /**
         * @param {?} dense
         * @return {?}
         */
        function (dense) {
            this._dense = dense;
        };
        /**
         * @param {?} secondary
         * @return {?}
         */
        MdcButton.prototype.setSecondary = /**
         * @param {?} secondary
         * @return {?}
         */
        function (secondary) {
            this._secondary = secondary;
        };
        /**
         * @param {?} unelevated
         * @return {?}
         */
        MdcButton.prototype.setUnelevated = /**
         * @param {?} unelevated
         * @return {?}
         */
        function (unelevated) {
            this._unelevated = unelevated;
        };
        /**
         * @param {?} outlined
         * @return {?}
         */
        MdcButton.prototype.setOutlined = /**
         * @param {?} outlined
         * @return {?}
         */
        function (outlined) {
            this._outlined = outlined;
        };
        /**
         * @param {?} icon
         * @return {?}
         */
        MdcButton.prototype.setIcon = /**
         * @param {?} icon
         * @return {?}
         */
        function (icon) {
            this._icon = icon;
            if (this.buttonIcon) {
                this.buttonIcon.elementRef.nativeElement.classList.add('mdc-button__icon');
            }
            else if (icon) {
                this.icon.classList.add('mdc-button__icon');
            }
        };
        /** Focuses the button. */
        /**
         * Focuses the button.
         * @return {?}
         */
        MdcButton.prototype.focus = /**
         * Focuses the button.
         * @return {?}
         */
        function () {
            this.getHostElement().focus();
        };
        /**
         * @return {?}
         */
        MdcButton.prototype.getHostElement = /**
         * @return {?}
         */
        function () {
            return this._elementRef.nativeElement;
        };
        /**
         * @param {?} event
         * @return {?}
         */
        MdcButton.prototype._onClick = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            // A disabled button shouldn't apply any actions
            if (this.disabled) {
                event.preventDefault();
                event.stopImmediatePropagation();
            }
        };
        MdcButton.decorators = [
            { type: core.Component, args: [{exportAs: 'mdcButton',
                        selector: 'button[mdc-button], a[mdc-button]',
                        template: '<ng-content></ng-content>',
                        providers: [
                            MdcRipple,
                            EventRegistry
                        ],
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcButton.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: MdcRipple }
        ]; };
        MdcButton.propDecorators = {
            raised: [{ type: core.Input }],
            primary: [{ type: core.Input }],
            dense: [{ type: core.Input }],
            secondary: [{ type: core.Input }],
            unelevated: [{ type: core.Input }],
            outlined: [{ type: core.Input }],
            icon: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            tabindex: [{ type: core.HostBinding, args: ['tabindex',] }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-button',] }],
            classRaised: [{ type: core.HostBinding, args: ['class.mdc-button--raised',] }],
            classPrimary: [{ type: core.HostBinding, args: ['class.ng-mdc-button--primary',] }],
            classSecondary: [{ type: core.HostBinding, args: ['class.ng-mdc-button--secondary',] }],
            classDense: [{ type: core.HostBinding, args: ['class.mdc-button--dense',] }],
            classUnelevated: [{ type: core.HostBinding, args: ['class.mdc-button--unelevated',] }],
            classOutlined: [{ type: core.HostBinding, args: ['class.mdc-button--outlined',] }],
            onclick: [{ type: core.HostListener, args: ['click', ['$event'],] }],
            buttonIcon: [{ type: core.ContentChild, args: [MdcIcon,] }]
        };
        return MdcButton;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcButtonModule = /** @class */ (function () {
        function MdcButtonModule() {
        }
        MdcButtonModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [MdcButton],
                        declarations: [MdcButton]
                    },] },
        ];
        return MdcButtonModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcCardMediaContent = /** @class */ (function () {
        function MdcCardMediaContent(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcCardMediaContent.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-card-media-content, [mdcCardMediaContent]',
                        exportAs: 'mdcCardMediaContent'
                    },] },
        ];
        /** @nocollapse */
        MdcCardMediaContent.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcCardMediaContent.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-card__media-content',] }]
        };
        return MdcCardMediaContent;
    }());
    var MdcCardMedia = /** @class */ (function () {
        function MdcCardMedia(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        Object.defineProperty(MdcCardMedia.prototype, "square", {
            get: /**
             * @return {?}
             */
            function () { return this._square; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setSquare(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcCardMedia.prototype, "wide", {
            get: /**
             * @return {?}
             */
            function () { return this._wide; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setWide(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcCardMedia.prototype, "classSquare", {
            get: /**
             * @return {?}
             */
            function () {
                return this.square ? 'mdc-card__media--square' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcCardMedia.prototype, "classWide", {
            get: /**
             * @return {?}
             */
            function () {
                return this._wide ? 'mdc-card__media--16-9' : '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} wide
         * @return {?}
         */
        MdcCardMedia.prototype.setWide = /**
         * @param {?} wide
         * @return {?}
         */
        function (wide) {
            this._wide = wide;
        };
        /**
         * @param {?} square
         * @return {?}
         */
        MdcCardMedia.prototype.setSquare = /**
         * @param {?} square
         * @return {?}
         */
        function (square) {
            this._square = square;
        };
        MdcCardMedia.decorators = [
            { type: core.Component, args: [{selector: 'mdc-card-media, [mdcCardMedia]',
                        template: '<ng-content></ng-content>',
                        exportAs: 'mdcCardMedia',
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcCardMedia.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcCardMedia.propDecorators = {
            square: [{ type: core.Input }],
            wide: [{ type: core.Input }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-card__media',] }],
            classSquare: [{ type: core.HostBinding, args: ['class.mdc-card__media--square',] }],
            classWide: [{ type: core.HostBinding, args: ['class.mdc-card__media--16-9',] }]
        };
        return MdcCardMedia;
    }());
    var MdcCardPrimaryAction = /** @class */ (function () {
        function MdcCardPrimaryAction(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcCardPrimaryAction.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-card-primary-action, [mdcCardPrimaryAction]',
                        exportAs: 'mdcCardPrimaryAction'
                    },] },
        ];
        /** @nocollapse */
        MdcCardPrimaryAction.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcCardPrimaryAction.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-card__primary-action',] }]
        };
        return MdcCardPrimaryAction;
    }());
    var MdcCardActions = /** @class */ (function () {
        function MdcCardActions(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        Object.defineProperty(MdcCardActions.prototype, "fullBleed", {
            get: /**
             * @return {?}
             */
            function () { return this._fullBleed; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._fullBleed = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcCardActions.prototype, "buttons", {
            get: /**
             * @return {?}
             */
            function () { return this._buttons; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._buttons = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcCardActions.prototype, "icons", {
            get: /**
             * @return {?}
             */
            function () { return this._icons; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._icons = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcCardActions.prototype, "classFullBleed", {
            get: /**
             * @return {?}
             */
            function () {
                return this.fullBleed ? 'mdc-card__actions--full-bleed' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcCardActions.prototype, "classActionButtons", {
            get: /**
             * @return {?}
             */
            function () {
                return this.buttons ? 'mdc-card__action-buttons' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcCardActions.prototype, "classActionIcons", {
            get: /**
             * @return {?}
             */
            function () {
                return this.icons ? 'mdc-card__action-icons' : '';
            },
            enumerable: true,
            configurable: true
        });
        MdcCardActions.decorators = [
            { type: core.Component, args: [{selector: 'mdc-card-actions, [mdcCardActions]',
                        template: '<ng-content></ng-content>',
                        exportAs: 'mdcCardActions',
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcCardActions.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcCardActions.propDecorators = {
            fullBleed: [{ type: core.Input }],
            buttons: [{ type: core.Input }],
            icons: [{ type: core.Input }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-card__actions',] }],
            classFullBleed: [{ type: core.HostBinding, args: ['class.mdc-card__actions--full-bleed',] }],
            classActionButtons: [{ type: core.HostBinding, args: ['class.mdc-card__action-buttons',] }],
            classActionIcons: [{ type: core.HostBinding, args: ['class.mdc-card__action-icons',] }]
        };
        return MdcCardActions;
    }());
    var MdcCardActionButtons = /** @class */ (function () {
        function MdcCardActionButtons(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcCardActionButtons.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-card-action-buttons, [mdcCardActionButtons]',
                        exportAs: 'mdcCardActionButtons'
                    },] },
        ];
        /** @nocollapse */
        MdcCardActionButtons.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcCardActionButtons.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-card__action-buttons',] }]
        };
        return MdcCardActionButtons;
    }());
    var MdcCardActionIcons = /** @class */ (function () {
        function MdcCardActionIcons(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcCardActionIcons.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-card-action-icons, [mdcCardActionIcons]',
                        exportAs: 'mdcCardActionIcons'
                    },] },
        ];
        /** @nocollapse */
        MdcCardActionIcons.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcCardActionIcons.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-card__action-icons',] }]
        };
        return MdcCardActionIcons;
    }());
    var MdcCardAction = /** @class */ (function () {
        function MdcCardAction(_renderer, elementRef) {
            this._renderer = _renderer;
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        Object.defineProperty(MdcCardAction.prototype, "action", {
            get: /**
             * @return {?}
             */
            function () { return this._action; },
            set: /**
             * @param {?} action
             * @return {?}
             */
            function (action) {
                // If the directive is set without a name (updated programatically), then this setter will
                // trigger with an empty string and should not overwrite the programatically set value.
                if (!action) {
                    return;
                }
                if (action === 'button') {
                    this._renderer.addClass(this.elementRef.nativeElement, 'mdc-card__action--button');
                }
                else if (action === 'icon') {
                    this._renderer.addClass(this.elementRef.nativeElement, 'mdc-card__action--icon');
                    this._renderer.setAttribute(this.elementRef.nativeElement, 'tabIndex', '0');
                    this._renderer.setAttribute(this.elementRef.nativeElement, 'role', 'button');
                }
                this._action = action;
            },
            enumerable: true,
            configurable: true
        });
        MdcCardAction.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcCardAction]'
                    },] },
        ];
        /** @nocollapse */
        MdcCardAction.ctorParameters = function () { return [
            { type: core.Renderer2 },
            { type: core.ElementRef }
        ]; };
        MdcCardAction.propDecorators = {
            action: [{ type: core.Input, args: ['mdcCardAction',] }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-card__action',] }]
        };
        return MdcCardAction;
    }());
    var MdcCard = /** @class */ (function () {
        function MdcCard(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        Object.defineProperty(MdcCard.prototype, "outlined", {
            get: /**
             * @return {?}
             */
            function () { return this._outlined; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setOutlined(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcCard.prototype, "classOutlined", {
            get: /**
             * @return {?}
             */
            function () {
                return this.outlined ? 'mdc-card--outlined' : '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} outlined
         * @return {?}
         */
        MdcCard.prototype.setOutlined = /**
         * @param {?} outlined
         * @return {?}
         */
        function (outlined) {
            this._outlined = outlined;
        };
        MdcCard.decorators = [
            { type: core.Component, args: [{selector: 'mdc-card, [mdc-card]',
                        template: '<ng-content></ng-content>',
                        exportAs: 'mdcCard',
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcCard.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcCard.propDecorators = {
            outlined: [{ type: core.Input }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-card',] }],
            classOutlined: [{ type: core.HostBinding, args: ['class.mdc-card--outlined',] }]
        };
        return MdcCard;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ CARD_DECLARATIONS = [
        MdcCard,
        MdcCardAction,
        MdcCardActionButtons,
        MdcCardActionIcons,
        MdcCardActions,
        MdcCardMedia,
        MdcCardMediaContent,
        MdcCardPrimaryAction
    ];
    var MdcCardModule = /** @class */ (function () {
        function MdcCardModule() {
        }
        MdcCardModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: CARD_DECLARATIONS,
                        declarations: CARD_DECLARATIONS,
                    },] },
        ];
        return MdcCardModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @abstract
     * @template T
     */
    var   /**
     * @abstract
     * @template T
     */
    MdcFormFieldControl = /** @class */ (function () {
        function MdcFormFieldControl() {
        }
        return MdcFormFieldControl;
    }());

    function _classCallCheck$3(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$3(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$3(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$3(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$3(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$3(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$3(subClass, superClass);
    }

    function _getPrototypeOf$3(o) {
      _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$3(o);
    }

    function _setPrototypeOf$3(o, p) {
      _setPrototypeOf$3 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$3(o, p);
    }

    function _assertThisInitialized$3(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$3(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$3(self);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @template A
     */
    var MDCFoundation$2 =
    /*#__PURE__*/
    function () {
      _createClass$3(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$3(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$3(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$2 =
    /*#__PURE__*/
    function () {
      _createClass$3(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$2());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$3(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$3(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Form Field. Provides an interface for managing
     * - event handlers
     * - ripple activation
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCFormFieldAdapter =
    /*#__PURE__*/
    function () {
      function MDCFormFieldAdapter() {
        _classCallCheck$3(this, MDCFormFieldAdapter);
      }

      _createClass$3(MDCFormFieldAdapter, [{
        key: "registerInteractionHandler",

        /**
         * @param {string} type
         * @param {!EventListener} handler
         */
        value: function registerInteractionHandler(type, handler) {}
        /**
         * @param {string} type
         * @param {!EventListener} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(type, handler) {}
      }, {
        key: "activateInputRipple",
        value: function activateInputRipple() {}
      }, {
        key: "deactivateInputRipple",
        value: function deactivateInputRipple() {}
      }]);

      return MDCFormFieldAdapter;
    }();

    /**
     * @license
     * Copyright 2017 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var cssClasses$2 = {
      ROOT: 'mdc-form-field'
    };
    /** @enum {string} */

    var strings$2 = {
      LABEL_SELECTOR: '.mdc-form-field > label'
    };

    /**
     * @extends {MDCFoundation<!MDCFormFieldAdapter>}
     */

    var MDCFormFieldFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$3(MDCFormFieldFoundation, _MDCFoundation);

      _createClass$3(MDCFormFieldFoundation, null, [{
        key: "cssClasses",

        /** @return enum {cssClasses} */
        get: function get() {
          return cssClasses$2;
        }
        /** @return enum {strings} */

      }, {
        key: "strings",
        get: function get() {
          return strings$2;
        }
        /** @return {!MDCFormFieldAdapter} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            registerInteractionHandler: function registerInteractionHandler()
            /* type: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* type: string, handler: EventListener */
            {},
            activateInputRipple: function activateInputRipple() {},
            deactivateInputRipple: function deactivateInputRipple() {}
          };
        }
      }]);

      function MDCFormFieldFoundation(adapter) {
        var _this;

        _classCallCheck$3(this, MDCFormFieldFoundation);

        _this = _possibleConstructorReturn$3(this, _getPrototypeOf$3(MDCFormFieldFoundation).call(this, Object.assign(MDCFormFieldFoundation.defaultAdapter, adapter)));
        /** @private {!EventListener} */

        _this.clickHandler_ =
        /** @type {!EventListener} */
        function () {
          return _this.handleClick_();
        };

        return _this;
      }

      _createClass$3(MDCFormFieldFoundation, [{
        key: "init",
        value: function init() {
          this.adapter_.registerInteractionHandler('click', this.clickHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
        }
        /** @private */

      }, {
        key: "handleClick_",
        value: function handleClick_() {
          var _this2 = this;

          this.adapter_.activateInputRipple();
          requestAnimationFrame(function () {
            return _this2.adapter_.deactivateInputRipple();
          });
        }
      }]);

      return MDCFormFieldFoundation;
    }(MDCFoundation$2);

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Ripple. Provides an interface for managing
     * - classes
     * - dom
     * - CSS variables
     * - position
     * - dimensions
     * - scroll position
     * - event handlers
     * - unbounded, active and disabled states
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCRippleAdapter$2 =
    /*#__PURE__*/
    function () {
      function MDCRippleAdapter() {
        _classCallCheck$3(this, MDCRippleAdapter);
      }

      _createClass$3(MDCRippleAdapter, [{
        key: "browserSupportsCssVars",

        /** @return {boolean} */
        value: function browserSupportsCssVars() {}
        /** @return {boolean} */

      }, {
        key: "isUnbounded",
        value: function isUnbounded() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceActive",
        value: function isSurfaceActive() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceDisabled",
        value: function isSurfaceDisabled() {}
        /** @param {string} className */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @param {!EventTarget} target */

      }, {
        key: "containsEventTarget",
        value: function containsEventTarget(target) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerDocumentInteractionHandler",
        value: function registerDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterDocumentInteractionHandler",
        value: function deregisterDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /**
         * @param {string} varName
         * @param {?number|string} value
         */

      }, {
        key: "updateCssVariable",
        value: function updateCssVariable(varName, value) {}
        /** @return {!ClientRect} */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}
        /** @return {{x: number, y: number}} */

      }, {
        key: "getWindowPageOffset",
        value: function getWindowPageOffset() {}
      }]);

      return MDCRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var cssClasses$1$2 = {
      // Ripple is a special case where the "root" component is really a "mixin" of sorts,
      // given that it's an 'upgrade' to an existing component. That being said it is the root
      // CSS class that all other CSS classes derive from.
      ROOT: 'mdc-ripple-upgraded',
      UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
      BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
      FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
      FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
    };
    var strings$1$2 = {
      VAR_LEFT: '--mdc-ripple-left',
      VAR_TOP: '--mdc-ripple-top',
      VAR_FG_SIZE: '--mdc-ripple-fg-size',
      VAR_FG_SCALE: '--mdc-ripple-fg-scale',
      VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
      VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
    };
    var numbers$2 = {
      PADDING: 10,
      INITIAL_ORIGIN_SCALE: 0.6,
      DEACTIVATION_TIMEOUT_MS: 225,
      // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
      FG_DEACTIVATION_MS: 150,
      // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
      TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

    };

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
     * @private {boolean|undefined}
     */
    var supportsCssVariables_$2;
    /**
     * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
     * @private {boolean|undefined}
     */

    var supportsPassive_$2;
    /**
     * @param {!Window} windowObj
     * @return {boolean}
     */

    function detectEdgePseudoVarBug$2(windowObj) {
      // Detect versions of Edge with buggy var() support
      // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
      var document = windowObj.document;
      var node = document.createElement('div');
      node.className = 'mdc-ripple-surface--test-edge-var-bug';
      document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
      // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
      // but Firefox is known to support CSS custom properties correctly.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

      var computedStyle = windowObj.getComputedStyle(node);
      var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
      node.remove();
      return hasPseudoVarBug;
    }
    /**
     * @param {!Window} windowObj
     * @param {boolean=} forceRefresh
     * @return {boolean|undefined}
     */


    function supportsCssVariables$2(windowObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var supportsCssVariables = supportsCssVariables_$2;

      if (typeof supportsCssVariables_$2 === 'boolean' && !forceRefresh) {
        return supportsCssVariables;
      }

      var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

      if (!supportsFunctionPresent) {
        return;
      }

      var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
      // See: README section on Safari

      var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

      if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVariables = !detectEdgePseudoVarBug$2(windowObj);
      } else {
        supportsCssVariables = false;
      }

      if (!forceRefresh) {
        supportsCssVariables_$2 = supportsCssVariables;
      }

      return supportsCssVariables;
    } //

    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|{passive: boolean}}
     */


    function applyPassive$2() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_$2 === undefined || forceRefresh) {
        var isSupported = false;

        try {
          globalObj.document.addEventListener('test', null, {
            get passive() {
              isSupported = true;
            }

          });
        } catch (e) {}

        supportsPassive_$2 = isSupported;
      }

      return supportsPassive_$2 ? {
        passive: true
      } : false;
    }
    /**
     * @param {!Object} HTMLElementPrototype
     * @return {!Array<string>}
     */


    function getMatchesProperty$2(HTMLElementPrototype) {
      return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(function (p) {
        return p in HTMLElementPrototype;
      }).pop();
    }
    /**
     * @param {!Event} ev
     * @param {{x: number, y: number}} pageOffset
     * @param {!ClientRect} clientRect
     * @return {{x: number, y: number}}
     */


    function getNormalizedEventCoords$2(ev, pageOffset, clientRect) {
      var x = pageOffset.x,
          y = pageOffset.y;
      var documentX = x + clientRect.left;
      var documentY = y + clientRect.top;
      var normalizedX;
      var normalizedY; // Determine touch point relative to the ripple container.

      if (ev.type === 'touchstart') {
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
      } else {
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
      }

      return {
        x: normalizedX,
        y: normalizedY
      };
    }

    var ACTIVATION_EVENT_TYPES$2 = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

    var POINTER_DEACTIVATION_EVENT_TYPES$2 = ['touchend', 'pointerup', 'mouseup']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

    /** @type {!Array<!EventTarget>} */

    var activatedTargets$2 = [];
    /**
     * @extends {MDCFoundation<!MDCRippleAdapter>}
     */

    var MDCRippleFoundation$2 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$3(MDCRippleFoundation, _MDCFoundation);

      _createClass$3(MDCRippleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$1$2;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$1$2;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers$2;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            browserSupportsCssVars: function browserSupportsCssVars()
            /* boolean - cached */
            {},
            isUnbounded: function isUnbounded()
            /* boolean */
            {},
            isSurfaceActive: function isSurfaceActive()
            /* boolean */
            {},
            isSurfaceDisabled: function isSurfaceDisabled()
            /* boolean */
            {},
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            containsEventTarget: function containsEventTarget()
            /* target: !EventTarget */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            updateCssVariable: function updateCssVariable()
            /* varName: string, value: string */
            {},
            computeBoundingRect: function computeBoundingRect()
            /* ClientRect */
            {},
            getWindowPageOffset: function getWindowPageOffset()
            /* {x: number, y: number} */
            {}
          };
        }
      }]);

      function MDCRippleFoundation(adapter) {
        var _this;

        _classCallCheck$3(this, MDCRippleFoundation);

        _this = _possibleConstructorReturn$3(this, _getPrototypeOf$3(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
        /** @private {number} */

        _this.layoutFrame_ = 0;
        /** @private {!ClientRect} */

        _this.frame_ =
        /** @type {!ClientRect} */
        {
          width: 0,
          height: 0
        };
        /** @private {!ActivationStateType} */

        _this.activationState_ = _this.defaultActivationState_();
        /** @private {number} */

        _this.initialSize_ = 0;
        /** @private {number} */

        _this.maxRadius_ = 0;
        /** @private {function(!Event)} */

        _this.activateHandler_ = function (e) {
          return _this.activate_(e);
        };
        /** @private {function(!Event)} */


        _this.deactivateHandler_ = function (e) {
          return _this.deactivate_(e);
        };
        /** @private {function(?Event=)} */


        _this.focusHandler_ = function () {
          return _this.handleFocus();
        };
        /** @private {function(?Event=)} */


        _this.blurHandler_ = function () {
          return _this.handleBlur();
        };
        /** @private {!Function} */


        _this.resizeHandler_ = function () {
          return _this.layout();
        };
        /** @private {{left: number, top:number}} */


        _this.unboundedCoords_ = {
          left: 0,
          top: 0
        };
        /** @private {number} */

        _this.fgScale_ = 0;
        /** @private {number} */

        _this.activationTimer_ = 0;
        /** @private {number} */

        _this.fgDeactivationRemovalTimer_ = 0;
        /** @private {boolean} */

        _this.activationAnimationHasEnded_ = false;
        /** @private {!Function} */

        _this.activationTimerCallback_ = function () {
          _this.activationAnimationHasEnded_ = true;

          _this.runDeactivationUXLogicIfReady_();
        };
        /** @private {?Event} */


        _this.previousActivationEvent_ = null;
        return _this;
      }
      /**
       * We compute this property so that we are not querying information about the client
       * until the point in time where the foundation requests it. This prevents scenarios where
       * client-side feature-detection may happen too early, such as when components are rendered on the server
       * and then initialized at mount time on the client.
       * @return {boolean}
       * @private
       */


      _createClass$3(MDCRippleFoundation, [{
        key: "isSupported_",
        value: function isSupported_() {
          return this.adapter_.browserSupportsCssVars();
        }
        /**
         * @return {!ActivationStateType}
         */

      }, {
        key: "defaultActivationState_",
        value: function defaultActivationState_() {
          return {
            isActivated: false,
            hasDeactivationUXRun: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
            activationEvent: null,
            isProgrammatic: false
          };
        }
        /** @override */

      }, {
        key: "init",
        value: function init() {
          var _this2 = this;

          if (!this.isSupported_()) {
            return;
          }

          this.registerRootHandlers_();
          var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$.ROOT,
              UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
          requestAnimationFrame(function () {
            _this2.adapter_.addClass(ROOT);

            if (_this2.adapter_.isUnbounded()) {
              _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


              _this2.layoutInternal_();
            }
          });
        }
        /** @override */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          if (!this.isSupported_()) {
            return;
          }

          if (this.activationTimer_) {
            clearTimeout(this.activationTimer_);
            this.activationTimer_ = 0;
            var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
            this.adapter_.removeClass(FG_ACTIVATION);
          }

          this.deregisterRootHandlers_();
          this.deregisterDeactivationHandlers_();
          var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$2.ROOT,
              UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
          requestAnimationFrame(function () {
            _this3.adapter_.removeClass(ROOT);

            _this3.adapter_.removeClass(UNBOUNDED);

            _this3.removeCssVars_();
          });
        }
        /** @private */

      }, {
        key: "registerRootHandlers_",
        value: function registerRootHandlers_() {
          var _this4 = this;

          ACTIVATION_EVENT_TYPES$2.forEach(function (type) {
            _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
          });
          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.registerResizeHandler(this.resizeHandler_);
          }
        }
        /**
         * @param {!Event} e
         * @private
         */

      }, {
        key: "registerDeactivationHandlers_",
        value: function registerDeactivationHandlers_(e) {
          var _this5 = this;

          if (e.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
          } else {
            POINTER_DEACTIVATION_EVENT_TYPES$2.forEach(function (type) {
              _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
            });
          }
        }
        /** @private */

      }, {
        key: "deregisterRootHandlers_",
        value: function deregisterRootHandlers_() {
          var _this6 = this;

          ACTIVATION_EVENT_TYPES$2.forEach(function (type) {
            _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
          });
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          }
        }
        /** @private */

      }, {
        key: "deregisterDeactivationHandlers_",
        value: function deregisterDeactivationHandlers_() {
          var _this7 = this;

          this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
          POINTER_DEACTIVATION_EVENT_TYPES$2.forEach(function (type) {
            _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
          });
        }
        /** @private */

      }, {
        key: "removeCssVars_",
        value: function removeCssVars_() {
          var _this8 = this;

          var strings = MDCRippleFoundation.strings;
          Object.keys(strings).forEach(function (k) {
            if (k.indexOf('VAR_') === 0) {
              _this8.adapter_.updateCssVariable(strings[k], null);
            }
          });
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "activate_",
        value: function activate_(e) {
          var _this9 = this;

          if (this.adapter_.isSurfaceDisabled()) {
            return;
          }

          var activationState = this.activationState_;

          if (activationState.isActivated) {
            return;
          } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


          var previousActivationEvent = this.previousActivationEvent_;
          var isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;

          if (isSameInteraction) {
            return;
          }

          activationState.isActivated = true;
          activationState.isProgrammatic = e === null;
          activationState.activationEvent = e;
          activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';
          var hasActivatedChild = e && activatedTargets$2.length > 0 && activatedTargets$2.some(function (target) {
            return _this9.adapter_.containsEventTarget(target);
          });

          if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
          }

          if (e) {
            activatedTargets$2.push(
            /** @type {!EventTarget} */
            e.target);
            this.registerDeactivationHandlers_(e);
          }

          activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

          if (activationState.wasElementMadeActive) {
            this.animateActivation_();
          }

          requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets$2 = [];

            if (!activationState.wasElementMadeActive && (e.key === ' ' || e.keyCode === 32)) {
              // If space was pressed, try again within an rAF call to detect :active, because different UAs report
              // active states inconsistently when they're called within event handling code:
              // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
              // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
              // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
              // variable is set within a rAF callback for a submit button interaction (#2241).
              activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

              if (activationState.wasElementMadeActive) {
                _this9.animateActivation_();
              }
            }

            if (!activationState.wasElementMadeActive) {
              // Reset activation state immediately if element was not made active.
              _this9.activationState_ = _this9.defaultActivationState_();
            }
          });
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "checkElementMadeActive_",
        value: function checkElementMadeActive_(e) {
          return e && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
        }
        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: "activate",
        value: function activate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          this.activate_(event);
        }
        /** @private */

      }, {
        key: "animateActivation_",
        value: function animateActivation_() {
          var _this10 = this;

          var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
              VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
              VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
          var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
              FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
              FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
          var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
          this.layoutInternal_();
          var translateStart = '';
          var translateEnd = '';

          if (!this.adapter_.isUnbounded()) {
            var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
                startPoint = _this$getFgTranslatio.startPoint,
                endPoint = _this$getFgTranslatio.endPoint;

            translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
            translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
          }

          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

          clearTimeout(this.activationTimer_);
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.rmBoundedActivationClasses_();
          this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

          this.adapter_.computeBoundingRect();
          this.adapter_.addClass(FG_ACTIVATION);
          this.activationTimer_ = setTimeout(function () {
            return _this10.activationTimerCallback_();
          }, DEACTIVATION_TIMEOUT_MS);
        }
        /**
         * @private
         * @return {{startPoint: PointType, endPoint: PointType}}
         */

      }, {
        key: "getFgTranslationCoordinates_",
        value: function getFgTranslationCoordinates_() {
          var _this$activationState = this.activationState_,
              activationEvent = _this$activationState.activationEvent,
              wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
          var startPoint;

          if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords$2(
            /** @type {!Event} */
            activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
          } else {
            startPoint = {
              x: this.frame_.width / 2,
              y: this.frame_.height / 2
            };
          } // Center the element around the start point.


          startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
          };
          var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
          };
          return {
            startPoint: startPoint,
            endPoint: endPoint
          };
        }
        /** @private */

      }, {
        key: "runDeactivationUXLogicIfReady_",
        value: function runDeactivationUXLogicIfReady_() {
          var _this11 = this;

          // This method is called both when a pointing device is released, and when the activation animation ends.
          // The deactivation animation should only run after both of those occur.
          var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
          var _this$activationState2 = this.activationState_,
              hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
              isActivated = _this$activationState2.isActivated;
          var activationHasEnded = hasDeactivationUXRun || !isActivated;

          if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
              _this11.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers$2.FG_DEACTIVATION_MS);
          }
        }
        /** @private */

      }, {
        key: "rmBoundedActivationClasses_",
        value: function rmBoundedActivationClasses_() {
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
          this.adapter_.removeClass(FG_ACTIVATION);
          this.activationAnimationHasEnded_ = false;
          this.adapter_.computeBoundingRect();
        }
      }, {
        key: "resetActivationState_",
        value: function resetActivationState_() {
          var _this12 = this;

          this.previousActivationEvent_ = this.activationState_.activationEvent;
          this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
          // Store the previous event until it's safe to assume that subsequent events are for new interactions.

          setTimeout(function () {
            return _this12.previousActivationEvent_ = null;
          }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "deactivate_",
        value: function deactivate_(e) {
          var _this13 = this;

          var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

          if (!activationState.isActivated) {
            return;
          }

          var state =
          /** @type {!ActivationStateType} */
          Object.assign({}, activationState);

          if (activationState.isProgrammatic) {
            var evtObject = null;
            requestAnimationFrame(function () {
              return _this13.animateDeactivation_(evtObject, state);
            });
            this.resetActivationState_();
          } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
              _this13.activationState_.hasDeactivationUXRun = true;

              _this13.animateDeactivation_(e, state);

              _this13.resetActivationState_();
            });
          }
        }
        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          this.deactivate_(event);
        }
        /**
         * @param {Event} e
         * @param {!ActivationStateType} options
         * @private
         */

      }, {
        key: "animateDeactivation_",
        value: function animateDeactivation_(e, _ref) {
          var wasActivatedByPointer = _ref.wasActivatedByPointer,
              wasElementMadeActive = _ref.wasElementMadeActive;

          if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this14 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }

          this.layoutFrame_ = requestAnimationFrame(function () {
            _this14.layoutInternal_();

            _this14.layoutFrame_ = 0;
          });
        }
        /** @private */

      }, {
        key: "layoutInternal_",
        value: function layoutInternal_() {
          var _this15 = this;

          this.frame_ = this.adapter_.computeBoundingRect();
          var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
          // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
          // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
          // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
          // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
          // `overflow: hidden`.

          var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
          };

          this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

          this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;
          this.fgScale_ = this.maxRadius_ / this.initialSize_;
          this.updateLayoutCssVars_();
        }
        /** @private */

      }, {
        key: "updateLayoutCssVars_",
        value: function updateLayoutCssVars_() {
          var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
              VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
              VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
              VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
              VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
          this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
          this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

          if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
              left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
              top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };
            this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
            this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
          }
        }
        /** @param {boolean} unbounded */

      }, {
        key: "setUnbounded",
        value: function setUnbounded(unbounded) {
          var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

          if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
          } else {
            this.adapter_.removeClass(UNBOUNDED);
          }
        }
      }, {
        key: "handleFocus",
        value: function handleFocus() {
          var _this16 = this;

          requestAnimationFrame(function () {
            return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }, {
        key: "handleBlur",
        value: function handleBlur() {
          var _this17 = this;

          requestAnimationFrame(function () {
            return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }]);

      return MDCRippleFoundation;
    }(MDCFoundation$2);

    /**
     * @extends MDCComponent<!MDCRippleFoundation>
     */

    var MDCRipple$2 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$3(MDCRipple, _MDCComponent);

      /** @param {...?} args */
      function MDCRipple() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$3(this, MDCRipple);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$3(this, (_getPrototypeOf2 = _getPrototypeOf$3(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {boolean} */

        _this.disabled = false;
        /** @private {boolean} */

        _this.unbounded_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @param {{isUnbounded: (boolean|undefined)}=} options
       * @return {!MDCRipple}
       */


      _createClass$3(MDCRipple, [{
        key: "setUnbounded_",

        /**
         * Closure Compiler throws an access control error when directly accessing a
         * protected or private property inside a getter/setter, like unbounded above.
         * By accessing the protected property inside a method, we solve that problem.
         * That's why this function exists.
         * @private
         */
        value: function setUnbounded_() {
          this.foundation_.setUnbounded(this.unbounded_);
        }
      }, {
        key: "activate",
        value: function activate() {
          this.foundation_.activate();
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
        /**
         * @return {!MDCRippleFoundation}
         * @override
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          return new MDCRippleFoundation$2(MDCRipple.createAdapter(this));
        }
        /** @override */

      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
        }
      }, {
        key: "unbounded",

        /** @return {boolean} */
        get: function get() {
          return this.unbounded_;
        }
        /** @param {boolean} unbounded */
        ,
        set: function set(unbounded) {
          this.unbounded_ = Boolean(unbounded);
          this.setUnbounded_();
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref$isUnbounded = _ref.isUnbounded,
              isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

          var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

          if (isUnbounded !== undefined) {
            ripple.unbounded =
            /** @type {boolean} */
            isUnbounded;
          }

          return ripple;
        }
        /**
         * @param {!RippleCapableSurface} instance
         * @return {!MDCRippleAdapter}
         */

      }, {
        key: "createAdapter",
        value: function createAdapter(instance) {
          var MATCHES = getMatchesProperty$2(HTMLElement.prototype);
          return {
            browserSupportsCssVars: function browserSupportsCssVars() {
              return supportsCssVariables$2(window);
            },
            isUnbounded: function isUnbounded() {
              return instance.unbounded;
            },
            isSurfaceActive: function isSurfaceActive() {
              return instance.root_[MATCHES](':active');
            },
            isSurfaceDisabled: function isSurfaceDisabled() {
              return instance.disabled;
            },
            addClass: function addClass(className) {
              return instance.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return instance.root_.classList.remove(className);
            },
            containsEventTarget: function containsEventTarget(target) {
              return instance.root_.contains(target);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return instance.root_.addEventListener(evtType, handler, applyPassive$2());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return instance.root_.removeEventListener(evtType, handler, applyPassive$2());
            },
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.addEventListener(evtType, handler, applyPassive$2());
            },
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.removeEventListener(evtType, handler, applyPassive$2());
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return instance.root_.style.setProperty(varName, value);
            },
            computeBoundingRect: function computeBoundingRect() {
              return instance.root_.getBoundingClientRect();
            },
            getWindowPageOffset: function getWindowPageOffset() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            }
          };
        }
      }]);

      return MDCRipple;
    }(MDCComponent$2);

    /**
     * @record
     */

    var MDCSelectionControl =
    /*#__PURE__*/
    function () {
      function MDCSelectionControl() {
        _classCallCheck$3(this, MDCSelectionControl);
      }

      _createClass$3(MDCSelectionControl, [{
        key: "ripple",

        /** @return {?MDCRipple} */
        get: function get() {}
      }]);

      return MDCSelectionControl;
    }();

    /* eslint-enable no-unused-vars */

    /**
     * @extends MDCComponent<!MDCFormFieldFoundation>
     */

    var MDCFormField =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$3(MDCFormField, _MDCComponent);

      _createClass$3(MDCFormField, [{
        key: "input",

        /** @param {?MDCSelectionControl} input */
        set: function set(input) {
          this.input_ = input;
        }
        /** @return {?MDCSelectionControl} */
        ,
        get: function get() {
          return this.input_;
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCFormField(root);
        }
      }]);

      function MDCFormField() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$3(this, MDCFormField);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$3(this, (_getPrototypeOf2 = _getPrototypeOf$3(MDCFormField)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {?MDCSelectionControl} */

        _this.input_;
        return _this;
      }
      /**
       * @return {!Element}
       * @private
       */


      _createClass$3(MDCFormField, [{
        key: "getDefaultFoundation",

        /** @return {!MDCFormFieldFoundation} */
        value: function getDefaultFoundation() {
          var _this2 = this;

          return new MDCFormFieldFoundation({
            registerInteractionHandler: function registerInteractionHandler(type, handler) {
              return _this2.label_.addEventListener(type, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
              return _this2.label_.removeEventListener(type, handler);
            },
            activateInputRipple: function activateInputRipple() {
              if (_this2.input_ && _this2.input_.ripple) {
                _this2.input_.ripple.activate();
              }
            },
            deactivateInputRipple: function deactivateInputRipple() {
              if (_this2.input_ && _this2.input_.ripple) {
                _this2.input_.ripple.deactivate();
              }
            }
          });
        }
      }, {
        key: "label_",
        get: function get() {
          var LABEL_SELECTOR = MDCFormFieldFoundation.strings.LABEL_SELECTOR;
          return (
            /** @type {!Element} */
            this.root_.querySelector(LABEL_SELECTOR)
          );
        }
      }]);

      return MDCFormField;
    }(MDCComponent$2);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcFormField = /** @class */ (function () {
        function MdcFormField(_changeDetectorRef, _renderer, elementRef, _registry) {
            var _this = this;
            this._changeDetectorRef = _changeDetectorRef;
            this._renderer = _renderer;
            this.elementRef = elementRef;
            this._registry = _registry;
            this.isHostClass = true;
            this._mdcAdapter = {
                registerInteractionHandler: function (type, handler) { return _this._registry.listen(type, handler, _this._label); },
                deregisterInteractionHandler: function (type, handler) { return _this._registry.unlisten(type, handler); },
                activateInputRipple: function () {
                    if (_this.input && _this.input.ripple) {
                        _this.input.ripple.activate();
                    }
                },
                deactivateInputRipple: function () {
                    if (_this.input && _this.input.ripple) {
                        _this.input.ripple.deactivate();
                    }
                }
            };
        }
        Object.defineProperty(MdcFormField.prototype, "alignEnd", {
            get: /**
             * @return {?}
             */
            function () { return this._alignEnd; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setAlignEnd(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcFormField.prototype, "classAlignEnd", {
            get: /**
             * @return {?}
             */
            function () {
                return this.alignEnd ? 'mdc-form-field--align-end' : '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcFormField.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            if (this.input) {
                var /** @type {?} */ label = this.input.elementRef.nativeElement;
                if (label.nextSibling.tagName === 'LABEL') {
                    this._label = label.nextSibling;
                    this._renderer.setAttribute(this._label, 'for', this.input.inputId);
                    this._foundation = new MDCFormFieldFoundation(this._mdcAdapter);
                    this._foundation.init();
                    this._changeDetectorRef.markForCheck();
                }
            }
        };
        /**
         * @return {?}
         */
        MdcFormField.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this._foundation) {
                this._foundation.destroy();
            }
        };
        /**
         * @param {?} alignEnd
         * @return {?}
         */
        MdcFormField.prototype.setAlignEnd = /**
         * @param {?} alignEnd
         * @return {?}
         */
        function (alignEnd) {
            this._alignEnd = alignEnd;
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} input
         * @return {?}
         */
        MdcFormField.prototype.setInput = /**
         * @param {?} input
         * @return {?}
         */
        function (input) {
            if (this.input !== input) {
                this.input = input;
                this._changeDetectorRef.markForCheck();
            }
        };
        /**
         * @return {?}
         */
        MdcFormField.prototype.isAlignEnd = /**
         * @return {?}
         */
        function () {
            return this.alignEnd;
        };
        MdcFormField.decorators = [
            { type: core.Component, args: [{selector: 'mdc-form-field',
                        exportAs: 'mdcFormField',
                        template: '<ng-content></ng-content>',
                        providers: [EventRegistry],
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcFormField.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.Renderer2 },
            { type: core.ElementRef },
            { type: EventRegistry }
        ]; };
        MdcFormField.propDecorators = {
            alignEnd: [{ type: core.Input }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-form-field',] }],
            classAlignEnd: [{ type: core.HostBinding, args: ['class.mdc-form-field--align-end',] }],
            input: [{ type: core.ContentChild, args: [MdcFormFieldControl,] }]
        };
        return MdcFormField;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcFormFieldModule = /** @class */ (function () {
        function MdcFormFieldModule() {
        }
        MdcFormFieldModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [MdcFormField],
                        declarations: [MdcFormField]
                    },] },
        ];
        return MdcFormFieldModule;
    }());

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /** @const {Object<string, !VendorPropertyMapType>} */

    var eventTypeMap = {
      'animationstart': {
        noPrefix: 'animationstart',
        webkitPrefix: 'webkitAnimationStart',
        styleProperty: 'animation'
      },
      'animationend': {
        noPrefix: 'animationend',
        webkitPrefix: 'webkitAnimationEnd',
        styleProperty: 'animation'
      },
      'animationiteration': {
        noPrefix: 'animationiteration',
        webkitPrefix: 'webkitAnimationIteration',
        styleProperty: 'animation'
      },
      'transitionend': {
        noPrefix: 'transitionend',
        webkitPrefix: 'webkitTransitionEnd',
        styleProperty: 'transition'
      }
    };
    /** @const {Object<string, !VendorPropertyMapType>} */

    var cssPropertyMap = {
      'animation': {
        noPrefix: 'animation',
        webkitPrefix: '-webkit-animation'
      },
      'transform': {
        noPrefix: 'transform',
        webkitPrefix: '-webkit-transform'
      },
      'transition': {
        noPrefix: 'transition',
        webkitPrefix: '-webkit-transition'
      }
    };
    /**
     * @param {!Object} windowObj
     * @return {boolean}
     */

    function hasProperShape(windowObj) {
      return windowObj['document'] !== undefined && typeof windowObj['document']['createElement'] === 'function';
    }
    /**
     * @param {string} eventType
     * @return {boolean}
     */


    function eventFoundInMaps(eventType) {
      return eventType in eventTypeMap || eventType in cssPropertyMap;
    }
    /**
     * @param {string} eventType
     * @param {!Object<string, !VendorPropertyMapType>} map
     * @param {!Element} el
     * @return {string}
     */


    function getJavaScriptEventName(eventType, map, el) {
      return map[eventType].styleProperty in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
    }
    /**
     * Helper function to determine browser prefix for CSS3 animation events
     * and property names.
     * @param {!Object} windowObj
     * @param {string} eventType
     * @return {string}
     */


    function getAnimationName(windowObj, eventType) {
      if (!hasProperShape(windowObj) || !eventFoundInMaps(eventType)) {
        return eventType;
      }

      var map =
      /** @type {!Object<string, !VendorPropertyMapType>} */
      eventType in eventTypeMap ? eventTypeMap : cssPropertyMap;
      var el = windowObj['document']['createElement']('div');
      var eventName = '';

      if (map === eventTypeMap) {
        eventName = getJavaScriptEventName(eventType, map, el);
      } else {
        eventName = map[eventType].noPrefix in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
      }

      return eventName;
    } // Public functions to access getAnimationName() for JavaScript events or CSS
    /**
     * @param {!Object} windowObj
     * @param {string} eventType
     * @return {string}
     */

    function getCorrectEventName(windowObj, eventType) {
      return getAnimationName(windowObj, eventType);
    }

    function _classCallCheck$4(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$4(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$4(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$4(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$4(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$4(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$4(subClass, superClass);
    }

    function _getPrototypeOf$4(o) {
      _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$4(o);
    }

    function _setPrototypeOf$4(o, p) {
      _setPrototypeOf$4 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$4(o, p);
    }

    function _assertThisInitialized$4(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$4(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$4(self);
    }

    function _superPropBase$2(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$4(object);
        if (object === null) break;
      }

      return object;
    }

    function _get$2(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$2 = Reflect.get;
      } else {
        _get$2 = function _get(target, property, receiver) {
          var base = _superPropBase$2(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get$2(target, property, receiver || target);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @template A
     */
    var MDCFoundation$3 =
    /*#__PURE__*/
    function () {
      _createClass$4(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$4(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$4(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$3 =
    /*#__PURE__*/
    function () {
      _createClass$4(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$3());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$4(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$4(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Ripple. Provides an interface for managing
     * - classes
     * - dom
     * - CSS variables
     * - position
     * - dimensions
     * - scroll position
     * - event handlers
     * - unbounded, active and disabled states
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCRippleAdapter$3 =
    /*#__PURE__*/
    function () {
      function MDCRippleAdapter() {
        _classCallCheck$4(this, MDCRippleAdapter);
      }

      _createClass$4(MDCRippleAdapter, [{
        key: "browserSupportsCssVars",

        /** @return {boolean} */
        value: function browserSupportsCssVars() {}
        /** @return {boolean} */

      }, {
        key: "isUnbounded",
        value: function isUnbounded() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceActive",
        value: function isSurfaceActive() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceDisabled",
        value: function isSurfaceDisabled() {}
        /** @param {string} className */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @param {!EventTarget} target */

      }, {
        key: "containsEventTarget",
        value: function containsEventTarget(target) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerDocumentInteractionHandler",
        value: function registerDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterDocumentInteractionHandler",
        value: function deregisterDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /**
         * @param {string} varName
         * @param {?number|string} value
         */

      }, {
        key: "updateCssVariable",
        value: function updateCssVariable(varName, value) {}
        /** @return {!ClientRect} */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}
        /** @return {{x: number, y: number}} */

      }, {
        key: "getWindowPageOffset",
        value: function getWindowPageOffset() {}
      }]);

      return MDCRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var cssClasses$3 = {
      // Ripple is a special case where the "root" component is really a "mixin" of sorts,
      // given that it's an 'upgrade' to an existing component. That being said it is the root
      // CSS class that all other CSS classes derive from.
      ROOT: 'mdc-ripple-upgraded',
      UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
      BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
      FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
      FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
    };
    var strings$3 = {
      VAR_LEFT: '--mdc-ripple-left',
      VAR_TOP: '--mdc-ripple-top',
      VAR_FG_SIZE: '--mdc-ripple-fg-size',
      VAR_FG_SCALE: '--mdc-ripple-fg-scale',
      VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
      VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
    };
    var numbers$3 = {
      PADDING: 10,
      INITIAL_ORIGIN_SCALE: 0.6,
      DEACTIVATION_TIMEOUT_MS: 225,
      // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
      FG_DEACTIVATION_MS: 150,
      // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
      TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

    };

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
     * @private {boolean|undefined}
     */
    var supportsCssVariables_$3;
    /**
     * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
     * @private {boolean|undefined}
     */

    var supportsPassive_$3;
    /**
     * @param {!Window} windowObj
     * @return {boolean}
     */

    function detectEdgePseudoVarBug$3(windowObj) {
      // Detect versions of Edge with buggy var() support
      // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
      var document = windowObj.document;
      var node = document.createElement('div');
      node.className = 'mdc-ripple-surface--test-edge-var-bug';
      document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
      // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
      // but Firefox is known to support CSS custom properties correctly.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

      var computedStyle = windowObj.getComputedStyle(node);
      var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
      node.remove();
      return hasPseudoVarBug;
    }
    /**
     * @param {!Window} windowObj
     * @param {boolean=} forceRefresh
     * @return {boolean|undefined}
     */


    function supportsCssVariables$3(windowObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var supportsCssVariables = supportsCssVariables_$3;

      if (typeof supportsCssVariables_$3 === 'boolean' && !forceRefresh) {
        return supportsCssVariables;
      }

      var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

      if (!supportsFunctionPresent) {
        return;
      }

      var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
      // See: README section on Safari

      var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

      if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVariables = !detectEdgePseudoVarBug$3(windowObj);
      } else {
        supportsCssVariables = false;
      }

      if (!forceRefresh) {
        supportsCssVariables_$3 = supportsCssVariables;
      }

      return supportsCssVariables;
    } //

    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|{passive: boolean}}
     */


    function applyPassive$3() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_$3 === undefined || forceRefresh) {
        var isSupported = false;

        try {
          globalObj.document.addEventListener('test', null, {
            get passive() {
              isSupported = true;
            }

          });
        } catch (e) {}

        supportsPassive_$3 = isSupported;
      }

      return supportsPassive_$3 ? {
        passive: true
      } : false;
    }
    /**
     * @param {!Object} HTMLElementPrototype
     * @return {!Array<string>}
     */


    function getMatchesProperty$3(HTMLElementPrototype) {
      return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(function (p) {
        return p in HTMLElementPrototype;
      }).pop();
    }
    /**
     * @param {!Event} ev
     * @param {{x: number, y: number}} pageOffset
     * @param {!ClientRect} clientRect
     * @return {{x: number, y: number}}
     */


    function getNormalizedEventCoords$3(ev, pageOffset, clientRect) {
      var x = pageOffset.x,
          y = pageOffset.y;
      var documentX = x + clientRect.left;
      var documentY = y + clientRect.top;
      var normalizedX;
      var normalizedY; // Determine touch point relative to the ripple container.

      if (ev.type === 'touchstart') {
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
      } else {
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
      }

      return {
        x: normalizedX,
        y: normalizedY
      };
    }

    var ACTIVATION_EVENT_TYPES$3 = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

    var POINTER_DEACTIVATION_EVENT_TYPES$3 = ['touchend', 'pointerup', 'mouseup']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

    /** @type {!Array<!EventTarget>} */

    var activatedTargets$3 = [];
    /**
     * @extends {MDCFoundation<!MDCRippleAdapter>}
     */

    var MDCRippleFoundation$3 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$4(MDCRippleFoundation, _MDCFoundation);

      _createClass$4(MDCRippleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$3;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$3;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers$3;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            browserSupportsCssVars: function browserSupportsCssVars()
            /* boolean - cached */
            {},
            isUnbounded: function isUnbounded()
            /* boolean */
            {},
            isSurfaceActive: function isSurfaceActive()
            /* boolean */
            {},
            isSurfaceDisabled: function isSurfaceDisabled()
            /* boolean */
            {},
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            containsEventTarget: function containsEventTarget()
            /* target: !EventTarget */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            updateCssVariable: function updateCssVariable()
            /* varName: string, value: string */
            {},
            computeBoundingRect: function computeBoundingRect()
            /* ClientRect */
            {},
            getWindowPageOffset: function getWindowPageOffset()
            /* {x: number, y: number} */
            {}
          };
        }
      }]);

      function MDCRippleFoundation(adapter) {
        var _this;

        _classCallCheck$4(this, MDCRippleFoundation);

        _this = _possibleConstructorReturn$4(this, _getPrototypeOf$4(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
        /** @private {number} */

        _this.layoutFrame_ = 0;
        /** @private {!ClientRect} */

        _this.frame_ =
        /** @type {!ClientRect} */
        {
          width: 0,
          height: 0
        };
        /** @private {!ActivationStateType} */

        _this.activationState_ = _this.defaultActivationState_();
        /** @private {number} */

        _this.initialSize_ = 0;
        /** @private {number} */

        _this.maxRadius_ = 0;
        /** @private {function(!Event)} */

        _this.activateHandler_ = function (e) {
          return _this.activate_(e);
        };
        /** @private {function(!Event)} */


        _this.deactivateHandler_ = function (e) {
          return _this.deactivate_(e);
        };
        /** @private {function(?Event=)} */


        _this.focusHandler_ = function () {
          return _this.handleFocus();
        };
        /** @private {function(?Event=)} */


        _this.blurHandler_ = function () {
          return _this.handleBlur();
        };
        /** @private {!Function} */


        _this.resizeHandler_ = function () {
          return _this.layout();
        };
        /** @private {{left: number, top:number}} */


        _this.unboundedCoords_ = {
          left: 0,
          top: 0
        };
        /** @private {number} */

        _this.fgScale_ = 0;
        /** @private {number} */

        _this.activationTimer_ = 0;
        /** @private {number} */

        _this.fgDeactivationRemovalTimer_ = 0;
        /** @private {boolean} */

        _this.activationAnimationHasEnded_ = false;
        /** @private {!Function} */

        _this.activationTimerCallback_ = function () {
          _this.activationAnimationHasEnded_ = true;

          _this.runDeactivationUXLogicIfReady_();
        };
        /** @private {?Event} */


        _this.previousActivationEvent_ = null;
        return _this;
      }
      /**
       * We compute this property so that we are not querying information about the client
       * until the point in time where the foundation requests it. This prevents scenarios where
       * client-side feature-detection may happen too early, such as when components are rendered on the server
       * and then initialized at mount time on the client.
       * @return {boolean}
       * @private
       */


      _createClass$4(MDCRippleFoundation, [{
        key: "isSupported_",
        value: function isSupported_() {
          return this.adapter_.browserSupportsCssVars();
        }
        /**
         * @return {!ActivationStateType}
         */

      }, {
        key: "defaultActivationState_",
        value: function defaultActivationState_() {
          return {
            isActivated: false,
            hasDeactivationUXRun: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
            activationEvent: null,
            isProgrammatic: false
          };
        }
        /** @override */

      }, {
        key: "init",
        value: function init() {
          var _this2 = this;

          if (!this.isSupported_()) {
            return;
          }

          this.registerRootHandlers_();
          var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$.ROOT,
              UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
          requestAnimationFrame(function () {
            _this2.adapter_.addClass(ROOT);

            if (_this2.adapter_.isUnbounded()) {
              _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


              _this2.layoutInternal_();
            }
          });
        }
        /** @override */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          if (!this.isSupported_()) {
            return;
          }

          if (this.activationTimer_) {
            clearTimeout(this.activationTimer_);
            this.activationTimer_ = 0;
            var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
            this.adapter_.removeClass(FG_ACTIVATION);
          }

          this.deregisterRootHandlers_();
          this.deregisterDeactivationHandlers_();
          var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$2.ROOT,
              UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
          requestAnimationFrame(function () {
            _this3.adapter_.removeClass(ROOT);

            _this3.adapter_.removeClass(UNBOUNDED);

            _this3.removeCssVars_();
          });
        }
        /** @private */

      }, {
        key: "registerRootHandlers_",
        value: function registerRootHandlers_() {
          var _this4 = this;

          ACTIVATION_EVENT_TYPES$3.forEach(function (type) {
            _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
          });
          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.registerResizeHandler(this.resizeHandler_);
          }
        }
        /**
         * @param {!Event} e
         * @private
         */

      }, {
        key: "registerDeactivationHandlers_",
        value: function registerDeactivationHandlers_(e) {
          var _this5 = this;

          if (e.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
          } else {
            POINTER_DEACTIVATION_EVENT_TYPES$3.forEach(function (type) {
              _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
            });
          }
        }
        /** @private */

      }, {
        key: "deregisterRootHandlers_",
        value: function deregisterRootHandlers_() {
          var _this6 = this;

          ACTIVATION_EVENT_TYPES$3.forEach(function (type) {
            _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
          });
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          }
        }
        /** @private */

      }, {
        key: "deregisterDeactivationHandlers_",
        value: function deregisterDeactivationHandlers_() {
          var _this7 = this;

          this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
          POINTER_DEACTIVATION_EVENT_TYPES$3.forEach(function (type) {
            _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
          });
        }
        /** @private */

      }, {
        key: "removeCssVars_",
        value: function removeCssVars_() {
          var _this8 = this;

          var strings$$1 = MDCRippleFoundation.strings;
          Object.keys(strings$$1).forEach(function (k) {
            if (k.indexOf('VAR_') === 0) {
              _this8.adapter_.updateCssVariable(strings$$1[k], null);
            }
          });
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "activate_",
        value: function activate_(e) {
          var _this9 = this;

          if (this.adapter_.isSurfaceDisabled()) {
            return;
          }

          var activationState = this.activationState_;

          if (activationState.isActivated) {
            return;
          } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


          var previousActivationEvent = this.previousActivationEvent_;
          var isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;

          if (isSameInteraction) {
            return;
          }

          activationState.isActivated = true;
          activationState.isProgrammatic = e === null;
          activationState.activationEvent = e;
          activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';
          var hasActivatedChild = e && activatedTargets$3.length > 0 && activatedTargets$3.some(function (target) {
            return _this9.adapter_.containsEventTarget(target);
          });

          if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
          }

          if (e) {
            activatedTargets$3.push(
            /** @type {!EventTarget} */
            e.target);
            this.registerDeactivationHandlers_(e);
          }

          activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

          if (activationState.wasElementMadeActive) {
            this.animateActivation_();
          }

          requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets$3 = [];

            if (!activationState.wasElementMadeActive && (e.key === ' ' || e.keyCode === 32)) {
              // If space was pressed, try again within an rAF call to detect :active, because different UAs report
              // active states inconsistently when they're called within event handling code:
              // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
              // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
              // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
              // variable is set within a rAF callback for a submit button interaction (#2241).
              activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

              if (activationState.wasElementMadeActive) {
                _this9.animateActivation_();
              }
            }

            if (!activationState.wasElementMadeActive) {
              // Reset activation state immediately if element was not made active.
              _this9.activationState_ = _this9.defaultActivationState_();
            }
          });
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "checkElementMadeActive_",
        value: function checkElementMadeActive_(e) {
          return e && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
        }
        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: "activate",
        value: function activate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          this.activate_(event);
        }
        /** @private */

      }, {
        key: "animateActivation_",
        value: function animateActivation_() {
          var _this10 = this;

          var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
              VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
              VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
          var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
              FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
              FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
          var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
          this.layoutInternal_();
          var translateStart = '';
          var translateEnd = '';

          if (!this.adapter_.isUnbounded()) {
            var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
                startPoint = _this$getFgTranslatio.startPoint,
                endPoint = _this$getFgTranslatio.endPoint;

            translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
            translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
          }

          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

          clearTimeout(this.activationTimer_);
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.rmBoundedActivationClasses_();
          this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

          this.adapter_.computeBoundingRect();
          this.adapter_.addClass(FG_ACTIVATION);
          this.activationTimer_ = setTimeout(function () {
            return _this10.activationTimerCallback_();
          }, DEACTIVATION_TIMEOUT_MS);
        }
        /**
         * @private
         * @return {{startPoint: PointType, endPoint: PointType}}
         */

      }, {
        key: "getFgTranslationCoordinates_",
        value: function getFgTranslationCoordinates_() {
          var _this$activationState = this.activationState_,
              activationEvent = _this$activationState.activationEvent,
              wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
          var startPoint;

          if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords$3(
            /** @type {!Event} */
            activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
          } else {
            startPoint = {
              x: this.frame_.width / 2,
              y: this.frame_.height / 2
            };
          } // Center the element around the start point.


          startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
          };
          var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
          };
          return {
            startPoint: startPoint,
            endPoint: endPoint
          };
        }
        /** @private */

      }, {
        key: "runDeactivationUXLogicIfReady_",
        value: function runDeactivationUXLogicIfReady_() {
          var _this11 = this;

          // This method is called both when a pointing device is released, and when the activation animation ends.
          // The deactivation animation should only run after both of those occur.
          var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
          var _this$activationState2 = this.activationState_,
              hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
              isActivated = _this$activationState2.isActivated;
          var activationHasEnded = hasDeactivationUXRun || !isActivated;

          if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
              _this11.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers$3.FG_DEACTIVATION_MS);
          }
        }
        /** @private */

      }, {
        key: "rmBoundedActivationClasses_",
        value: function rmBoundedActivationClasses_() {
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
          this.adapter_.removeClass(FG_ACTIVATION);
          this.activationAnimationHasEnded_ = false;
          this.adapter_.computeBoundingRect();
        }
      }, {
        key: "resetActivationState_",
        value: function resetActivationState_() {
          var _this12 = this;

          this.previousActivationEvent_ = this.activationState_.activationEvent;
          this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
          // Store the previous event until it's safe to assume that subsequent events are for new interactions.

          setTimeout(function () {
            return _this12.previousActivationEvent_ = null;
          }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "deactivate_",
        value: function deactivate_(e) {
          var _this13 = this;

          var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

          if (!activationState.isActivated) {
            return;
          }

          var state =
          /** @type {!ActivationStateType} */
          Object.assign({}, activationState);

          if (activationState.isProgrammatic) {
            var evtObject = null;
            requestAnimationFrame(function () {
              return _this13.animateDeactivation_(evtObject, state);
            });
            this.resetActivationState_();
          } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
              _this13.activationState_.hasDeactivationUXRun = true;

              _this13.animateDeactivation_(e, state);

              _this13.resetActivationState_();
            });
          }
        }
        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          this.deactivate_(event);
        }
        /**
         * @param {Event} e
         * @param {!ActivationStateType} options
         * @private
         */

      }, {
        key: "animateDeactivation_",
        value: function animateDeactivation_(e, _ref) {
          var wasActivatedByPointer = _ref.wasActivatedByPointer,
              wasElementMadeActive = _ref.wasElementMadeActive;

          if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this14 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }

          this.layoutFrame_ = requestAnimationFrame(function () {
            _this14.layoutInternal_();

            _this14.layoutFrame_ = 0;
          });
        }
        /** @private */

      }, {
        key: "layoutInternal_",
        value: function layoutInternal_() {
          var _this15 = this;

          this.frame_ = this.adapter_.computeBoundingRect();
          var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
          // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
          // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
          // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
          // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
          // `overflow: hidden`.

          var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
          };

          this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

          this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;
          this.fgScale_ = this.maxRadius_ / this.initialSize_;
          this.updateLayoutCssVars_();
        }
        /** @private */

      }, {
        key: "updateLayoutCssVars_",
        value: function updateLayoutCssVars_() {
          var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
              VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
              VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
              VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
              VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
          this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
          this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

          if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
              left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
              top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };
            this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
            this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
          }
        }
        /** @param {boolean} unbounded */

      }, {
        key: "setUnbounded",
        value: function setUnbounded(unbounded) {
          var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

          if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
          } else {
            this.adapter_.removeClass(UNBOUNDED);
          }
        }
      }, {
        key: "handleFocus",
        value: function handleFocus() {
          var _this16 = this;

          requestAnimationFrame(function () {
            return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }, {
        key: "handleBlur",
        value: function handleBlur() {
          var _this17 = this;

          requestAnimationFrame(function () {
            return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }]);

      return MDCRippleFoundation;
    }(MDCFoundation$3);

    /**
     * @extends MDCComponent<!MDCRippleFoundation>
     */

    var MDCRipple$3 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$4(MDCRipple, _MDCComponent);

      /** @param {...?} args */
      function MDCRipple() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$4(this, MDCRipple);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$4(this, (_getPrototypeOf2 = _getPrototypeOf$4(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {boolean} */

        _this.disabled = false;
        /** @private {boolean} */

        _this.unbounded_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @param {{isUnbounded: (boolean|undefined)}=} options
       * @return {!MDCRipple}
       */


      _createClass$4(MDCRipple, [{
        key: "setUnbounded_",

        /**
         * Closure Compiler throws an access control error when directly accessing a
         * protected or private property inside a getter/setter, like unbounded above.
         * By accessing the protected property inside a method, we solve that problem.
         * That's why this function exists.
         * @private
         */
        value: function setUnbounded_() {
          this.foundation_.setUnbounded(this.unbounded_);
        }
      }, {
        key: "activate",
        value: function activate() {
          this.foundation_.activate();
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
        /**
         * @return {!MDCRippleFoundation}
         * @override
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          return new MDCRippleFoundation$3(MDCRipple.createAdapter(this));
        }
        /** @override */

      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
        }
      }, {
        key: "unbounded",

        /** @return {boolean} */
        get: function get() {
          return this.unbounded_;
        }
        /** @param {boolean} unbounded */
        ,
        set: function set(unbounded) {
          this.unbounded_ = Boolean(unbounded);
          this.setUnbounded_();
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref$isUnbounded = _ref.isUnbounded,
              isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

          var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

          if (isUnbounded !== undefined) {
            ripple.unbounded =
            /** @type {boolean} */
            isUnbounded;
          }

          return ripple;
        }
        /**
         * @param {!RippleCapableSurface} instance
         * @return {!MDCRippleAdapter}
         */

      }, {
        key: "createAdapter",
        value: function createAdapter(instance) {
          var MATCHES = getMatchesProperty$3(HTMLElement.prototype);
          return {
            browserSupportsCssVars: function browserSupportsCssVars() {
              return supportsCssVariables$3(window);
            },
            isUnbounded: function isUnbounded() {
              return instance.unbounded;
            },
            isSurfaceActive: function isSurfaceActive() {
              return instance.root_[MATCHES](':active');
            },
            isSurfaceDisabled: function isSurfaceDisabled() {
              return instance.disabled;
            },
            addClass: function addClass(className) {
              return instance.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return instance.root_.classList.remove(className);
            },
            containsEventTarget: function containsEventTarget(target) {
              return instance.root_.contains(target);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return instance.root_.addEventListener(evtType, handler, applyPassive$3());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return instance.root_.removeEventListener(evtType, handler, applyPassive$3());
            },
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.addEventListener(evtType, handler, applyPassive$3());
            },
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.removeEventListener(evtType, handler, applyPassive$3());
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return instance.root_.style.setProperty(varName, value);
            },
            computeBoundingRect: function computeBoundingRect() {
              return instance.root_.getBoundingClientRect();
            },
            getWindowPageOffset: function getWindowPageOffset() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            }
          };
        }
      }]);

      return MDCRipple;
    }(MDCComponent$3);

    /**
     * @record
     */

    var MDCSelectionControl$1 =
    /*#__PURE__*/
    function () {
      function MDCSelectionControl() {
        _classCallCheck$4(this, MDCSelectionControl);
      }

      _createClass$4(MDCSelectionControl, [{
        key: "ripple",

        /** @return {?MDCRipple} */
        get: function get() {}
      }]);

      return MDCSelectionControl;
    }();

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Checkbox. Provides an interface for managing
     * - classes
     * - dom
     * - event handlers
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */

    var MDCCheckboxAdapter =
    /*#__PURE__*/
    function () {
      function MDCCheckboxAdapter() {
        _classCallCheck$4(this, MDCCheckboxAdapter);
      }

      _createClass$4(MDCCheckboxAdapter, [{
        key: "addClass",

        /** @param {string} className */
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Sets an attribute with a given value on the input element.
         * @param {string} attr
         * @param {string} value
         */

      }, {
        key: "setNativeControlAttr",
        value: function setNativeControlAttr(attr, value) {}
        /**
         * Removes an attribute from the input element.
         * @param {string} attr
         */

      }, {
        key: "removeNativeControlAttr",
        value: function removeNativeControlAttr(attr) {}
        /** @param {!EventListener} handler */

      }, {
        key: "registerAnimationEndHandler",
        value: function registerAnimationEndHandler(handler) {}
        /** @param {!EventListener} handler */

      }, {
        key: "deregisterAnimationEndHandler",
        value: function deregisterAnimationEndHandler(handler) {}
        /** @param {!EventListener} handler */

      }, {
        key: "registerChangeHandler",
        value: function registerChangeHandler(handler) {}
        /** @param {!EventListener} handler */

      }, {
        key: "deregisterChangeHandler",
        value: function deregisterChangeHandler(handler) {}
        /** @return {!MDCSelectionControlState} */

      }, {
        key: "getNativeControl",
        value: function getNativeControl() {}
      }, {
        key: "forceLayout",
        value: function forceLayout() {}
        /** @return {boolean} */

      }, {
        key: "isAttachedToDOM",
        value: function isAttachedToDOM() {}
      }]);

      return MDCCheckboxAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @const {string} */
    var ROOT = 'mdc-checkbox';
    /** @enum {string} */

    var cssClasses$1$3 = {
      UPGRADED: 'mdc-checkbox--upgraded',
      CHECKED: 'mdc-checkbox--checked',
      INDETERMINATE: 'mdc-checkbox--indeterminate',
      DISABLED: 'mdc-checkbox--disabled',
      ANIM_UNCHECKED_CHECKED: 'mdc-checkbox--anim-unchecked-checked',
      ANIM_UNCHECKED_INDETERMINATE: 'mdc-checkbox--anim-unchecked-indeterminate',
      ANIM_CHECKED_UNCHECKED: 'mdc-checkbox--anim-checked-unchecked',
      ANIM_CHECKED_INDETERMINATE: 'mdc-checkbox--anim-checked-indeterminate',
      ANIM_INDETERMINATE_CHECKED: 'mdc-checkbox--anim-indeterminate-checked',
      ANIM_INDETERMINATE_UNCHECKED: 'mdc-checkbox--anim-indeterminate-unchecked'
    };
    /** @enum {string} */

    var strings$1$3 = {
      NATIVE_CONTROL_SELECTOR: ".".concat(ROOT, "__native-control"),
      TRANSITION_STATE_INIT: 'init',
      TRANSITION_STATE_CHECKED: 'checked',
      TRANSITION_STATE_UNCHECKED: 'unchecked',
      TRANSITION_STATE_INDETERMINATE: 'indeterminate',
      ARIA_CHECKED_ATTR: 'aria-checked',
      ARIA_CHECKED_INDETERMINATE_VALUE: 'mixed'
    };
    /** @enum {number} */

    var numbers$1$2 = {
      ANIM_END_LATCH_MS: 250
    };

    /** @const {!Array<string>} */

    var CB_PROTO_PROPS = ['checked', 'indeterminate'];
    /**
     * @extends {MDCFoundation<!MDCCheckboxAdapter>}
     */

    var MDCCheckboxFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$4(MDCCheckboxFoundation, _MDCFoundation);

      _createClass$4(MDCCheckboxFoundation, null, [{
        key: "cssClasses",

        /** @return enum {cssClasses} */
        get: function get() {
          return cssClasses$1$3;
        }
        /** @return enum {strings} */

      }, {
        key: "strings",
        get: function get() {
          return strings$1$3;
        }
        /** @return enum {numbers} */

      }, {
        key: "numbers",
        get: function get() {
          return numbers$1$2;
        }
        /** @return {!MDCCheckboxAdapter} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCCheckboxAdapter} */
            {
              addClass: function addClass()
              /* className: string */
              {},
              removeClass: function removeClass()
              /* className: string */
              {},
              setNativeControlAttr: function setNativeControlAttr()
              /* attr: string, value: string */
              {},
              removeNativeControlAttr: function removeNativeControlAttr()
              /* attr: string */
              {},
              registerAnimationEndHandler: function registerAnimationEndHandler()
              /* handler: EventListener */
              {},
              deregisterAnimationEndHandler: function deregisterAnimationEndHandler()
              /* handler: EventListener */
              {},
              registerChangeHandler: function registerChangeHandler()
              /* handler: EventListener */
              {},
              deregisterChangeHandler: function deregisterChangeHandler()
              /* handler: EventListener */
              {},
              getNativeControl: function getNativeControl()
              /* !MDCSelectionControlState */
              {},
              forceLayout: function forceLayout() {},
              isAttachedToDOM: function isAttachedToDOM()
              /* boolean */
              {}
            }
          );
        }
      }]);

      function MDCCheckboxFoundation(adapter) {
        var _this;

        _classCallCheck$4(this, MDCCheckboxFoundation);

        _this = _possibleConstructorReturn$4(this, _getPrototypeOf$4(MDCCheckboxFoundation).call(this, Object.assign(MDCCheckboxFoundation.defaultAdapter, adapter)));
        /** @private {string} */

        _this.currentCheckState_ = strings$1$3.TRANSITION_STATE_INIT;
        /** @private {string} */

        _this.currentAnimationClass_ = '';
        /** @private {number} */

        _this.animEndLatchTimer_ = 0;

        _this.animEndHandler_ =
        /** @private {!EventListener} */
        function () {
          return _this.handleAnimationEnd();
        };

        _this.changeHandler_ =
        /** @private {!EventListener} */
        function () {
          return _this.handleChange();
        };

        return _this;
      }
      /** @override */


      _createClass$4(MDCCheckboxFoundation, [{
        key: "init",
        value: function init() {
          this.currentCheckState_ = this.determineCheckState_(this.getNativeControl_());
          this.updateAriaChecked_();
          this.adapter_.addClass(cssClasses$1$3.UPGRADED);
          this.adapter_.registerChangeHandler(this.changeHandler_);
          this.installPropertyChangeHooks_();
        }
        /** @override */

      }, {
        key: "destroy",
        value: function destroy() {
          this.adapter_.deregisterChangeHandler(this.changeHandler_);
          this.uninstallPropertyChangeHooks_();
        }
        /** @return {boolean} */

      }, {
        key: "isChecked",
        value: function isChecked() {
          return this.getNativeControl_().checked;
        }
        /** @param {boolean} checked */

      }, {
        key: "setChecked",
        value: function setChecked(checked) {
          this.getNativeControl_().checked = checked;
        }
        /** @return {boolean} */

      }, {
        key: "isIndeterminate",
        value: function isIndeterminate() {
          return this.getNativeControl_().indeterminate;
        }
        /** @param {boolean} indeterminate */

      }, {
        key: "setIndeterminate",
        value: function setIndeterminate(indeterminate) {
          this.getNativeControl_().indeterminate = indeterminate;
        }
        /** @return {boolean} */

      }, {
        key: "isDisabled",
        value: function isDisabled() {
          return this.getNativeControl_().disabled;
        }
        /** @param {boolean} disabled */

      }, {
        key: "setDisabled",
        value: function setDisabled(disabled) {
          this.getNativeControl_().disabled = disabled;

          if (disabled) {
            this.adapter_.addClass(cssClasses$1$3.DISABLED);
          } else {
            this.adapter_.removeClass(cssClasses$1$3.DISABLED);
          }
        }
        /** @return {?string} */

      }, {
        key: "getValue",
        value: function getValue() {
          return this.getNativeControl_().value;
        }
        /** @param {?string} value */

      }, {
        key: "setValue",
        value: function setValue(value) {
          this.getNativeControl_().value = value;
        }
        /**
         * Handles the animationend event for the checkbox
         */

      }, {
        key: "handleAnimationEnd",
        value: function handleAnimationEnd() {
          var _this2 = this;

          clearTimeout(this.animEndLatchTimer_);
          this.animEndLatchTimer_ = setTimeout(function () {
            _this2.adapter_.removeClass(_this2.currentAnimationClass_);

            _this2.adapter_.deregisterAnimationEndHandler(_this2.animEndHandler_);
          }, numbers$1$2.ANIM_END_LATCH_MS);
        }
        /**
         * Handles the change event for the checkbox
         */

      }, {
        key: "handleChange",
        value: function handleChange() {
          this.transitionCheckState_();
        }
        /** @private */

      }, {
        key: "installPropertyChangeHooks_",
        value: function installPropertyChangeHooks_() {
          var _this3 = this;

          var nativeCb = this.getNativeControl_();
          var cbProto = Object.getPrototypeOf(nativeCb);
          CB_PROTO_PROPS.forEach(function (controlState) {
            var desc = Object.getOwnPropertyDescriptor(cbProto, controlState); // We have to check for this descriptor, since some browsers (Safari) don't support its return.
            // See: https://bugs.webkit.org/show_bug.cgi?id=49739

            if (validDescriptor(desc)) {
              var nativeCbDesc =
              /** @type {!ObjectPropertyDescriptor} */
              {
                get: desc.get,
                set: function set(state) {
                  desc.set.call(nativeCb, state);

                  _this3.transitionCheckState_();
                },
                configurable: desc.configurable,
                enumerable: desc.enumerable
              };
              Object.defineProperty(nativeCb, controlState, nativeCbDesc);
            }
          });
        }
        /** @private */

      }, {
        key: "uninstallPropertyChangeHooks_",
        value: function uninstallPropertyChangeHooks_() {
          var nativeCb = this.getNativeControl_();
          var cbProto = Object.getPrototypeOf(nativeCb);
          CB_PROTO_PROPS.forEach(function (controlState) {
            var desc =
            /** @type {!ObjectPropertyDescriptor} */
            Object.getOwnPropertyDescriptor(cbProto, controlState);

            if (validDescriptor(desc)) {
              Object.defineProperty(nativeCb, controlState, desc);
            }
          });
        }
        /** @private */

      }, {
        key: "transitionCheckState_",
        value: function transitionCheckState_() {
          var nativeCb = this.adapter_.getNativeControl();

          if (!nativeCb) {
            return;
          }

          var oldState = this.currentCheckState_;
          var newState = this.determineCheckState_(nativeCb);

          if (oldState === newState) {
            return;
          }

          this.updateAriaChecked_(); // Check to ensure that there isn't a previously existing animation class, in case for example
          // the user interacted with the checkbox before the animation was finished.

          if (this.currentAnimationClass_.length > 0) {
            clearTimeout(this.animEndLatchTimer_);
            this.adapter_.forceLayout();
            this.adapter_.removeClass(this.currentAnimationClass_);
          }

          this.currentAnimationClass_ = this.getTransitionAnimationClass_(oldState, newState);
          this.currentCheckState_ = newState; // Check for parentNode so that animations are only run when the element is attached
          // to the DOM.

          if (this.adapter_.isAttachedToDOM() && this.currentAnimationClass_.length > 0) {
            this.adapter_.addClass(this.currentAnimationClass_);
            this.adapter_.registerAnimationEndHandler(this.animEndHandler_);
          }
        }
        /**
         * @param {!MDCSelectionControlState} nativeCb
         * @return {string}
         * @private
         */

      }, {
        key: "determineCheckState_",
        value: function determineCheckState_(nativeCb) {
          var TRANSITION_STATE_INDETERMINATE = strings$1$3.TRANSITION_STATE_INDETERMINATE,
              TRANSITION_STATE_CHECKED = strings$1$3.TRANSITION_STATE_CHECKED,
              TRANSITION_STATE_UNCHECKED = strings$1$3.TRANSITION_STATE_UNCHECKED;

          if (nativeCb.indeterminate) {
            return TRANSITION_STATE_INDETERMINATE;
          }

          return nativeCb.checked ? TRANSITION_STATE_CHECKED : TRANSITION_STATE_UNCHECKED;
        }
        /**
         * @param {string} oldState
         * @param {string} newState
         * @return {string}
         */

      }, {
        key: "getTransitionAnimationClass_",
        value: function getTransitionAnimationClass_(oldState, newState) {
          var TRANSITION_STATE_INIT = strings$1$3.TRANSITION_STATE_INIT,
              TRANSITION_STATE_CHECKED = strings$1$3.TRANSITION_STATE_CHECKED,
              TRANSITION_STATE_UNCHECKED = strings$1$3.TRANSITION_STATE_UNCHECKED;
          var _MDCCheckboxFoundatio = MDCCheckboxFoundation.cssClasses,
              ANIM_UNCHECKED_CHECKED = _MDCCheckboxFoundatio.ANIM_UNCHECKED_CHECKED,
              ANIM_UNCHECKED_INDETERMINATE = _MDCCheckboxFoundatio.ANIM_UNCHECKED_INDETERMINATE,
              ANIM_CHECKED_UNCHECKED = _MDCCheckboxFoundatio.ANIM_CHECKED_UNCHECKED,
              ANIM_CHECKED_INDETERMINATE = _MDCCheckboxFoundatio.ANIM_CHECKED_INDETERMINATE,
              ANIM_INDETERMINATE_CHECKED = _MDCCheckboxFoundatio.ANIM_INDETERMINATE_CHECKED,
              ANIM_INDETERMINATE_UNCHECKED = _MDCCheckboxFoundatio.ANIM_INDETERMINATE_UNCHECKED;

          switch (oldState) {
            case TRANSITION_STATE_INIT:
              if (newState === TRANSITION_STATE_UNCHECKED) {
                return '';
              }

            // fallthrough

            case TRANSITION_STATE_UNCHECKED:
              return newState === TRANSITION_STATE_CHECKED ? ANIM_UNCHECKED_CHECKED : ANIM_UNCHECKED_INDETERMINATE;

            case TRANSITION_STATE_CHECKED:
              return newState === TRANSITION_STATE_UNCHECKED ? ANIM_CHECKED_UNCHECKED : ANIM_CHECKED_INDETERMINATE;
            // TRANSITION_STATE_INDETERMINATE

            default:
              return newState === TRANSITION_STATE_CHECKED ? ANIM_INDETERMINATE_CHECKED : ANIM_INDETERMINATE_UNCHECKED;
          }
        }
      }, {
        key: "updateAriaChecked_",
        value: function updateAriaChecked_() {
          // Ensure aria-checked is set to mixed if checkbox is in indeterminate state.
          if (this.isIndeterminate()) {
            this.adapter_.setNativeControlAttr(strings$1$3.ARIA_CHECKED_ATTR, strings$1$3.ARIA_CHECKED_INDETERMINATE_VALUE);
          } else {
            this.adapter_.removeNativeControlAttr(strings$1$3.ARIA_CHECKED_ATTR);
          }
        }
        /**
         * @return {!MDCSelectionControlState}
         * @private
         */

      }, {
        key: "getNativeControl_",
        value: function getNativeControl_() {
          return this.adapter_.getNativeControl() || {
            checked: false,
            indeterminate: false,
            disabled: false,
            value: null
          };
        }
      }]);

      return MDCCheckboxFoundation;
    }(MDCFoundation$3);
    /**
     * @param {ObjectPropertyDescriptor|undefined} inputPropDesc
     * @return {boolean}
     */


    function validDescriptor(inputPropDesc) {
      return !!inputPropDesc && typeof inputPropDesc.set === 'function';
    }

    /**
     * @extends MDCComponent<!MDCCheckboxFoundation>
     * @implements {MDCSelectionControl}
     */

    var MDCCheckbox =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$4(MDCCheckbox, _MDCComponent);

      _createClass$4(MDCCheckbox, [{
        key: "nativeCb_",

        /**
         * Returns the state of the native control element, or null if the native control element is not present.
         * @return {?MDCSelectionControlState}
         * @private
         */
        get: function get$$1() {
          var NATIVE_CONTROL_SELECTOR = MDCCheckboxFoundation.strings.NATIVE_CONTROL_SELECTOR;
          var cbEl =
          /** @type {?MDCSelectionControlState} */
          this.root_.querySelector(NATIVE_CONTROL_SELECTOR);
          return cbEl;
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCCheckbox(root);
        }
      }]);

      function MDCCheckbox() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$4(this, MDCCheckbox);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$4(this, (_getPrototypeOf2 = _getPrototypeOf$4(MDCCheckbox)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {!MDCRipple} */

        _this.ripple_ = _this.initRipple_();
        return _this;
      }
      /**
       * @return {!MDCRipple}
       * @private
       */


      _createClass$4(MDCCheckbox, [{
        key: "initRipple_",
        value: function initRipple_() {
          var _this2 = this;

          var MATCHES = getMatchesProperty$3(HTMLElement.prototype);
          var adapter = Object.assign(MDCRipple$3.createAdapter(this), {
            isUnbounded: function isUnbounded() {
              return true;
            },
            isSurfaceActive: function isSurfaceActive() {
              return _this2.nativeCb_[MATCHES](':active');
            },
            registerInteractionHandler: function registerInteractionHandler(type, handler) {
              return _this2.nativeCb_.addEventListener(type, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
              return _this2.nativeCb_.removeEventListener(type, handler);
            }
          });
          var foundation = new MDCRippleFoundation$3(adapter);
          return new MDCRipple$3(this.root_, foundation);
        }
        /** @return {!MDCCheckboxFoundation} */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this3 = this;

          return new MDCCheckboxFoundation({
            addClass: function addClass(className) {
              return _this3.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this3.root_.classList.remove(className);
            },
            setNativeControlAttr: function setNativeControlAttr(attr, value) {
              return _this3.nativeCb_.setAttribute(attr, value);
            },
            removeNativeControlAttr: function removeNativeControlAttr(attr) {
              return _this3.nativeCb_.removeAttribute(attr);
            },
            registerAnimationEndHandler: function registerAnimationEndHandler(handler) {
              return _this3.root_.addEventListener(getCorrectEventName(window, 'animationend'), handler);
            },
            deregisterAnimationEndHandler: function deregisterAnimationEndHandler(handler) {
              return _this3.root_.removeEventListener(getCorrectEventName(window, 'animationend'), handler);
            },
            registerChangeHandler: function registerChangeHandler(handler) {
              return _this3.nativeCb_.addEventListener('change', handler);
            },
            deregisterChangeHandler: function deregisterChangeHandler(handler) {
              return _this3.nativeCb_.removeEventListener('change', handler);
            },
            getNativeControl: function getNativeControl() {
              return _this3.nativeCb_;
            },
            forceLayout: function forceLayout() {
              return _this3.root_.offsetWidth;
            },
            isAttachedToDOM: function isAttachedToDOM() {
              return Boolean(_this3.root_.parentNode);
            }
          });
        }
        /** @return {!MDCRipple} */

      }, {
        key: "destroy",
        value: function destroy() {
          this.ripple_.destroy();

          _get$2(_getPrototypeOf$4(MDCCheckbox.prototype), "destroy", this).call(this);
        }
      }, {
        key: "ripple",
        get: function get$$1() {
          return this.ripple_;
        }
        /** @return {boolean} */

      }, {
        key: "checked",
        get: function get$$1() {
          return this.foundation_.isChecked();
        }
        /** @param {boolean} checked */
        ,
        set: function set(checked) {
          this.foundation_.setChecked(checked);
        }
        /** @return {boolean} */

      }, {
        key: "indeterminate",
        get: function get$$1() {
          return this.foundation_.isIndeterminate();
        }
        /** @param {boolean} indeterminate */
        ,
        set: function set(indeterminate) {
          this.foundation_.setIndeterminate(indeterminate);
        }
        /** @return {boolean} */

      }, {
        key: "disabled",
        get: function get$$1() {
          return this.foundation_.isDisabled();
        }
        /** @param {boolean} disabled */
        ,
        set: function set(disabled) {
          this.foundation_.setDisabled(disabled);
        }
        /** @return {?string} */

      }, {
        key: "value",
        get: function get$$1() {
          return this.foundation_.getValue();
        }
        /** @param {?string} value */
        ,
        set: function set(value) {
          this.foundation_.setValue(value);
        }
      }]);

      return MDCCheckbox;
    }(MDCComponent$3);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ nextUniqueId = 0;
    /**
     * Change event object emitted by MdcCheckbox.
     */
    var   /**
     * Change event object emitted by MdcCheckbox.
     */
    MdcCheckboxChange = /** @class */ (function () {
        function MdcCheckboxChange(source, checked) {
            this.source = source;
            this.checked = checked;
        }
        return MdcCheckboxChange;
    }());
    var /** @type {?} */ MDC_CHECKBOX_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return MdcCheckbox; }),
        multi: true
    };
    var MdcCheckbox = /** @class */ (function () {
        function MdcCheckbox(_changeDetectorRef, _renderer, elementRef, ripple, _registry) {
            var _this = this;
            this._changeDetectorRef = _changeDetectorRef;
            this._renderer = _renderer;
            this.elementRef = elementRef;
            this.ripple = ripple;
            this._registry = _registry;
            this.componentInstance = MdcCheckbox;
            this._mdcAdapter = {
                addClass: function (className) { return _this._renderer.addClass(_this._getHostElement(), className); },
                removeClass: function (className) { return _this._renderer.removeClass(_this._getHostElement(), className); },
                setNativeControlAttr: function (attr, value) { return _this._renderer.setAttribute(_this.inputEl.nativeElement, attr, value); },
                removeNativeControlAttr: function (attr) { return _this._renderer.removeAttribute(_this.inputEl.nativeElement, attr); },
                registerAnimationEndHandler: function (handler) {
                    if (isBrowser()) {
                        _this._registry.listen(getCorrectEventName(window, 'animationend'), handler, _this._getHostElement());
                    }
                },
                deregisterAnimationEndHandler: function (handler) {
                    if (isBrowser()) {
                        _this._registry.unlisten(getCorrectEventName(window, 'animationend'), handler);
                    }
                },
                registerChangeHandler: function (handler) { return _this._registry.listen('change', handler, _this.inputEl.nativeElement); },
                deregisterChangeHandler: function (handler) { return _this._registry.unlisten('change', handler); },
                getNativeControl: function () { return _this.inputEl.nativeElement; },
                forceLayout: function () { return _this._getHostElement().offsetWidth; },
                isAttachedToDOM: function () { return !!_this.inputEl; }
            };
            this._foundation = new MDCCheckboxFoundation(this._mdcAdapter);
            this._uniqueId = "mdc-checkbox-" + ++nextUniqueId;
            this.id = this._uniqueId;
            this.name = null;
            this._indeterminateToChecked = true;
            this.tabIndex = 0;
            this.ariaLabel = '';
            this.ariaLabelledby = null;
            this.change = new core.EventEmitter();
            this.indeterminateChange = new core.EventEmitter();
            this.isHostClass = true;
            /**
             * View -> model callback called when value changes
             */
            this._onChange = function () { };
            /**
             * View -> model callback called when component has been touched
             */
            this._onTouched = function () { };
        }
        Object.defineProperty(MdcCheckbox.prototype, "inputId", {
            get: /**
             * @return {?}
             */
            function () { return (this.id || this._uniqueId) + "-input"; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcCheckbox.prototype, "checked", {
            get: /**
             * @return {?}
             */
            function () { return this._checked; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setChecked(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcCheckbox.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setDisabled(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcCheckbox.prototype, "indeterminate", {
            /// Alternative state of the checkbox, not user set-able state. Between
            /// [checked] and [indeterminate], only one can be true, though both can be
            /// false.
            /// `true` is INDETERMINATE and `false` is not.
            get: /**
             * @return {?}
             */
            function () { return this._indeterminate; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setIndeterminate(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcCheckbox.prototype, "indeterminateToChecked", {
            /// Determines the state to go into when [indeterminate] state is toggled.
            /// `true` will go to checked and `false` will go to unchecked.
            get: /**
             * @return {?}
             */
            function () { return this._indeterminateToChecked; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setIndeterminateToChecked(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcCheckbox.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this._foundation.init();
            this.ripple.attachTo(this._getHostElement(), true, this.inputEl.nativeElement);
        };
        /**
         * @return {?}
         */
        MdcCheckbox.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.ripple.destroy();
            this._foundation.destroy();
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MdcCheckbox.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value == null) {
                return;
            }
            this.checked = !!value;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcCheckbox.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcCheckbox.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onTouched = fn;
        };
        /** Focuses the checkbox. */
        /**
         * Focuses the checkbox.
         * @return {?}
         */
        MdcCheckbox.prototype.focus = /**
         * Focuses the checkbox.
         * @return {?}
         */
        function () {
            this.inputEl.nativeElement.focus();
        };
        // Toggles checkbox via user action. When it is indeterminate, toggle
        /// can go to checked or unchecked, depending on state
        /// [indeterminateToChecked].
        /**
         * @return {?}
         */
        MdcCheckbox.prototype.toggle = /**
         * @return {?}
         */
        function () {
            if (this.disabled) {
                return;
            }
            if (this.indeterminate) {
                this.indeterminate = false;
                this.checked = !this.indeterminateToChecked ? false : true;
            }
            else {
                this.checked = !this.checked;
            }
            this._foundation.setChecked(this.checked);
            this._onChange(this.checked);
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcCheckbox.prototype.onChange = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            evt.stopPropagation();
        };
        /**
           * Event handler for checkbox input element.
           * Toggles checked state if element is not disabled.
           * Do not toggle on (change) event since IE doesn't fire change event when
           * indeterminate checkbox is clicked.
           */
        /**
         * Event handler for checkbox input element.
         * Toggles checked state if element is not disabled.
         * Do not toggle on (change) event since IE doesn't fire change event when
         * indeterminate checkbox is clicked.
         * @param {?} evt
         * @return {?}
         */
        MdcCheckbox.prototype._onInputClick = /**
         * Event handler for checkbox input element.
         * Toggles checked state if element is not disabled.
         * Do not toggle on (change) event since IE doesn't fire change event when
         * indeterminate checkbox is clicked.
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            evt.stopPropagation();
            if (this.disabled) {
                return;
            }
            this.toggle();
            this.change.emit(new MdcCheckboxChange(this, this.checked));
        };
        /**
         * @param {?} indeterminate
         * @return {?}
         */
        MdcCheckbox.prototype.setIndeterminate = /**
         * @param {?} indeterminate
         * @return {?}
         */
        function (indeterminate) {
            if (this.disabled) {
                return;
            }
            var /** @type {?} */ previousValue = this.indeterminate;
            this._indeterminate = indeterminate;
            this._foundation.setIndeterminate(indeterminate);
            this.indeterminateChange.emit({ source: this, indeterminate: indeterminate });
            if (!indeterminate && !this.indeterminateToChecked) {
                this._checked = false;
            }
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} indeterminateToChecked
         * @return {?}
         */
        MdcCheckbox.prototype.setIndeterminateToChecked = /**
         * @param {?} indeterminateToChecked
         * @return {?}
         */
        function (indeterminateToChecked) {
            this._indeterminateToChecked = indeterminateToChecked;
            this._changeDetectorRef.markForCheck();
        };
        /** Sets the checkbox disabled state */
        /**
         * Sets the checkbox disabled state
         * @param {?} disabled
         * @return {?}
         */
        MdcCheckbox.prototype.setDisabled = /**
         * Sets the checkbox disabled state
         * @param {?} disabled
         * @return {?}
         */
        function (disabled) {
            this.setDisabledState(disabled);
        };
        /**
         * @return {?}
         */
        MdcCheckbox.prototype.isChecked = /**
         * @return {?}
         */
        function () {
            return this._foundation.isChecked();
        };
        /**
         * @return {?}
         */
        MdcCheckbox.prototype.isDisabled = /**
         * @return {?}
         */
        function () {
            return this._foundation.isDisabled();
        };
        /**
         * @return {?}
         */
        MdcCheckbox.prototype.getValue = /**
         * @return {?}
         */
        function () {
            return this._foundation.getValue();
        };
        /**
         * @param {?} checked
         * @return {?}
         */
        MdcCheckbox.prototype.setChecked = /**
         * @param {?} checked
         * @return {?}
         */
        function (checked) {
            this._checked = checked;
            this._foundation.setValue(checked);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} disabled
         * @return {?}
         */
        MdcCheckbox.prototype.setDisabledState = /**
         * @param {?} disabled
         * @return {?}
         */
        function (disabled) {
            this._disabled = disabled;
            this._foundation.setDisabled(disabled);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        MdcCheckbox.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcCheckbox.decorators = [
            { type: core.Component, args: [{selector: 'mdc-checkbox',
                        exportAs: 'mdcCheckbox',
                        host: {
                            '[id]': 'id',
                        },
                        template: "\n  <input type=\"checkbox\"\n    #input\n    class=\"mdc-checkbox__native-control\"\n    [id]=\"inputId\"\n    [name]=\"name\"\n    [tabIndex]=\"tabIndex\"\n    [attr.aria-label]=\"ariaLabel\"\n    [attr.aria-labelledby]=\"ariaLabelledby\"\n    [disabled]=\"disabled\"\n    [checked]=\"checked\"\n    [attr.value]=\"checked\"\n    [indeterminate]=\"indeterminate\"\n    (change)=\"onChange($event)\"\n    (click)=\"_onInputClick($event)\"/>\n  <div class=\"mdc-checkbox__background\">\n    <svg class=\"mdc-checkbox__checkmark\"\n      viewBox=\"0 0 24 24\">\n      <path class=\"mdc-checkbox__checkmark-path\"\n            fill=\"none\"\n            stroke=\"white\"\n            d=\"M1.73,12.91 8.1,19.28 22.79,4.59\"></path>\n    </svg>\n    <div class=\"mdc-checkbox__mixedmark\"></div>\n  </div>\n  ",
                        providers: [
                            MDC_CHECKBOX_CONTROL_VALUE_ACCESSOR,
                            MdcRipple,
                            EventRegistry,
                            [{ provide: MdcFormFieldControl, useExisting: MdcCheckbox }]
                        ],
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcCheckbox.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.Renderer2 },
            { type: core.ElementRef },
            { type: MdcRipple },
            { type: EventRegistry }
        ]; };
        MdcCheckbox.propDecorators = {
            id: [{ type: core.Input }],
            name: [{ type: core.Input }],
            checked: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            indeterminate: [{ type: core.Input }],
            indeterminateToChecked: [{ type: core.Input }],
            tabIndex: [{ type: core.Input }],
            ariaLabel: [{ type: core.Input, args: ['aria-label',] }],
            ariaLabelledby: [{ type: core.Input, args: ['aria-labelledby',] }],
            change: [{ type: core.Output }],
            indeterminateChange: [{ type: core.Output }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-checkbox',] }],
            inputEl: [{ type: core.ViewChild, args: ['input',] }]
        };
        return MdcCheckbox;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcCheckboxModule = /** @class */ (function () {
        function MdcCheckboxModule() {
        }
        MdcCheckboxModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [MdcCheckbox],
                        declarations: [MdcCheckbox]
                    },] },
        ];
        return MdcCheckboxModule;
    }());

    function _classCallCheck$5(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$5(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$5(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$5(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$5(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$5(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$5(subClass, superClass);
    }

    function _getPrototypeOf$5(o) {
      _getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$5(o);
    }

    function _setPrototypeOf$5(o, p) {
      _setPrototypeOf$5 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$5(o, p);
    }

    function _assertThisInitialized$5(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$5(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$5(self);
    }

    function _superPropBase$3(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$5(object);
        if (object === null) break;
      }

      return object;
    }

    function _get$3(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$3 = Reflect.get;
      } else {
        _get$3 = function _get(target, property, receiver) {
          var base = _superPropBase$3(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get$3(target, property, receiver || target);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @template A
     */
    var MDCFoundation$4 =
    /*#__PURE__*/
    function () {
      _createClass$5(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$5(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$5(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$4 =
    /*#__PURE__*/
    function () {
      _createClass$5(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$4());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$5(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$5(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Ripple. Provides an interface for managing
     * - classes
     * - dom
     * - CSS variables
     * - position
     * - dimensions
     * - scroll position
     * - event handlers
     * - unbounded, active and disabled states
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCRippleAdapter$4 =
    /*#__PURE__*/
    function () {
      function MDCRippleAdapter() {
        _classCallCheck$5(this, MDCRippleAdapter);
      }

      _createClass$5(MDCRippleAdapter, [{
        key: "browserSupportsCssVars",

        /** @return {boolean} */
        value: function browserSupportsCssVars() {}
        /** @return {boolean} */

      }, {
        key: "isUnbounded",
        value: function isUnbounded() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceActive",
        value: function isSurfaceActive() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceDisabled",
        value: function isSurfaceDisabled() {}
        /** @param {string} className */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @param {!EventTarget} target */

      }, {
        key: "containsEventTarget",
        value: function containsEventTarget(target) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerDocumentInteractionHandler",
        value: function registerDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterDocumentInteractionHandler",
        value: function deregisterDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /**
         * @param {string} varName
         * @param {?number|string} value
         */

      }, {
        key: "updateCssVariable",
        value: function updateCssVariable(varName, value) {}
        /** @return {!ClientRect} */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}
        /** @return {{x: number, y: number}} */

      }, {
        key: "getWindowPageOffset",
        value: function getWindowPageOffset() {}
      }]);

      return MDCRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var cssClasses$4 = {
      // Ripple is a special case where the "root" component is really a "mixin" of sorts,
      // given that it's an 'upgrade' to an existing component. That being said it is the root
      // CSS class that all other CSS classes derive from.
      ROOT: 'mdc-ripple-upgraded',
      UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
      BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
      FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
      FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
    };
    var strings$4 = {
      VAR_LEFT: '--mdc-ripple-left',
      VAR_TOP: '--mdc-ripple-top',
      VAR_FG_SIZE: '--mdc-ripple-fg-size',
      VAR_FG_SCALE: '--mdc-ripple-fg-scale',
      VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
      VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
    };
    var numbers$4 = {
      PADDING: 10,
      INITIAL_ORIGIN_SCALE: 0.6,
      DEACTIVATION_TIMEOUT_MS: 225,
      // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
      FG_DEACTIVATION_MS: 150,
      // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
      TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

    };

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
     * @private {boolean|undefined}
     */
    var supportsCssVariables_$4;
    /**
     * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
     * @private {boolean|undefined}
     */

    var supportsPassive_$4;
    /**
     * @param {!Window} windowObj
     * @return {boolean}
     */

    function detectEdgePseudoVarBug$4(windowObj) {
      // Detect versions of Edge with buggy var() support
      // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
      var document = windowObj.document;
      var node = document.createElement('div');
      node.className = 'mdc-ripple-surface--test-edge-var-bug';
      document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
      // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
      // but Firefox is known to support CSS custom properties correctly.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

      var computedStyle = windowObj.getComputedStyle(node);
      var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
      node.remove();
      return hasPseudoVarBug;
    }
    /**
     * @param {!Window} windowObj
     * @param {boolean=} forceRefresh
     * @return {boolean|undefined}
     */


    function supportsCssVariables$4(windowObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var supportsCssVariables = supportsCssVariables_$4;

      if (typeof supportsCssVariables_$4 === 'boolean' && !forceRefresh) {
        return supportsCssVariables;
      }

      var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

      if (!supportsFunctionPresent) {
        return;
      }

      var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
      // See: README section on Safari

      var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

      if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVariables = !detectEdgePseudoVarBug$4(windowObj);
      } else {
        supportsCssVariables = false;
      }

      if (!forceRefresh) {
        supportsCssVariables_$4 = supportsCssVariables;
      }

      return supportsCssVariables;
    } //

    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|{passive: boolean}}
     */


    function applyPassive$4() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_$4 === undefined || forceRefresh) {
        var isSupported = false;

        try {
          globalObj.document.addEventListener('test', null, {
            get passive() {
              isSupported = true;
            }

          });
        } catch (e) {}

        supportsPassive_$4 = isSupported;
      }

      return supportsPassive_$4 ? {
        passive: true
      } : false;
    }
    /**
     * @param {!Object} HTMLElementPrototype
     * @return {!Array<string>}
     */


    function getMatchesProperty$4(HTMLElementPrototype) {
      return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(function (p) {
        return p in HTMLElementPrototype;
      }).pop();
    }
    /**
     * @param {!Event} ev
     * @param {{x: number, y: number}} pageOffset
     * @param {!ClientRect} clientRect
     * @return {{x: number, y: number}}
     */


    function getNormalizedEventCoords$4(ev, pageOffset, clientRect) {
      var x = pageOffset.x,
          y = pageOffset.y;
      var documentX = x + clientRect.left;
      var documentY = y + clientRect.top;
      var normalizedX;
      var normalizedY; // Determine touch point relative to the ripple container.

      if (ev.type === 'touchstart') {
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
      } else {
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
      }

      return {
        x: normalizedX,
        y: normalizedY
      };
    }

    var ACTIVATION_EVENT_TYPES$4 = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

    var POINTER_DEACTIVATION_EVENT_TYPES$4 = ['touchend', 'pointerup', 'mouseup']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

    /** @type {!Array<!EventTarget>} */

    var activatedTargets$4 = [];
    /**
     * @extends {MDCFoundation<!MDCRippleAdapter>}
     */

    var MDCRippleFoundation$4 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$5(MDCRippleFoundation, _MDCFoundation);

      _createClass$5(MDCRippleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$4;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$4;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers$4;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            browserSupportsCssVars: function browserSupportsCssVars()
            /* boolean - cached */
            {},
            isUnbounded: function isUnbounded()
            /* boolean */
            {},
            isSurfaceActive: function isSurfaceActive()
            /* boolean */
            {},
            isSurfaceDisabled: function isSurfaceDisabled()
            /* boolean */
            {},
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            containsEventTarget: function containsEventTarget()
            /* target: !EventTarget */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            updateCssVariable: function updateCssVariable()
            /* varName: string, value: string */
            {},
            computeBoundingRect: function computeBoundingRect()
            /* ClientRect */
            {},
            getWindowPageOffset: function getWindowPageOffset()
            /* {x: number, y: number} */
            {}
          };
        }
      }]);

      function MDCRippleFoundation(adapter) {
        var _this;

        _classCallCheck$5(this, MDCRippleFoundation);

        _this = _possibleConstructorReturn$5(this, _getPrototypeOf$5(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
        /** @private {number} */

        _this.layoutFrame_ = 0;
        /** @private {!ClientRect} */

        _this.frame_ =
        /** @type {!ClientRect} */
        {
          width: 0,
          height: 0
        };
        /** @private {!ActivationStateType} */

        _this.activationState_ = _this.defaultActivationState_();
        /** @private {number} */

        _this.initialSize_ = 0;
        /** @private {number} */

        _this.maxRadius_ = 0;
        /** @private {function(!Event)} */

        _this.activateHandler_ = function (e) {
          return _this.activate_(e);
        };
        /** @private {function(!Event)} */


        _this.deactivateHandler_ = function (e) {
          return _this.deactivate_(e);
        };
        /** @private {function(?Event=)} */


        _this.focusHandler_ = function () {
          return _this.handleFocus();
        };
        /** @private {function(?Event=)} */


        _this.blurHandler_ = function () {
          return _this.handleBlur();
        };
        /** @private {!Function} */


        _this.resizeHandler_ = function () {
          return _this.layout();
        };
        /** @private {{left: number, top:number}} */


        _this.unboundedCoords_ = {
          left: 0,
          top: 0
        };
        /** @private {number} */

        _this.fgScale_ = 0;
        /** @private {number} */

        _this.activationTimer_ = 0;
        /** @private {number} */

        _this.fgDeactivationRemovalTimer_ = 0;
        /** @private {boolean} */

        _this.activationAnimationHasEnded_ = false;
        /** @private {!Function} */

        _this.activationTimerCallback_ = function () {
          _this.activationAnimationHasEnded_ = true;

          _this.runDeactivationUXLogicIfReady_();
        };
        /** @private {?Event} */


        _this.previousActivationEvent_ = null;
        return _this;
      }
      /**
       * We compute this property so that we are not querying information about the client
       * until the point in time where the foundation requests it. This prevents scenarios where
       * client-side feature-detection may happen too early, such as when components are rendered on the server
       * and then initialized at mount time on the client.
       * @return {boolean}
       * @private
       */


      _createClass$5(MDCRippleFoundation, [{
        key: "isSupported_",
        value: function isSupported_() {
          return this.adapter_.browserSupportsCssVars();
        }
        /**
         * @return {!ActivationStateType}
         */

      }, {
        key: "defaultActivationState_",
        value: function defaultActivationState_() {
          return {
            isActivated: false,
            hasDeactivationUXRun: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
            activationEvent: null,
            isProgrammatic: false
          };
        }
        /** @override */

      }, {
        key: "init",
        value: function init() {
          var _this2 = this;

          if (!this.isSupported_()) {
            return;
          }

          this.registerRootHandlers_();
          var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$.ROOT,
              UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
          requestAnimationFrame(function () {
            _this2.adapter_.addClass(ROOT);

            if (_this2.adapter_.isUnbounded()) {
              _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


              _this2.layoutInternal_();
            }
          });
        }
        /** @override */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          if (!this.isSupported_()) {
            return;
          }

          if (this.activationTimer_) {
            clearTimeout(this.activationTimer_);
            this.activationTimer_ = 0;
            var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
            this.adapter_.removeClass(FG_ACTIVATION);
          }

          this.deregisterRootHandlers_();
          this.deregisterDeactivationHandlers_();
          var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$2.ROOT,
              UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
          requestAnimationFrame(function () {
            _this3.adapter_.removeClass(ROOT);

            _this3.adapter_.removeClass(UNBOUNDED);

            _this3.removeCssVars_();
          });
        }
        /** @private */

      }, {
        key: "registerRootHandlers_",
        value: function registerRootHandlers_() {
          var _this4 = this;

          ACTIVATION_EVENT_TYPES$4.forEach(function (type) {
            _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
          });
          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.registerResizeHandler(this.resizeHandler_);
          }
        }
        /**
         * @param {!Event} e
         * @private
         */

      }, {
        key: "registerDeactivationHandlers_",
        value: function registerDeactivationHandlers_(e) {
          var _this5 = this;

          if (e.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
          } else {
            POINTER_DEACTIVATION_EVENT_TYPES$4.forEach(function (type) {
              _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
            });
          }
        }
        /** @private */

      }, {
        key: "deregisterRootHandlers_",
        value: function deregisterRootHandlers_() {
          var _this6 = this;

          ACTIVATION_EVENT_TYPES$4.forEach(function (type) {
            _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
          });
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          }
        }
        /** @private */

      }, {
        key: "deregisterDeactivationHandlers_",
        value: function deregisterDeactivationHandlers_() {
          var _this7 = this;

          this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
          POINTER_DEACTIVATION_EVENT_TYPES$4.forEach(function (type) {
            _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
          });
        }
        /** @private */

      }, {
        key: "removeCssVars_",
        value: function removeCssVars_() {
          var _this8 = this;

          var strings$$1 = MDCRippleFoundation.strings;
          Object.keys(strings$$1).forEach(function (k) {
            if (k.indexOf('VAR_') === 0) {
              _this8.adapter_.updateCssVariable(strings$$1[k], null);
            }
          });
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "activate_",
        value: function activate_(e) {
          var _this9 = this;

          if (this.adapter_.isSurfaceDisabled()) {
            return;
          }

          var activationState = this.activationState_;

          if (activationState.isActivated) {
            return;
          } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


          var previousActivationEvent = this.previousActivationEvent_;
          var isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;

          if (isSameInteraction) {
            return;
          }

          activationState.isActivated = true;
          activationState.isProgrammatic = e === null;
          activationState.activationEvent = e;
          activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';
          var hasActivatedChild = e && activatedTargets$4.length > 0 && activatedTargets$4.some(function (target) {
            return _this9.adapter_.containsEventTarget(target);
          });

          if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
          }

          if (e) {
            activatedTargets$4.push(
            /** @type {!EventTarget} */
            e.target);
            this.registerDeactivationHandlers_(e);
          }

          activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

          if (activationState.wasElementMadeActive) {
            this.animateActivation_();
          }

          requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets$4 = [];

            if (!activationState.wasElementMadeActive && (e.key === ' ' || e.keyCode === 32)) {
              // If space was pressed, try again within an rAF call to detect :active, because different UAs report
              // active states inconsistently when they're called within event handling code:
              // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
              // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
              // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
              // variable is set within a rAF callback for a submit button interaction (#2241).
              activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

              if (activationState.wasElementMadeActive) {
                _this9.animateActivation_();
              }
            }

            if (!activationState.wasElementMadeActive) {
              // Reset activation state immediately if element was not made active.
              _this9.activationState_ = _this9.defaultActivationState_();
            }
          });
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "checkElementMadeActive_",
        value: function checkElementMadeActive_(e) {
          return e && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
        }
        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: "activate",
        value: function activate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          this.activate_(event);
        }
        /** @private */

      }, {
        key: "animateActivation_",
        value: function animateActivation_() {
          var _this10 = this;

          var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
              VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
              VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
          var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
              FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
              FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
          var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
          this.layoutInternal_();
          var translateStart = '';
          var translateEnd = '';

          if (!this.adapter_.isUnbounded()) {
            var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
                startPoint = _this$getFgTranslatio.startPoint,
                endPoint = _this$getFgTranslatio.endPoint;

            translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
            translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
          }

          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

          clearTimeout(this.activationTimer_);
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.rmBoundedActivationClasses_();
          this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

          this.adapter_.computeBoundingRect();
          this.adapter_.addClass(FG_ACTIVATION);
          this.activationTimer_ = setTimeout(function () {
            return _this10.activationTimerCallback_();
          }, DEACTIVATION_TIMEOUT_MS);
        }
        /**
         * @private
         * @return {{startPoint: PointType, endPoint: PointType}}
         */

      }, {
        key: "getFgTranslationCoordinates_",
        value: function getFgTranslationCoordinates_() {
          var _this$activationState = this.activationState_,
              activationEvent = _this$activationState.activationEvent,
              wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
          var startPoint;

          if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords$4(
            /** @type {!Event} */
            activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
          } else {
            startPoint = {
              x: this.frame_.width / 2,
              y: this.frame_.height / 2
            };
          } // Center the element around the start point.


          startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
          };
          var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
          };
          return {
            startPoint: startPoint,
            endPoint: endPoint
          };
        }
        /** @private */

      }, {
        key: "runDeactivationUXLogicIfReady_",
        value: function runDeactivationUXLogicIfReady_() {
          var _this11 = this;

          // This method is called both when a pointing device is released, and when the activation animation ends.
          // The deactivation animation should only run after both of those occur.
          var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
          var _this$activationState2 = this.activationState_,
              hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
              isActivated = _this$activationState2.isActivated;
          var activationHasEnded = hasDeactivationUXRun || !isActivated;

          if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
              _this11.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers$4.FG_DEACTIVATION_MS);
          }
        }
        /** @private */

      }, {
        key: "rmBoundedActivationClasses_",
        value: function rmBoundedActivationClasses_() {
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
          this.adapter_.removeClass(FG_ACTIVATION);
          this.activationAnimationHasEnded_ = false;
          this.adapter_.computeBoundingRect();
        }
      }, {
        key: "resetActivationState_",
        value: function resetActivationState_() {
          var _this12 = this;

          this.previousActivationEvent_ = this.activationState_.activationEvent;
          this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
          // Store the previous event until it's safe to assume that subsequent events are for new interactions.

          setTimeout(function () {
            return _this12.previousActivationEvent_ = null;
          }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "deactivate_",
        value: function deactivate_(e) {
          var _this13 = this;

          var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

          if (!activationState.isActivated) {
            return;
          }

          var state =
          /** @type {!ActivationStateType} */
          Object.assign({}, activationState);

          if (activationState.isProgrammatic) {
            var evtObject = null;
            requestAnimationFrame(function () {
              return _this13.animateDeactivation_(evtObject, state);
            });
            this.resetActivationState_();
          } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
              _this13.activationState_.hasDeactivationUXRun = true;

              _this13.animateDeactivation_(e, state);

              _this13.resetActivationState_();
            });
          }
        }
        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          this.deactivate_(event);
        }
        /**
         * @param {Event} e
         * @param {!ActivationStateType} options
         * @private
         */

      }, {
        key: "animateDeactivation_",
        value: function animateDeactivation_(e, _ref) {
          var wasActivatedByPointer = _ref.wasActivatedByPointer,
              wasElementMadeActive = _ref.wasElementMadeActive;

          if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this14 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }

          this.layoutFrame_ = requestAnimationFrame(function () {
            _this14.layoutInternal_();

            _this14.layoutFrame_ = 0;
          });
        }
        /** @private */

      }, {
        key: "layoutInternal_",
        value: function layoutInternal_() {
          var _this15 = this;

          this.frame_ = this.adapter_.computeBoundingRect();
          var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
          // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
          // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
          // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
          // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
          // `overflow: hidden`.

          var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
          };

          this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

          this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;
          this.fgScale_ = this.maxRadius_ / this.initialSize_;
          this.updateLayoutCssVars_();
        }
        /** @private */

      }, {
        key: "updateLayoutCssVars_",
        value: function updateLayoutCssVars_() {
          var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
              VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
              VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
              VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
              VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
          this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
          this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

          if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
              left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
              top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };
            this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
            this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
          }
        }
        /** @param {boolean} unbounded */

      }, {
        key: "setUnbounded",
        value: function setUnbounded(unbounded) {
          var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

          if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
          } else {
            this.adapter_.removeClass(UNBOUNDED);
          }
        }
      }, {
        key: "handleFocus",
        value: function handleFocus() {
          var _this16 = this;

          requestAnimationFrame(function () {
            return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }, {
        key: "handleBlur",
        value: function handleBlur() {
          var _this17 = this;

          requestAnimationFrame(function () {
            return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }]);

      return MDCRippleFoundation;
    }(MDCFoundation$4);

    /**
     * @extends MDCComponent<!MDCRippleFoundation>
     */

    var MDCRipple$4 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$5(MDCRipple, _MDCComponent);

      /** @param {...?} args */
      function MDCRipple() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$5(this, MDCRipple);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$5(this, (_getPrototypeOf2 = _getPrototypeOf$5(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {boolean} */

        _this.disabled = false;
        /** @private {boolean} */

        _this.unbounded_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @param {{isUnbounded: (boolean|undefined)}=} options
       * @return {!MDCRipple}
       */


      _createClass$5(MDCRipple, [{
        key: "setUnbounded_",

        /**
         * Closure Compiler throws an access control error when directly accessing a
         * protected or private property inside a getter/setter, like unbounded above.
         * By accessing the protected property inside a method, we solve that problem.
         * That's why this function exists.
         * @private
         */
        value: function setUnbounded_() {
          this.foundation_.setUnbounded(this.unbounded_);
        }
      }, {
        key: "activate",
        value: function activate() {
          this.foundation_.activate();
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
        /**
         * @return {!MDCRippleFoundation}
         * @override
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          return new MDCRippleFoundation$4(MDCRipple.createAdapter(this));
        }
        /** @override */

      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
        }
      }, {
        key: "unbounded",

        /** @return {boolean} */
        get: function get() {
          return this.unbounded_;
        }
        /** @param {boolean} unbounded */
        ,
        set: function set(unbounded) {
          this.unbounded_ = Boolean(unbounded);
          this.setUnbounded_();
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref$isUnbounded = _ref.isUnbounded,
              isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

          var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

          if (isUnbounded !== undefined) {
            ripple.unbounded =
            /** @type {boolean} */
            isUnbounded;
          }

          return ripple;
        }
        /**
         * @param {!RippleCapableSurface} instance
         * @return {!MDCRippleAdapter}
         */

      }, {
        key: "createAdapter",
        value: function createAdapter(instance) {
          var MATCHES = getMatchesProperty$4(HTMLElement.prototype);
          return {
            browserSupportsCssVars: function browserSupportsCssVars() {
              return supportsCssVariables$4(window);
            },
            isUnbounded: function isUnbounded() {
              return instance.unbounded;
            },
            isSurfaceActive: function isSurfaceActive() {
              return instance.root_[MATCHES](':active');
            },
            isSurfaceDisabled: function isSurfaceDisabled() {
              return instance.disabled;
            },
            addClass: function addClass(className) {
              return instance.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return instance.root_.classList.remove(className);
            },
            containsEventTarget: function containsEventTarget(target) {
              return instance.root_.contains(target);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return instance.root_.addEventListener(evtType, handler, applyPassive$4());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return instance.root_.removeEventListener(evtType, handler, applyPassive$4());
            },
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.addEventListener(evtType, handler, applyPassive$4());
            },
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.removeEventListener(evtType, handler, applyPassive$4());
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return instance.root_.style.setProperty(varName, value);
            },
            computeBoundingRect: function computeBoundingRect() {
              return instance.root_.getBoundingClientRect();
            },
            getWindowPageOffset: function getWindowPageOffset() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            }
          };
        }
      }]);

      return MDCRipple;
    }(MDCComponent$4);

    /**
     * @license
     * Copyright 2017 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Chip.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Chip into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCChipAdapter =
    /*#__PURE__*/
    function () {
      function MDCChipAdapter() {
        _classCallCheck$5(this, MDCChipAdapter);
      }

      _createClass$5(MDCChipAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the root element.
         * @param {string} className
         */
        value: function addClass(className) {}
        /**
         * Removes a class from the root element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Returns true if the root element contains the given class.
         * @param {string} className
         * @return {boolean}
         */

      }, {
        key: "hasClass",
        value: function hasClass(className) {}
        /**
         * Adds a class to the leading icon element.
         * @param {string} className
         */

      }, {
        key: "addClassToLeadingIcon",
        value: function addClassToLeadingIcon(className) {}
        /**
         * Removes a class from the leading icon element.
         * @param {string} className
         */

      }, {
        key: "removeClassFromLeadingIcon",
        value: function removeClassFromLeadingIcon(className) {}
        /**
         * Returns true if target has className, false otherwise.
         * @param {!EventTarget} target
         * @param {string} className
         * @return {boolean}
         */

      }, {
        key: "eventTargetHasClass",
        value: function eventTargetHasClass(target, className) {}
        /**
         * Registers an event listener on the root element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerEventHandler",
        value: function registerEventHandler(evtType, handler) {}
        /**
         * Deregisters an event listener on the root element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterEventHandler",
        value: function deregisterEventHandler(evtType, handler) {}
        /**
         * Registers an event listener on the trailing icon element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerTrailingIconInteractionHandler",
        value: function registerTrailingIconInteractionHandler(evtType, handler) {}
        /**
         * Deregisters an event listener on the trailing icon element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterTrailingIconInteractionHandler",
        value: function deregisterTrailingIconInteractionHandler(evtType, handler) {}
        /**
         * Emits a custom "MDCChip:interaction" event denoting the chip has been
         * interacted with (typically on click or keydown).
         */

      }, {
        key: "notifyInteraction",
        value: function notifyInteraction() {}
        /**
         * Emits a custom "MDCChip:trailingIconInteraction" event denoting the trailing icon has been
         * interacted with (typically on click or keydown).
         */

      }, {
        key: "notifyTrailingIconInteraction",
        value: function notifyTrailingIconInteraction() {}
        /**
         * Emits a custom event "MDCChip:removal" denoting the chip will be removed.
         */

      }, {
        key: "notifyRemoval",
        value: function notifyRemoval() {}
        /**
         * Returns the computed property value of the given style property on the root element.
         * @param {string} propertyName
         * @return {string}
         */

      }, {
        key: "getComputedStyleValue",
        value: function getComputedStyleValue(propertyName) {}
        /**
         * Sets the property value of the given style property on the root element.
         * @param {string} propertyName
         * @param {string} value
         */

      }, {
        key: "setStyleProperty",
        value: function setStyleProperty(propertyName, value) {}
      }]);

      return MDCChipAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var strings$1$4 = {
      ENTRY_ANIMATION_NAME: 'mdc-chip-entry',
      INTERACTION_EVENT: 'MDCChip:interaction',
      TRAILING_ICON_INTERACTION_EVENT: 'MDCChip:trailingIconInteraction',
      REMOVAL_EVENT: 'MDCChip:removal',
      CHECKMARK_SELECTOR: '.mdc-chip__checkmark',
      LEADING_ICON_SELECTOR: '.mdc-chip__icon--leading',
      TRAILING_ICON_SELECTOR: '.mdc-chip__icon--trailing'
    };
    /** @enum {string} */

    var cssClasses$1$4 = {
      CHECKMARK: 'mdc-chip__checkmark',
      CHIP_EXIT: 'mdc-chip--exit',
      HIDDEN_LEADING_ICON: 'mdc-chip__icon--leading-hidden',
      LEADING_ICON: 'mdc-chip__icon--leading',
      TRAILING_ICON: 'mdc-chip__icon--trailing',
      SELECTED: 'mdc-chip--selected'
    };

    /**
     * @extends {MDCFoundation<!MDCChipAdapter>}
     * @final
     */

    var MDCChipFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$5(MDCChipFoundation, _MDCFoundation);

      _createClass$5(MDCChipFoundation, null, [{
        key: "strings",

        /** @return enum {string} */
        get: function get() {
          return strings$1$4;
        }
        /** @return enum {string} */

      }, {
        key: "cssClasses",
        get: function get() {
          return cssClasses$1$4;
        }
        /**
         * {@see MDCChipAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCChipAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCChipAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              hasClass: function hasClass() {},
              addClassToLeadingIcon: function addClassToLeadingIcon() {},
              removeClassFromLeadingIcon: function removeClassFromLeadingIcon() {},
              eventTargetHasClass: function eventTargetHasClass() {},
              registerEventHandler: function registerEventHandler() {},
              deregisterEventHandler: function deregisterEventHandler() {},
              registerTrailingIconInteractionHandler: function registerTrailingIconInteractionHandler() {},
              deregisterTrailingIconInteractionHandler: function deregisterTrailingIconInteractionHandler() {},
              notifyInteraction: function notifyInteraction() {},
              notifyTrailingIconInteraction: function notifyTrailingIconInteraction() {},
              notifyRemoval: function notifyRemoval() {},
              getComputedStyleValue: function getComputedStyleValue() {},
              setStyleProperty: function setStyleProperty() {}
            }
          );
        }
        /**
         * @param {!MDCChipAdapter} adapter
         */

      }]);

      function MDCChipFoundation(adapter) {
        var _this;

        _classCallCheck$5(this, MDCChipFoundation);

        _this = _possibleConstructorReturn$5(this, _getPrototypeOf$5(MDCChipFoundation).call(this, Object.assign(MDCChipFoundation.defaultAdapter, adapter)));
        /**
         * Whether a trailing icon click should immediately trigger exit/removal of the chip.
         * @private {boolean}
         * */

        _this.shouldRemoveOnTrailingIconClick_ = true;
        /** @private {function(!Event): undefined} */

        _this.interactionHandler_ = function (evt) {
          return _this.handleInteraction(evt);
        };
        /** @private {function(!Event): undefined} */


        _this.transitionEndHandler_ = function (evt) {
          return _this.handleTransitionEnd(evt);
        };
        /** @private {function(!Event): undefined} */


        _this.trailingIconInteractionHandler_ = function (evt) {
          return _this.handleTrailingIconInteraction(evt);
        };

        return _this;
      }

      _createClass$5(MDCChipFoundation, [{
        key: "init",
        value: function init() {
          var _this2 = this;

          ['click', 'keydown'].forEach(function (evtType) {
            _this2.adapter_.registerEventHandler(evtType, _this2.interactionHandler_);
          });
          this.adapter_.registerEventHandler('transitionend', this.transitionEndHandler_);
          ['click', 'keydown', 'touchstart', 'pointerdown', 'mousedown'].forEach(function (evtType) {
            _this2.adapter_.registerTrailingIconInteractionHandler(evtType, _this2.trailingIconInteractionHandler_);
          });
        }
      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          ['click', 'keydown'].forEach(function (evtType) {
            _this3.adapter_.deregisterEventHandler(evtType, _this3.interactionHandler_);
          });
          this.adapter_.deregisterEventHandler('transitionend', this.transitionEndHandler_);
          ['click', 'keydown', 'touchstart', 'pointerdown', 'mousedown'].forEach(function (evtType) {
            _this3.adapter_.deregisterTrailingIconInteractionHandler(evtType, _this3.trailingIconInteractionHandler_);
          });
        }
        /**
         * @return {boolean}
         */

      }, {
        key: "isSelected",
        value: function isSelected() {
          return this.adapter_.hasClass(cssClasses$1$4.SELECTED);
        }
        /**
         * @param {boolean} selected
         */

      }, {
        key: "setSelected",
        value: function setSelected(selected) {
          if (selected) {
            this.adapter_.addClass(cssClasses$1$4.SELECTED);
          } else {
            this.adapter_.removeClass(cssClasses$1$4.SELECTED);
          }
        }
        /**
         * @return {boolean}
         */

      }, {
        key: "getShouldRemoveOnTrailingIconClick",
        value: function getShouldRemoveOnTrailingIconClick() {
          return this.shouldRemoveOnTrailingIconClick_;
        }
        /**
         * @param {boolean} shouldRemove
         */

      }, {
        key: "setShouldRemoveOnTrailingIconClick",
        value: function setShouldRemoveOnTrailingIconClick(shouldRemove) {
          this.shouldRemoveOnTrailingIconClick_ = shouldRemove;
        }
        /**
         * Begins the exit animation which leads to removal of the chip.
         */

      }, {
        key: "beginExit",
        value: function beginExit() {
          this.adapter_.addClass(cssClasses$1$4.CHIP_EXIT);
        }
        /**
         * Handles an interaction event on the root element.
         * @param {!Event} evt
         */

      }, {
        key: "handleInteraction",
        value: function handleInteraction(evt) {
          if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
            this.adapter_.notifyInteraction();
          }
        }
        /**
         * Handles a transition end event on the root element.
         * @param {!Event} evt
         */

      }, {
        key: "handleTransitionEnd",
        value: function handleTransitionEnd(evt) {
          var _this4 = this;

          // Handle transition end event on the chip when it is about to be removed.
          if (this.adapter_.eventTargetHasClass(
          /** @type {!EventTarget} */
          evt.target, cssClasses$1$4.CHIP_EXIT)) {
            if (evt.propertyName === 'width') {
              this.adapter_.notifyRemoval();
            } else if (evt.propertyName === 'opacity') {
              // See: https://css-tricks.com/using-css-transitions-auto-dimensions/#article-header-id-5
              var chipWidth = this.adapter_.getComputedStyleValue('width'); // On the next frame (once we get the computed width), explicitly set the chip's width
              // to its current pixel width, so we aren't transitioning out of 'auto'.

              requestAnimationFrame(function () {
                _this4.adapter_.setStyleProperty('width', chipWidth); // To mitigate jitter, start transitioning padding and margin before width.


                _this4.adapter_.setStyleProperty('padding', '0');

                _this4.adapter_.setStyleProperty('margin', '0'); // On the next frame (once width is explicitly set), transition width to 0.


                requestAnimationFrame(function () {
                  _this4.adapter_.setStyleProperty('width', '0');
                });
              });
            }

            return;
          } // Handle a transition end event on the leading icon or checkmark, since the transition end event bubbles.


          if (evt.propertyName !== 'opacity') {
            return;
          }

          if (this.adapter_.eventTargetHasClass(
          /** @type {!EventTarget} */
          evt.target, cssClasses$1$4.LEADING_ICON) && this.adapter_.hasClass(cssClasses$1$4.SELECTED)) {
            this.adapter_.addClassToLeadingIcon(cssClasses$1$4.HIDDEN_LEADING_ICON);
          } else if (this.adapter_.eventTargetHasClass(
          /** @type {!EventTarget} */
          evt.target, cssClasses$1$4.CHECKMARK) && !this.adapter_.hasClass(cssClasses$1$4.SELECTED)) {
            this.adapter_.removeClassFromLeadingIcon(cssClasses$1$4.HIDDEN_LEADING_ICON);
          }
        }
        /**
         * Handles an interaction event on the trailing icon element. This is used to
         * prevent the ripple from activating on interaction with the trailing icon.
         * @param {!Event} evt
         */

      }, {
        key: "handleTrailingIconInteraction",
        value: function handleTrailingIconInteraction(evt) {
          evt.stopPropagation();

          if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
            this.adapter_.notifyTrailingIconInteraction();

            if (this.shouldRemoveOnTrailingIconClick_) {
              this.beginExit();
            }
          }
        }
      }]);

      return MDCChipFoundation;
    }(MDCFoundation$4);

    /**
     * @extends {MDCComponent<!MDCChipFoundation>}
     * @final
     */

    var MDCChip =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$5(MDCChip, _MDCComponent);

      /**
       * @param {...?} args
       */
      function MDCChip() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$5(this, MDCChip);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$5(this, (_getPrototypeOf2 = _getPrototypeOf$5(MDCChip)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {?Element} */

        _this.leadingIcon_;
        /** @private {!MDCRipple} */

        _this.ripple_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @return {!MDCChip}
       */


      _createClass$5(MDCChip, [{
        key: "initialize",
        value: function initialize() {
          var _this2 = this;

          this.leadingIcon_ = this.root_.querySelector(strings$1$4.LEADING_ICON_SELECTOR); // Adjust ripple size for chips with animated growing width. This applies when filter chips without
          // a leading icon are selected, and a leading checkmark will cause the chip width to expand.

          var checkmarkEl = this.root_.querySelector(strings$1$4.CHECKMARK_SELECTOR);

          if (checkmarkEl && !this.leadingIcon_) {
            var adapter = Object.assign(MDCRipple$4.createAdapter(this), {
              computeBoundingRect: function computeBoundingRect() {
                var height = _this2.root_.getBoundingClientRect().height; // The checkmark's width is initially set to 0, so use the checkmark's height as a proxy since the
                // checkmark should always be square.


                var width = _this2.root_.getBoundingClientRect().width + checkmarkEl.getBoundingClientRect().height;
                return {
                  height: height,
                  width: width
                };
              }
            });
            this.ripple_ = new MDCRipple$4(this.root_, new MDCRippleFoundation$4(adapter));
          } else {
            this.ripple_ = new MDCRipple$4(this.root_);
          }
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.ripple_.destroy();

          _get$3(_getPrototypeOf$5(MDCChip.prototype), "destroy", this).call(this);
        }
        /**
         * Returns true if the chip is selected.
         * @return {boolean}
         */

      }, {
        key: "isSelected",
        value: function isSelected() {
          return this.foundation_.isSelected();
        }
        /**
         * Begins the exit animation which leads to removal of the chip.
         */

      }, {
        key: "beginExit",
        value: function beginExit() {
          this.foundation_.beginExit();
        }
        /**
         * @return {!MDCChipFoundation}
         */

      }, {
        key: "getDefaultFoundation",

        /**
         * @return {!MDCChipFoundation}
         */
        value: function getDefaultFoundation() {
          var _this3 = this;

          return new MDCChipFoundation(
          /** @type {!MDCChipAdapter} */
          Object.assign({
            addClass: function addClass(className) {
              return _this3.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this3.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
              return _this3.root_.classList.contains(className);
            },
            addClassToLeadingIcon: function addClassToLeadingIcon(className) {
              if (_this3.leadingIcon_) {
                _this3.leadingIcon_.classList.add(className);
              }
            },
            removeClassFromLeadingIcon: function removeClassFromLeadingIcon(className) {
              if (_this3.leadingIcon_) {
                _this3.leadingIcon_.classList.remove(className);
              }
            },
            eventTargetHasClass: function eventTargetHasClass(target, className) {
              return target.classList.contains(className);
            },
            registerEventHandler: function registerEventHandler(evtType, handler) {
              return _this3.root_.addEventListener(evtType, handler);
            },
            deregisterEventHandler: function deregisterEventHandler(evtType, handler) {
              return _this3.root_.removeEventListener(evtType, handler);
            },
            registerTrailingIconInteractionHandler: function registerTrailingIconInteractionHandler(evtType, handler) {
              var trailingIconEl = _this3.root_.querySelector(strings$1$4.TRAILING_ICON_SELECTOR);

              if (trailingIconEl) {
                trailingIconEl.addEventListener(evtType, handler);
              }
            },
            deregisterTrailingIconInteractionHandler: function deregisterTrailingIconInteractionHandler(evtType, handler) {
              var trailingIconEl = _this3.root_.querySelector(strings$1$4.TRAILING_ICON_SELECTOR);

              if (trailingIconEl) {
                trailingIconEl.removeEventListener(evtType, handler);
              }
            },
            notifyInteraction: function notifyInteraction() {
              return _this3.emit(strings$1$4.INTERACTION_EVENT, {
                chip: _this3
              }, true
              /* shouldBubble */
              );
            },
            notifyTrailingIconInteraction: function notifyTrailingIconInteraction() {
              return _this3.emit(strings$1$4.TRAILING_ICON_INTERACTION_EVENT, {
                chip: _this3
              }, true
              /* shouldBubble */
              );
            },
            notifyRemoval: function notifyRemoval() {
              return _this3.emit(strings$1$4.REMOVAL_EVENT, {
                chip: _this3,
                root: _this3.root_
              }, true
              /* shouldBubble */
              );
            },
            getComputedStyleValue: function getComputedStyleValue(propertyName) {
              return window.getComputedStyle(_this3.root_).getPropertyValue(propertyName);
            },
            setStyleProperty: function setStyleProperty(propertyName, value) {
              return _this3.root_.style.setProperty(propertyName, value);
            }
          }));
        }
        /** @return {!MDCRipple} */

      }, {
        key: "foundation",
        get: function get$$1() {
          return this.foundation_;
        }
        /**
         * Returns whether a trailing icon click should trigger exit/removal of the chip.
         * @return {boolean}
         */

      }, {
        key: "shouldRemoveOnTrailingIconClick",
        get: function get$$1() {
          return this.foundation_.getShouldRemoveOnTrailingIconClick();
        }
        /**
         * Sets whether a trailing icon click should trigger exit/removal of the chip.
         * @param {boolean} shouldRemove
         */
        ,
        set: function set(shouldRemove) {
          return this.foundation_.setShouldRemoveOnTrailingIconClick(shouldRemove);
        }
      }, {
        key: "ripple",
        get: function get$$1() {
          return this.ripple_;
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCChip(root);
        }
      }]);

      return MDCChip;
    }(MDCComponent$4);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Event object emitted by MdcChip when selected or deselected.
     */
    var   /**
     * Event object emitted by MdcChip when selected or deselected.
     */
    MdcChipSelectionEvent = /** @class */ (function () {
        function MdcChipSelectionEvent(source) {
            this.source = source;
        }
        return MdcChipSelectionEvent;
    }());
    var /** @type {?} */ nextUniqueId$1 = 0;
    var MdcChipIcon = /** @class */ (function (_super) {
        __extends(MdcChipIcon, _super);
        function MdcChipIcon() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.isHostClass = true;
            return _this;
        }
        Object.defineProperty(MdcChipIcon.prototype, "classIconLeading", {
            get: /**
             * @return {?}
             */
            function () {
                return this.leading ? 'mdc-chip__icon--leading' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChipIcon.prototype, "classIconTrailing", {
            get: /**
             * @return {?}
             */
            function () {
                this.setClickable(this.trailing);
                return this.trailing ? 'mdc-chip__icon--trailing' : '';
            },
            enumerable: true,
            configurable: true
        });
        MdcChipIcon.decorators = [
            { type: core.Component, args: [{selector: 'mdc-chip-icon, [mdc-chip-icon], [mdcChipIcon]',
                        template: '<ng-content></ng-content>',
                        exportAs: 'mdcChipIcon',
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        MdcChipIcon.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-chip__icon',] }],
            classIconLeading: [{ type: core.HostBinding, args: ['class.mdc-chip__icon--leading',] }],
            classIconTrailing: [{ type: core.HostBinding, args: ['class.mdc-chip__icon--trailing',] }]
        };
        return MdcChipIcon;
    }(MdcIcon));
    var MdcChipCheckmark = /** @class */ (function () {
        function MdcChipCheckmark() {
        }
        MdcChipCheckmark.decorators = [
            { type: core.Component, args: [{selector: 'mdc-chip-checkmark',
                        exportAs: 'mdcChipCheckmark',
                        template: "\n  <div class=\"mdc-chip__checkmark\">\n    <svg class=\"mdc-chip__checkmark-svg\" viewBox=\"-2 -3 30 30\">\n      <path class=\"mdc-chip__checkmark-path\" fill=\"none\" stroke=\"black\" d=\"M1.73,12.91 8.1,19.28 22.79,4.59\"/>\n    </svg>\n  </div>\n  "
                    },] },
        ];
        return MdcChipCheckmark;
    }());
    var MdcChipText = /** @class */ (function () {
        function MdcChipText(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcChipText.decorators = [
            { type: core.Component, args: [{selector: 'mdc-chip-text, [mdcChipText]',
                        exportAs: 'mdcChipText',
                        template: '<ng-content></ng-content>',
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcChipText.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcChipText.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-chip__text',] }]
        };
        return MdcChipText;
    }());
    var MdcChip = /** @class */ (function () {
        function MdcChip(_changeDetectorRef, _ripple, elementRef, _registry) {
            var _this = this;
            this._changeDetectorRef = _changeDetectorRef;
            this._ripple = _ripple;
            this.elementRef = elementRef;
            this._registry = _registry;
            this._id = "mdc-chip-" + nextUniqueId$1++;
            this._removable = true;
            /**
             * Whether the chip has focus.
             */
            this._hasFocus = false;
            /**
             * Emits when the chip is focused.
             */
            this._onFocus = new rxjs.Subject();
            /**
             * Emits when the chip is blured.
             */
            this._onBlur = new rxjs.Subject();
            /**
             * Emitted when the chip is destroyed.
             */
            this.destroyed = new core.EventEmitter();
            /**
             * Emitted when the chip is selected or deselected.
             */
            this.selectionChange = new core.EventEmitter();
            /**
             * Emitted when the chip is selected or deselected.
             */
            this.trailingIconInteraction = new core.EventEmitter();
            /**
             * Emitted when a chip is to be removed.
             */
            this.removed = new core.EventEmitter();
            this.isHostClass = true;
            this._mdcAdapter = {
                addClass: function (className) { return _this._getHostElement().classList.add(className); },
                removeClass: function (className) { return _this._getHostElement().classList.remove(className); },
                hasClass: function (className) { return _this._getHostElement().classList.contains(className); },
                addClassToLeadingIcon: function (className) {
                    var /** @type {?} */ leadingIcon = _this.getLeadingIcon();
                    if (leadingIcon) {
                        leadingIcon.elementRef.nativeElement.classList.add(className);
                    }
                },
                removeClassFromLeadingIcon: function (className) {
                    var /** @type {?} */ leadingIcon = _this.getLeadingIcon();
                    if (leadingIcon) {
                        leadingIcon.elementRef.nativeElement.classList.remove(className);
                    }
                },
                eventTargetHasClass: function (target, className) { return target.classList.contains(className); },
                registerEventHandler: function (evtType, handler) { return _this._registry.listen(evtType, handler, _this._getHostElement()); },
                deregisterEventHandler: function (evtType, handler) { return _this._registry.unlisten(evtType, handler); },
                registerInteractionHandler: function (evtType, handler) {
                    return _this._registry.listen(evtType, handler, _this._getHostElement());
                },
                deregisterInteractionHandler: function (evtType, handler) { return _this._registry.unlisten(evtType, handler); },
                registerTrailingIconInteractionHandler: function (evtType, handler) {
                    if (_this.icons) {
                        var /** @type {?} */ trailingIcon = _this.icons.find(function (_) { return _.isTrailing(); });
                        if (trailingIcon) {
                            _this._registry.listen(evtType, handler, trailingIcon.elementRef.nativeElement);
                        }
                    }
                },
                deregisterTrailingIconInteractionHandler: function (evtType, handler) { return _this._registry.unlisten(evtType, handler); },
                notifyInteraction: function () { return _this._emitSelectionChangeEvent(); },
                notifyTrailingIconInteraction: function () { return _this.trailingIconInteraction.emit(); },
                notifyRemoval: function () { return _this.removed.emit({ chip: _this }); },
                getComputedStyleValue: function (propertyName) {
                    if (isBrowser()) {
                        window.getComputedStyle(_this._getHostElement()).getPropertyValue(propertyName);
                    }
                },
                setStyleProperty: function (propertyName, value) { return _this._getHostElement().style.setProperty(propertyName, value); }
            };
            this._foundation = new MDCChipFoundation(this._mdcAdapter);
        }
        Object.defineProperty(MdcChip.prototype, "selected", {
            get: /**
             * @return {?}
             */
            function () { return this._selected; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setSelected(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChip.prototype, "filter", {
            get: /**
             * @return {?}
             */
            function () { return this._filter; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._filter = toBoolean(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChip.prototype, "primary", {
            get: /**
             * @return {?}
             */
            function () { return this._primary; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setPrimary(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChip.prototype, "secondary", {
            get: /**
             * @return {?}
             */
            function () { return this._secondary; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setSecondary(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChip.prototype, "removable", {
            /**
              * Determines whether or not the chip displays the remove styling and emits (removed) events.
              */
            get: /**
             * Determines whether or not the chip displays the remove styling and emits (removed) events.
             * @return {?}
             */
            function () { return this._removable; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setRemovable(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChip.prototype, "id", {
            /** The unique ID of the option. */
            get: /**
             * The unique ID of the option.
             * @return {?}
             */
            function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChip.prototype, "disabled", {
            /** Whether the chip is disabled. */
            get: /**
             * Whether the chip is disabled.
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._disabled = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChip.prototype, "tabindex", {
            get: /**
             * @return {?}
             */
            function () {
                return this.disabled ? null : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChip.prototype, "classPrimary", {
            get: /**
             * @return {?}
             */
            function () {
                return this.primary ? 'ng-mdc-chip--primary' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChip.prototype, "classSecondary", {
            get: /**
             * @return {?}
             */
            function () {
                return this.secondary ? 'ng-mdc-chip--secondary' : '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcChip.prototype.onfocus = /**
         * @return {?}
         */
        function () {
            this._hasFocus = true;
        };
        /**
         * @return {?}
         */
        MdcChip.prototype.onblur = /**
         * @return {?}
         */
        function () {
            this._blur();
        };
        /**
         * @return {?}
         */
        MdcChip.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            this._ripple.attachTo(this._getHostElement());
            this._foundation.init();
        };
        /**
         * @return {?}
         */
        MdcChip.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (!this.removable) {
                this._foundation.beginExit();
            }
            this._ripple.destroy();
            this.destroyed.emit({ chip: this });
            this._foundation.destroy();
        };
        /**
         * @param {?} selected
         * @return {?}
         */
        MdcChip.prototype.setSelected = /**
         * @param {?} selected
         * @return {?}
         */
        function (selected) {
            this._selected = toBoolean(selected);
            this._foundation.setSelected(selected);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @return {?}
         */
        MdcChip.prototype.isSelected = /**
         * @return {?}
         */
        function () {
            return this._foundation.isSelected();
        };
        /**
         * @param {?} primary
         * @return {?}
         */
        MdcChip.prototype.setPrimary = /**
         * @param {?} primary
         * @return {?}
         */
        function (primary) {
            if (primary) {
                this.setSecondary(false);
            }
            this._primary = primary;
        };
        /**
         * @param {?} secondary
         * @return {?}
         */
        MdcChip.prototype.setSecondary = /**
         * @param {?} secondary
         * @return {?}
         */
        function (secondary) {
            if (secondary) {
                this.setPrimary(false);
            }
            this._secondary = secondary;
        };
        /**
         * @param {?} removable
         * @return {?}
         */
        MdcChip.prototype.setRemovable = /**
         * @param {?} removable
         * @return {?}
         */
        function (removable) {
            this._removable = toBoolean(removable);
            this._foundation.setShouldRemoveOnTrailingIconClick(removable);
            this._changeDetectorRef.markForCheck();
        };
        /** Allows for programmatic focusing of the chip. */
        /**
         * Allows for programmatic focusing of the chip.
         * @return {?}
         */
        MdcChip.prototype.focus = /**
         * Allows for programmatic focusing of the chip.
         * @return {?}
         */
        function () {
            this._getHostElement().focus();
            this._onFocus.next({ chip: this });
        };
        /**
         * Allows for programmatic removal of the chip. Called by the MdcChipSet when the DELETE or
         * BACKSPACE keys are pressed.
         *
         * Informs any listeners of the removal request. Does not remove the chip from the DOM.
         */
        /**
         * Allows for programmatic removal of the chip. Called by the MdcChipSet when the DELETE or
         * BACKSPACE keys are pressed.
         *
         * Informs any listeners of the removal request. Does not remove the chip from the DOM.
         * @return {?}
         */
        MdcChip.prototype.remove = /**
         * Allows for programmatic removal of the chip. Called by the MdcChipSet when the DELETE or
         * BACKSPACE keys are pressed.
         *
         * Informs any listeners of the removal request. Does not remove the chip from the DOM.
         * @return {?}
         */
        function () {
            this.removed.emit({ chip: this });
        };
        /**
         * @return {?}
         */
        MdcChip.prototype.isLeadingIconVisibile = /**
         * @return {?}
         */
        function () {
            return this.filter && this.selected ? false : true;
        };
        /**
         * @return {?}
         */
        MdcChip.prototype.getLeadingIcon = /**
         * @return {?}
         */
        function () {
            if (this.icons) {
                return this.icons.find(function (_) { return _.isLeading(); });
            }
        };
        /**
         * @return {?}
         */
        MdcChip.prototype._blur = /**
         * @return {?}
         */
        function () {
            this._onBlur.next({ chip: this });
        };
        /** Retrieves the DOM element of the component host. */
        /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        MdcChip.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        /**
         * Emits the selection change event.
         * @return {?}
         */
        MdcChip.prototype._emitSelectionChangeEvent = /**
         * Emits the selection change event.
         * @return {?}
         */
        function () {
            this.selectionChange.emit({ source: this });
        };
        MdcChip.decorators = [
            { type: core.Component, args: [{selector: 'mdc-chip',
                        host: {
                            '[id]': 'id'
                        },
                        exportAs: 'mdcChip',
                        template: "\n  <ng-content *ngIf=\"isLeadingIconVisibile()\" select=\"mdc-chip-icon[leading]\"></ng-content>\n  <mdc-chip-checkmark *ngIf=\"filter\"></mdc-chip-checkmark>\n  <div class=\"mdc-chip__text\" *ngIf=\"label\">{{label}}</div>\n  <ng-content></ng-content>\n  ",
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [
                            MdcRipple,
                            EventRegistry
                        ]
                    },] },
        ];
        /** @nocollapse */
        MdcChip.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: MdcRipple },
            { type: core.ElementRef },
            { type: EventRegistry }
        ]; };
        MdcChip.propDecorators = {
            label: [{ type: core.Input }],
            primary: [{ type: core.Input }],
            secondary: [{ type: core.Input }],
            removable: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            destroyed: [{ type: core.Output }],
            selectionChange: [{ type: core.Output }],
            trailingIconInteraction: [{ type: core.Output }],
            removed: [{ type: core.Output }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-chip',] }],
            tabindex: [{ type: core.HostBinding, args: ['attr.tabindex',] }],
            classPrimary: [{ type: core.HostBinding, args: ['class.ng-mdc-chip--primary',] }],
            classSecondary: [{ type: core.HostBinding, args: ['class.ng-mdc-chip--secondary',] }],
            onfocus: [{ type: core.HostListener, args: ['focus',] }],
            onblur: [{ type: core.HostListener, args: ['blur',] }],
            chipText: [{ type: core.ContentChild, args: [MdcChipText,] }],
            icons: [{ type: core.ContentChildren, args: [MdcChipIcon,] }]
        };
        return MdcChip;
    }());

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Chip Set.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Chip Set into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */

    var MDCChipSetAdapter =
    /*#__PURE__*/
    function () {
      function MDCChipSetAdapter() {
        _classCallCheck$5(this, MDCChipSetAdapter);
      }

      _createClass$5(MDCChipSetAdapter, [{
        key: "hasClass",

        /**
         * Returns true if the root element contains the given class name.
         * @param {string} className
         * @return {boolean}
         */
        value: function hasClass(className) {}
        /**
         * Registers an event handler on the root element for a given event.
         * @param {string} evtType
         * @param {function(!MDCChipInteractionEventType): undefined} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * Deregisters an event handler on the root element for a given event.
         * @param {string} evtType
         * @param {function(!MDCChipInteractionEventType): undefined} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * Removes the chip object from the chip set.
         * @param {!Object} chip
         */

      }, {
        key: "removeChip",
        value: function removeChip(chip) {}
      }]);

      return MDCChipSetAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var strings$2$1 = {
      CHIP_SELECTOR: '.mdc-chip'
    };
    /** @enum {string} */

    var cssClasses$2$1 = {
      CHOICE: 'mdc-chip-set--choice',
      FILTER: 'mdc-chip-set--filter'
    };

    /**
     * @extends {MDCFoundation<!MDCChipSetAdapter>}
     * @final
     */

    var MDCChipSetFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$5(MDCChipSetFoundation, _MDCFoundation);

      _createClass$5(MDCChipSetFoundation, null, [{
        key: "strings",

        /** @return enum {string} */
        get: function get() {
          return strings$2$1;
        }
        /** @return enum {string} */

      }, {
        key: "cssClasses",
        get: function get() {
          return cssClasses$2$1;
        }
        /**
         * {@see MDCChipSetAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCChipSetAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCChipSetAdapter} */
            {
              hasClass: function hasClass() {},
              registerInteractionHandler: function registerInteractionHandler() {},
              deregisterInteractionHandler: function deregisterInteractionHandler() {},
              removeChip: function removeChip() {}
            }
          );
        }
        /**
         * @param {!MDCChipSetAdapter} adapter
         */

      }]);

      function MDCChipSetFoundation(adapter) {
        var _this;

        _classCallCheck$5(this, MDCChipSetFoundation);

        _this = _possibleConstructorReturn$5(this, _getPrototypeOf$5(MDCChipSetFoundation).call(this, Object.assign(MDCChipSetFoundation.defaultAdapter, adapter)));
        /**
         * The selected chips in the set. Only used for choice chip set or filter chip set.
         * @private {!Array<!MDCChipFoundation>}
         */

        _this.selectedChips_ = [];
        /** @private {function(!MDCChipInteractionEventType): undefined} */

        _this.chipInteractionHandler_ = function (evt) {
          return _this.handleChipInteraction_(evt);
        };
        /** @private {function(!MDCChipInteractionEventType): undefined} */


        _this.chipRemovalHandler_ = function (evt) {
          return _this.handleChipRemoval_(evt);
        };

        return _this;
      }

      _createClass$5(MDCChipSetFoundation, [{
        key: "init",
        value: function init() {
          this.adapter_.registerInteractionHandler(MDCChipFoundation.strings.INTERACTION_EVENT, this.chipInteractionHandler_);
          this.adapter_.registerInteractionHandler(MDCChipFoundation.strings.REMOVAL_EVENT, this.chipRemovalHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.adapter_.deregisterInteractionHandler(MDCChipFoundation.strings.INTERACTION_EVENT, this.chipInteractionHandler_);
          this.adapter_.deregisterInteractionHandler(MDCChipFoundation.strings.REMOVAL_EVENT, this.chipRemovalHandler_);
        }
        /**
         * Selects the given chip. Deselects all other chips if the chip set is of the choice variant.
         * @param {!MDCChipFoundation} chipFoundation
         */

      }, {
        key: "select",
        value: function select(chipFoundation) {
          if (this.adapter_.hasClass(cssClasses$2$1.CHOICE)) {
            this.deselectAll_();
          }

          chipFoundation.setSelected(true);
          this.selectedChips_.push(chipFoundation);
        }
        /**
         * Deselects the given chip.
         * @param {!MDCChipFoundation} chipFoundation
         */

      }, {
        key: "deselect",
        value: function deselect(chipFoundation) {
          var index = this.selectedChips_.indexOf(chipFoundation);

          if (index >= 0) {
            this.selectedChips_.splice(index, 1);
          }

          chipFoundation.setSelected(false);
        }
        /** Deselects all selected chips. */

      }, {
        key: "deselectAll_",
        value: function deselectAll_() {
          this.selectedChips_.forEach(function (chipFoundation) {
            chipFoundation.setSelected(false);
          });
          this.selectedChips_.length = 0;
        }
        /**
         * Handles a chip interaction event
         * @param {!MDCChipInteractionEventType} evt
         * @private
         */

      }, {
        key: "handleChipInteraction_",
        value: function handleChipInteraction_(evt) {
          var chipFoundation = evt.detail.chip.foundation;

          if (this.adapter_.hasClass(cssClasses$2$1.CHOICE) || this.adapter_.hasClass(cssClasses$2$1.FILTER)) {
            if (chipFoundation.isSelected()) {
              this.deselect(chipFoundation);
            } else {
              this.select(chipFoundation);
            }
          }
        }
        /**
         * Handles the event when a chip is removed.
         * @param {!MDCChipInteractionEventType} evt
         * @private
         */

      }, {
        key: "handleChipRemoval_",
        value: function handleChipRemoval_(evt) {
          var chip = evt.detail.chip;
          this.deselect(chip.foundation);
          this.adapter_.removeChip(chip);
        }
      }]);

      return MDCChipSetFoundation;
    }(MDCFoundation$4);

    /**
     * @extends {MDCComponent<!MDCChipSetFoundation>}
     * @final
     */

    var MDCChipSet =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$5(MDCChipSet, _MDCComponent);

      /**
       * @param {...?} args
       */
      function MDCChipSet() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$5(this, MDCChipSet);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$5(this, (_getPrototypeOf2 = _getPrototypeOf$5(MDCChipSet)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {!Array<!MDCChip>} */

        _this.chips;
        /** @type {(function(!Element): !MDCChip)} */

        _this.chipFactory_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @return {!MDCChipSet}
       */


      _createClass$5(MDCChipSet, [{
        key: "initialize",

        /**
         * @param {(function(!Element): !MDCChip)=} chipFactory A function which
         * creates a new MDCChip.
         */
        value: function initialize() {
          var chipFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (el) {
            return new MDCChip(el);
          };
          this.chipFactory_ = chipFactory;
          this.chips = this.instantiateChips_(this.chipFactory_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.chips.forEach(function (chip) {
            chip.destroy();
          });
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          var _this2 = this;

          this.chips.forEach(function (chip) {
            if (chip.isSelected()) {
              _this2.foundation_.select(chip.foundation);
            }
          });
        }
        /**
         * Adds a new chip object to the chip set from the given chip element.
         * @param {!Element} chipEl
         */

      }, {
        key: "addChip",
        value: function addChip(chipEl) {
          this.chips.push(this.chipFactory_(chipEl));
        }
        /**
         * @return {!MDCChipSetFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this3 = this;

          return new MDCChipSetFoundation(
          /** @type {!MDCChipSetAdapter} */
          Object.assign({
            hasClass: function hasClass(className) {
              return _this3.root_.classList.contains(className);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return _this3.root_.addEventListener(evtType, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return _this3.root_.removeEventListener(evtType, handler);
            },
            removeChip: function removeChip(chip) {
              var index = _this3.chips.indexOf(chip);

              _this3.chips.splice(index, 1);

              chip.destroy();
            }
          }));
        }
        /**
         * Instantiates chip components on all of the chip set's child chip elements.
         * @param {(function(!Element): !MDCChip)} chipFactory
         * @return {!Array<!MDCChip>}
         */

      }, {
        key: "instantiateChips_",
        value: function instantiateChips_(chipFactory) {
          var chipElements = [].slice.call(this.root_.querySelectorAll(MDCChipSetFoundation.strings.CHIP_SELECTOR));
          return chipElements.map(function (el) {
            return chipFactory(el);
          });
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCChipSet(root);
        }
      }]);

      return MDCChipSet;
    }(MDCComponent$4);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcChipSet = /** @class */ (function () {
        function MdcChipSet(_changeDetectorRef, _ngZone, elementRef, _registry) {
            var _this = this;
            this._changeDetectorRef = _changeDetectorRef;
            this._ngZone = _ngZone;
            this.elementRef = elementRef;
            this._registry = _registry;
            /**
             * Emits whenever the component is destroyed.
             */
            this._destroy = new rxjs.Subject();
            this._choice = false;
            this._filter = false;
            this._input = false;
            this.isHostClass = true;
            /**
             * Combined stream of all of the chip change events.
             */
            this.chipSelectionChanges = rxjs.defer(function () {
                if (_this.chips) {
                    return rxjs.merge.apply(void 0, _this.chips.map(function (chip) { return chip.selectionChange; }));
                }
                return _this._ngZone.onStable
                    .asObservable()
                    .pipe(operators.take(1), operators.switchMap(function () { return _this.chipSelectionChanges; }));
            });
            this._mdcAdapter = {
                hasClass: function (className) { return _this._getHostElement().classList.contains(className); },
                registerInteractionHandler: function (evtType, handler) {
                    return _this._registry.listen(evtType, handler, _this._getHostElement());
                },
                deregisterInteractionHandler: function (evtType, handler) { return _this._registry.unlisten(evtType, handler); },
                removeChip: function (chip) {
                    var /** @type {?} */ index = _this.chips.toArray().indexOf(chip);
                    _this.chips.toArray().splice(index, 1);
                }
            };
            this._foundation = new MDCChipSetFoundation(this._mdcAdapter);
        }
        Object.defineProperty(MdcChipSet.prototype, "choice", {
            /**
            * Indicates that the chips in the set are choice chips, which allow a single selection from a set of options.
            */
            get: /**
             * Indicates that the chips in the set are choice chips, which allow a single selection from a set of options.
             * @return {?}
             */
            function () { return this._choice; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setChoice(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChipSet.prototype, "filter", {
            /**
            * Indicates that the chips in the set are filter chips, which allow multiple selection from a set of options.
            */
            get: /**
             * Indicates that the chips in the set are filter chips, which allow multiple selection from a set of options.
             * @return {?}
             */
            function () { return this._filter; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setFilter(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChipSet.prototype, "input", {
            /**
            * Indicates that the chips in the set are input chips, which enable user input by converting text into chips.
            */
            get: /**
             * Indicates that the chips in the set are input chips, which enable user input by converting text into chips.
             * @return {?}
             */
            function () { return this._input; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setInput(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChipSet.prototype, "classChoice", {
            get: /**
             * @return {?}
             */
            function () {
                return this.choice ? 'mdc-chip-set--choice' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChipSet.prototype, "classFilter", {
            get: /**
             * @return {?}
             */
            function () {
                return this.filter ? 'mdc-chip-set--filter' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcChipSet.prototype, "classInput", {
            get: /**
             * @return {?}
             */
            function () {
                return this.input ? 'mdc-chip-set--input' : '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcChipSet.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.chipSelectionChanges.pipe(operators.takeUntil(rxjs.merge(this._destroy, this.chips.changes))).subscribe(function (event) {
                if (!_this.filter) {
                    _this.chips.forEach(function (chip) {
                        if (chip.selected && chip !== event.source) {
                            chip.setSelected(!chip.selected);
                        }
                    });
                }
                if (_this.choice || _this.filter) {
                    event.source.setSelected(!event.source.selected);
                }
            });
            this.chips.changes.pipe(operators.startWith(null), operators.takeUntil(this._destroy)).subscribe(function () {
                Promise.resolve().then(function () {
                    _this.chips.forEach(function (chip) {
                        chip.filter = _this.filter;
                    });
                });
            });
        };
        /**
         * @return {?}
         */
        MdcChipSet.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroy.next();
            this._destroy.complete();
            this._foundation.destroy();
        };
        /**
         * @return {?}
         */
        MdcChipSet.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this._foundation.init();
        };
        /**
         * @param {?} choice
         * @return {?}
         */
        MdcChipSet.prototype.setChoice = /**
         * @param {?} choice
         * @return {?}
         */
        function (choice) {
            this._choice = choice;
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} filter
         * @return {?}
         */
        MdcChipSet.prototype.setFilter = /**
         * @param {?} filter
         * @return {?}
         */
        function (filter) {
            this._filter = filter;
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} input
         * @return {?}
         */
        MdcChipSet.prototype.setInput = /**
         * @param {?} input
         * @return {?}
         */
        function (input) {
            this._input = input;
            this._changeDetectorRef.markForCheck();
        };
        /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        MdcChipSet.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcChipSet.decorators = [
            { type: core.Component, args: [{selector: 'mdc-chip-set',
                        exportAs: 'mdcChipSet',
                        template: "<ng-content></ng-content>",
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [EventRegistry]
                    },] },
        ];
        /** @nocollapse */
        MdcChipSet.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.NgZone },
            { type: core.ElementRef },
            { type: EventRegistry }
        ]; };
        MdcChipSet.propDecorators = {
            choice: [{ type: core.Input }],
            filter: [{ type: core.Input }],
            input: [{ type: core.Input }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-chip-set',] }],
            classChoice: [{ type: core.HostBinding, args: ['class.mdc-chip-set--choice',] }],
            classFilter: [{ type: core.HostBinding, args: ['class.mdc-chip-set--filter',] }],
            classInput: [{ type: core.HostBinding, args: ['class.mdc-chip-set--input',] }],
            chips: [{ type: core.ContentChildren, args: [MdcChip,] }]
        };
        return MdcChipSet;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ CHIP_DECLARATIONS = [
        MdcChip,
        MdcChipCheckmark,
        MdcChipIcon,
        MdcChipSet,
        MdcChipText
    ];
    var MdcChipsModule = /** @class */ (function () {
        function MdcChipsModule() {
        }
        MdcChipsModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, MdcIconModule],
                        exports: CHIP_DECLARATIONS,
                        declarations: CHIP_DECLARATIONS,
                        entryComponents: [MdcChip, MdcChipText, MdcChipIcon]
                    },] },
        ];
        return MdcChipsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * A `Portal` is something that you want to render somewhere else.
     * It can be attach to / detached from a `PortalOutlet`.
     * @abstract
     * @template T
     */
    var   /**
     * A `Portal` is something that you want to render somewhere else.
     * It can be attach to / detached from a `PortalOutlet`.
     * @abstract
     * @template T
     */
    Portal = /** @class */ (function () {
        function Portal() {
        }
        /** Attach this portal to a host. */
        /**
         * Attach this portal to a host.
         * @param {?} host
         * @return {?}
         */
        Portal.prototype.attach = /**
         * Attach this portal to a host.
         * @param {?} host
         * @return {?}
         */
        function (host) {
            this._attachedHost = host;
            return /** @type {?} */ (host.attach(this));
        };
        /** Detach this portal from its host */
        /**
         * Detach this portal from its host
         * @return {?}
         */
        Portal.prototype.detach = /**
         * Detach this portal from its host
         * @return {?}
         */
        function () {
            var /** @type {?} */ host = this._attachedHost;
            this._attachedHost = null;
            host.detach();
        };
        Object.defineProperty(Portal.prototype, "isAttached", {
            /** Whether this portal is attached to a host. */
            get: /**
             * Whether this portal is attached to a host.
             * @return {?}
             */
            function () {
                return this._attachedHost != null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Sets the PortalOutlet reference without performing `attach()`. This is used directly by
         * the PortalOutlet when it is performing an `attach()` or `detach()`.
         */
        /**
         * Sets the PortalOutlet reference without performing `attach()`. This is used directly by
         * the PortalOutlet when it is performing an `attach()` or `detach()`.
         * @param {?} host
         * @return {?}
         */
        Portal.prototype.setAttachedHost = /**
         * Sets the PortalOutlet reference without performing `attach()`. This is used directly by
         * the PortalOutlet when it is performing an `attach()` or `detach()`.
         * @param {?} host
         * @return {?}
         */
        function (host) {
            this._attachedHost = host;
        };
        return Portal;
    }());
    /**
     * A `ComponentPortal` is a portal that instantiates some Component upon attachment.
     * @template T
     */
    var   /**
     * A `ComponentPortal` is a portal that instantiates some Component upon attachment.
     * @template T
     */
    ComponentPortal = /** @class */ (function (_super) {
        __extends(ComponentPortal, _super);
        function ComponentPortal(component, viewContainerRef, injector) {
            var _this = _super.call(this) || this;
            _this.component = component;
            _this.viewContainerRef = viewContainerRef;
            _this.injector = injector;
            return _this;
        }
        return ComponentPortal;
    }(Portal));
    /**
     * Partial implementation of PortalOutlet that handles attaching
     * ComponentPortal and TemplatePortal.
     * @abstract
     */
    var   /**
     * Partial implementation of PortalOutlet that handles attaching
     * ComponentPortal and TemplatePortal.
     * @abstract
     */
    BasePortalOutlet = /** @class */ (function () {
        function BasePortalOutlet() {
            /**
             * Whether this host has already been permanently disposed.
             */
            this._isDisposed = false;
        }
        /** Whether this host has an attached portal. */
        /**
         * Whether this host has an attached portal.
         * @return {?}
         */
        BasePortalOutlet.prototype.hasAttached = /**
         * Whether this host has an attached portal.
         * @return {?}
         */
        function () {
            return !!this._attachedPortal;
        };
        /** Attaches a portal. */
        /**
         * Attaches a portal.
         * @param {?} portal
         * @return {?}
         */
        BasePortalOutlet.prototype.attach = /**
         * Attaches a portal.
         * @param {?} portal
         * @return {?}
         */
        function (portal) {
            if (portal instanceof ComponentPortal) {
                this._attachedPortal = portal;
                return this.attachComponentPortal(portal);
            }
        };
        /** Detaches a previously attached portal. */
        /**
         * Detaches a previously attached portal.
         * @return {?}
         */
        BasePortalOutlet.prototype.detach = /**
         * Detaches a previously attached portal.
         * @return {?}
         */
        function () {
            if (this._attachedPortal) {
                this._attachedPortal.setAttachedHost(null);
                this._attachedPortal = null;
            }
            this._invokeDisposeFn();
        };
        /** Permanently dispose of this portal host. */
        /**
         * Permanently dispose of this portal host.
         * @return {?}
         */
        BasePortalOutlet.prototype.dispose = /**
         * Permanently dispose of this portal host.
         * @return {?}
         */
        function () {
            if (this.hasAttached()) {
                this.detach();
            }
            this._invokeDisposeFn();
            this._isDisposed = true;
        };
        /** @docs-private */
        /**
         * \@docs-private
         * @param {?} fn
         * @return {?}
         */
        BasePortalOutlet.prototype.setDisposeFn = /**
         * \@docs-private
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._disposeFn = fn;
        };
        /**
         * @return {?}
         */
        BasePortalOutlet.prototype._invokeDisposeFn = /**
         * @return {?}
         */
        function () {
            if (this._disposeFn) {
                this._disposeFn();
                this._disposeFn = null;
            }
        };
        return BasePortalOutlet;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular
     * application context.
     */
    var   /**
     * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular
     * application context.
     */
    DomPortalOutlet = /** @class */ (function (_super) {
        __extends(DomPortalOutlet, _super);
        function DomPortalOutlet(outletElement, _componentFactoryResolver, _appRef, _defaultInjector) {
            var _this = _super.call(this) || this;
            _this.outletElement = outletElement;
            _this._componentFactoryResolver = _componentFactoryResolver;
            _this._appRef = _appRef;
            _this._defaultInjector = _defaultInjector;
            return _this;
        }
        /**
         * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
         * @param portal Portal to be attached
         * @returns Reference to the created component.
         */
        /**
         * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
         * @template T
         * @param {?} portal Portal to be attached
         * @return {?} Reference to the created component.
         */
        DomPortalOutlet.prototype.attachComponentPortal = /**
         * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
         * @template T
         * @param {?} portal Portal to be attached
         * @return {?} Reference to the created component.
         */
        function (portal) {
            var _this = this;
            var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);
            var /** @type {?} */ componentRef;
            // If the portal specifies a ViewContainerRef, we will use that as the attachment point
            // for the component (in terms of Angular's component tree, not rendering).
            // When the ViewContainerRef is missing, we use the factory to create the component directly
            // and then manually attach the view to the application.
            if (portal.viewContainerRef) {
                componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.parentInjector);
                this.setDisposeFn(function () { return componentRef.destroy(); });
            }
            else {
                componentRef = componentFactory.create(portal.injector || this._defaultInjector);
                this._appRef.attachView(componentRef.hostView);
                this.setDisposeFn(function () {
                    _this._appRef.detachView(componentRef.hostView);
                    componentRef.destroy();
                });
            }
            // At this point the component has been instantiated, so we move it to the location in the DOM
            // where we want it to be rendered.
            this.outletElement.appendChild(this._getComponentRootNode(componentRef));
            return componentRef;
        };
        /**
         * Clears out a portal from the DOM.
         */
        /**
         * Clears out a portal from the DOM.
         * @return {?}
         */
        DomPortalOutlet.prototype.dispose = /**
         * Clears out a portal from the DOM.
         * @return {?}
         */
        function () {
            _super.prototype.dispose.call(this);
            if (this.outletElement.parentNode != null) {
                this.outletElement.parentNode.removeChild(this.outletElement);
            }
        };
        /**
         * Gets the root HTMLElement for an instantiated component.
         * @param {?} componentRef
         * @return {?}
         */
        DomPortalOutlet.prototype._getComponentRootNode = /**
         * Gets the root HTMLElement for an instantiated component.
         * @param {?} componentRef
         * @return {?}
         */
        function (componentRef) {
            return /** @type {?} */ ((/** @type {?} */ (componentRef.hostView)).rootNodes[0]);
        };
        return DomPortalOutlet;
    }(BasePortalOutlet));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Custom injector to be used when providing custom
     * injection tokens to components inside a portal.
     * \@docs-private
     */
    var   /**
     * Custom injector to be used when providing custom
     * injection tokens to components inside a portal.
     * \@docs-private
     */
    PortalInjector = /** @class */ (function () {
        function PortalInjector(_parentInjector, _customTokens) {
            this._parentInjector = _parentInjector;
            this._customTokens = _customTokens;
        }
        /**
         * @param {?} token
         * @param {?=} notFoundValue
         * @return {?}
         */
        PortalInjector.prototype.get = /**
         * @param {?} token
         * @param {?=} notFoundValue
         * @return {?}
         */
        function (token, notFoundValue) {
            var /** @type {?} */ value = this._customTokens.get(token);
            if (typeof value !== 'undefined') {
                return value;
            }
            return this._parentInjector.get(token, notFoundValue);
        };
        return PortalInjector;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be
     * directly attached to it, enabling declarative use.
     *
     * Usage:
     * `<ng-template [cdkPortalOutlet]="greeting"></ng-template>`
     */
    var CdkPortalOutlet = /** @class */ (function (_super) {
        __extends(CdkPortalOutlet, _super);
        function CdkPortalOutlet(_componentFactoryResolver, _viewContainerRef) {
            var _this = _super.call(this) || this;
            _this._componentFactoryResolver = _componentFactoryResolver;
            _this._viewContainerRef = _viewContainerRef;
            /**
             * Whether the portal component is initialized.
             */
            _this._isInitialized = false;
            _this.attached = new core.EventEmitter();
            return _this;
        }
        Object.defineProperty(CdkPortalOutlet.prototype, "portal", {
            /** Portal associated with the Portal outlet. */
            get: /**
             * Portal associated with the Portal outlet.
             * @return {?}
             */
            function () {
                return this._attachedPortal;
            },
            set: /**
             * @param {?} portal
             * @return {?}
             */
            function (portal) {
                // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have
                // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`
                // and attach a portal programmatically in the parent component. When Angular does the first CD
                // round, it will fire the setter with empty string, causing the user's content to be cleared.
                if (this.hasAttached() && !portal && !this._isInitialized) {
                    return;
                }
                if (this.hasAttached()) {
                    _super.prototype.detach.call(this);
                }
                if (portal) {
                    _super.prototype.attach.call(this, portal);
                }
                this._attachedPortal = portal;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CdkPortalOutlet.prototype, "attachedRef", {
            /** Component or view reference that is attached to the portal. */
            get: /**
             * Component or view reference that is attached to the portal.
             * @return {?}
             */
            function () {
                return this._attachedRef;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        CdkPortalOutlet.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this._isInitialized = true;
        };
        /**
         * @return {?}
         */
        CdkPortalOutlet.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            _super.prototype.dispose.call(this);
            this._attachedPortal = null;
            this._attachedRef = null;
        };
        /**
         * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.
         *
         * @param portal Portal to be attached to the portal outlet.
         * @returns Reference to the created component.
         */
        /**
         * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.
         *
         * @template T
         * @param {?} portal Portal to be attached to the portal outlet.
         * @return {?} Reference to the created component.
         */
        CdkPortalOutlet.prototype.attachComponentPortal = /**
         * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.
         *
         * @template T
         * @param {?} portal Portal to be attached to the portal outlet.
         * @return {?} Reference to the created component.
         */
        function (portal) {
            portal.setAttachedHost(this);
            // If the portal specifies an origin, use that as the logical location of the component
            // in the application tree. Otherwise use the location of this PortalOutlet.
            var /** @type {?} */ viewContainerRef = portal.viewContainerRef != null ?
                portal.viewContainerRef :
                this._viewContainerRef;
            var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);
            var /** @type {?} */ ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.parentInjector);
            _super.prototype.setDisposeFn.call(this, function () { return ref.destroy(); });
            this._attachedPortal = portal;
            this._attachedRef = ref;
            this.attached.emit(ref);
            return ref;
        };
        CdkPortalOutlet.decorators = [
            { type: core.Directive, args: [{
                        selector: '[cdkPortalOutlet], [cdkPortalHost], [portalHost]',
                        exportAs: 'cdkPortalOutlet, cdkPortalHost',
                        inputs: ['portal: cdkPortalOutlet']
                    },] },
        ];
        /** @nocollapse */
        CdkPortalOutlet.ctorParameters = function () { return [
            { type: core.ComponentFactoryResolver },
            { type: core.ViewContainerRef }
        ]; };
        CdkPortalOutlet.propDecorators = {
            attached: [{ type: core.Output }]
        };
        return CdkPortalOutlet;
    }(BasePortalOutlet));
    var PortalModule = /** @class */ (function () {
        function PortalModule() {
        }
        PortalModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [CdkPortalOutlet],
                        declarations: [CdkPortalOutlet],
                    },] },
        ];
        return PortalModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcPortalService = /** @class */ (function () {
        function MdcPortalService(_componentFactoryResolver, _appRef, _injector) {
            this._componentFactoryResolver = _componentFactoryResolver;
            this._appRef = _appRef;
            this._injector = _injector;
        }
        /**
         * @template T
         * @param {?} portal
         * @param {?=} parent
         * @return {?}
         */
        MdcPortalService.prototype.createComponentRef = /**
         * @template T
         * @param {?} portal
         * @param {?=} parent
         * @return {?}
         */
        function (portal, parent) {
            var _this = this;
            if (parent === void 0) { parent = document.body; }
            var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal);
            var /** @type {?} */ componentRef;
            componentRef = componentFactory.create(this._injector);
            this._appRef.attachView(componentRef.hostView);
            this.setDisposeFn(function () {
                _this._appRef.detachView(componentRef.hostView);
                componentRef.destroy();
            });
            this._addChild(this._getComponentRootNode(componentRef), parent);
            return componentRef;
        };
        /**
         * @param {?} componentRef
         * @return {?}
         */
        MdcPortalService.prototype._getComponentRootNode = /**
         * @param {?} componentRef
         * @return {?}
         */
        function (componentRef) {
            return /** @type {?} */ ((/** @type {?} */ (componentRef.hostView)).rootNodes[0]);
        };
        /**
         * @param {?} child
         * @param {?} parent
         * @return {?}
         */
        MdcPortalService.prototype._addChild = /**
         * @param {?} child
         * @param {?} parent
         * @return {?}
         */
        function (child, parent) {
            parent.appendChild(child);
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcPortalService.prototype.setDisposeFn = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._disposeFn = fn;
        };
        /**
         * @return {?}
         */
        MdcPortalService.prototype.dispose = /**
         * @return {?}
         */
        function () {
            if (this._disposeFn) {
                this._disposeFn();
                this._disposeFn = null;
            }
        };
        MdcPortalService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        MdcPortalService.ctorParameters = function () { return [
            { type: core.ComponentFactoryResolver },
            { type: core.ApplicationRef },
            { type: core.Injector }
        ]; };
        return MdcPortalService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @template D
     */
    var   /**
     * @template D
     */
    MdcDialogConfig = /** @class */ (function () {
        function MdcDialogConfig() {
            /**
             * ID of the element that describes the dialog.
             */
            this.ariaDescribedBy = null;
            /**
             * Aria label to assign to the dialog element
             */
            this.ariaLabel = null;
            /**
             * Whether the user can use escape key to close the dialog
             */
            this.escapeToClose = true;
            /**
             * Whether the user can click outside to close the dialog
             */
            this.clickOutsideToClose = true;
            /**
             * Whether the dialog has a backdrop.
             */
            this.backdrop = true;
            /**
             * Data to be injected into the dialog content.
             */
            this.data = null;
        }
        return MdcDialogConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcDialogContainer = /** @class */ (function (_super) {
        __extends(MdcDialogContainer, _super);
        function MdcDialogContainer(_elementRef, _document) {
            var _this = _super.call(this) || this;
            _this._elementRef = _elementRef;
            _this._document = _document;
            /**
             * A subject emitting after the dialog exits the view.
             */
            _this._afterExit = new rxjs.Subject();
            return _this;
        }
        /**
         * @return {?}
         */
        MdcDialogContainer.prototype.closed = /**
         * @return {?}
         */
        function () {
            this._afterExit.next();
        };
        /**
         * Attach a ComponentPortal as content to this dialog container.
         * @param portal Portal to be attached as the dialog content.
         */
        /**
         * Attach a ComponentPortal as content to this dialog container.
         * @template T
         * @param {?} portal Portal to be attached as the dialog content.
         * @return {?}
         */
        MdcDialogContainer.prototype.attachComponentPortal = /**
         * Attach a ComponentPortal as content to this dialog container.
         * @template T
         * @param {?} portal Portal to be attached as the dialog content.
         * @return {?}
         */
        function (portal) {
            return this._portalOutlet.attachComponentPortal(portal);
        };
        MdcDialogContainer.decorators = [
            { type: core.Component, args: [{selector: 'mdc-dialog-container',
                        template: '<ng-template cdkPortalOutlet></ng-template>',
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcDialogContainer.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] }
        ]; };
        MdcDialogContainer.propDecorators = {
            _portalOutlet: [{ type: core.ViewChild, args: [CdkPortalOutlet,] }]
        };
        return MdcDialogContainer;
    }(BasePortalOutlet));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcDialogSurface = /** @class */ (function () {
        function MdcDialogSurface(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcDialogSurface.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcDialogSurface], mdc-dialog-surface',
                        exportAs: 'mdcDialogSurface'
                    },] },
        ];
        /** @nocollapse */
        MdcDialogSurface.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcDialogSurface.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-dialog__surface',] }]
        };
        return MdcDialogSurface;
    }());
    var MdcDialogHeader = /** @class */ (function () {
        function MdcDialogHeader(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcDialogHeader.decorators = [
            { type: core.Component, args: [{selector: '[mdcDialogHeader], mdc-dialog-header',
                        exportAs: 'mdcDialogHeader',
                        template: "\n  <ng-content></ng-content>\n  <h2 class=\"mdc-dialog__header__title\" *ngIf=\"title\">{{title}}</h2>\n  "
                    },] },
        ];
        /** @nocollapse */
        MdcDialogHeader.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcDialogHeader.propDecorators = {
            title: [{ type: core.Input }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-dialog__header',] }]
        };
        return MdcDialogHeader;
    }());
    var MdcDialogHeaderTitle = /** @class */ (function () {
        function MdcDialogHeaderTitle(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcDialogHeaderTitle.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcDialogHeaderTitle], mdc-dialog-header-title',
                        exportAs: 'mdcDialogHeaderTitle'
                    },] },
        ];
        /** @nocollapse */
        MdcDialogHeaderTitle.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcDialogHeaderTitle.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-dialog__header__title',] }]
        };
        return MdcDialogHeaderTitle;
    }());
    var MdcDialogBody = /** @class */ (function () {
        function MdcDialogBody(elementRef) {
            this.elementRef = elementRef;
            this.scrollable = false;
            this.isHostClass = true;
        }
        Object.defineProperty(MdcDialogBody.prototype, "classScrollable", {
            get: /**
             * @return {?}
             */
            function () {
                return this.scrollable ? 'mdc-dialog__body--scrollable' : '';
            },
            enumerable: true,
            configurable: true
        });
        MdcDialogBody.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcDialogBody], mdc-dialog-body',
                        exportAs: 'mdcDialogBody'
                    },] },
        ];
        /** @nocollapse */
        MdcDialogBody.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcDialogBody.propDecorators = {
            scrollable: [{ type: core.Input }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-dialog__body',] }],
            classScrollable: [{ type: core.HostBinding, args: ['class.mdc-dialog__body--scrollable',] }]
        };
        return MdcDialogBody;
    }());
    var MdcDialogFooter = /** @class */ (function () {
        function MdcDialogFooter(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcDialogFooter.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcDialogFooter], mdc-dialog-footer',
                        exportAs: 'mdcDialogFooter'
                    },] },
        ];
        /** @nocollapse */
        MdcDialogFooter.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcDialogFooter.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-dialog__footer',] }]
        };
        return MdcDialogFooter;
    }());
    var MdcDialogButton = /** @class */ (function (_super) {
        __extends(MdcDialogButton, _super);
        function MdcDialogButton() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.isFooterButton = true;
            return _this;
        }
        Object.defineProperty(MdcDialogButton.prototype, "classAction", {
            get: /**
             * @return {?}
             */
            function () {
                return this.action ? 'mdc-dialog__action' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcDialogButton.prototype, "classAccept", {
            get: /**
             * @return {?}
             */
            function () {
                return this.accept ? 'mdc-dialog__footer__button--accept' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcDialogButton.prototype, "classCancel", {
            get: /**
             * @return {?}
             */
            function () {
                return this.cancel ? 'mdc-dialog__footer__button--cancel' : '';
            },
            enumerable: true,
            configurable: true
        });
        MdcDialogButton.decorators = [
            { type: core.Directive, args: [{
                        selector: 'button[mdc-dialog-button], a[mdc-dialog-button]',
                        providers: [MdcRipple]
                    },] },
        ];
        MdcDialogButton.propDecorators = {
            accept: [{ type: core.Input }],
            cancel: [{ type: core.Input }],
            action: [{ type: core.Input }],
            isFooterButton: [{ type: core.HostBinding, args: ['class.mdc-dialog__footer__button',] }],
            classAction: [{ type: core.HostBinding, args: ['class.mdc-dialog__action',] }],
            classAccept: [{ type: core.HostBinding, args: ['class.mdc-dialog__footer__button--accept',] }],
            classCancel: [{ type: core.HostBinding, args: ['class.mdc-dialog__footer__button--cancel',] }]
        };
        return MdcDialogButton;
    }(MdcButton));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Injection token for the Dialog's Data.
     */
    var /** @type {?} */ DIALOG_DATA = new core.InjectionToken('DialogData');
    /**
     * Injection token for the MdcDialogRef constructor.
     */
    var /** @type {?} */ DIALOG_REF = new core.InjectionToken('DialogRef');
    /**
     * Injection token for the MdcDialogConfig.
     */
    var /** @type {?} */ DIALOG_CONFIG = new core.InjectionToken('DialogConfig');
    /**
     * Injection token for the Dialog's MdcDialogContainer component.
     */
    var /** @type {?} */ DIALOG_CONTAINER = new core.InjectionToken('DialogContainer');

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Unique id for the created dialog.
     */
    var /** @type {?} */ uniqueId = 0;
    /**
     * Reference to a dialog dispatched from the MdcDialog service.
     * @template T, R
     */
    var   /**
     * Reference to a dialog dispatched from the MdcDialog service.
     * @template T, R
     */
    MdcDialogRef = /** @class */ (function () {
        function MdcDialogRef(_containerInstance, id) {
            if (id === void 0) { id = "mdc-dialog-" + uniqueId++; }
            var _this = this;
            this._containerInstance = _containerInstance;
            this.id = id;
            this.afterClosed().subscribe(function () {
                _this._containerInstance.detach();
                _this._containerInstance.dispose();
                _this.componentInstance = /** @type {?} */ ((null));
            });
        }
        /**
         * Close the dialog.
         * @param dialogResult Optional result to return to the dialog opener.
         */
        /**
         * Close the dialog.
         * @param {?=} dialogResult Optional result to return to the dialog opener.
         * @return {?}
         */
        MdcDialogRef.prototype.close = /**
         * Close the dialog.
         * @param {?=} dialogResult Optional result to return to the dialog opener.
         * @return {?}
         */
        function (dialogResult) {
            this._result = dialogResult;
            this._containerInstance.closed();
        };
        Object.defineProperty(MdcDialogRef.prototype, "config", {
            get: /**
             * @return {?}
             */
            function () {
                return this._containerInstance.config;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcDialogRef.prototype, "data", {
            get: /**
             * @return {?}
             */
            function () {
                return this._containerInstance.config.data;
            },
            enumerable: true,
            configurable: true
        });
        /** Gets an observable that is notified when the dialog is finished closing. */
        /**
         * Gets an observable that is notified when the dialog is finished closing.
         * @return {?}
         */
        MdcDialogRef.prototype.afterClosed = /**
         * Gets an observable that is notified when the dialog is finished closing.
         * @return {?}
         */
        function () {
            var _this = this;
            return this._containerInstance._afterExit.pipe(operators.map(function () { return _this._result; }));
        };
        return MdcDialogRef;
    }());

    function _classCallCheck$6(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$6(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$6(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$6(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$6(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$6(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$6(subClass, superClass);
    }

    function _getPrototypeOf$6(o) {
      _getPrototypeOf$6 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$6(o);
    }

    function _setPrototypeOf$6(o, p) {
      _setPrototypeOf$6 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$6(o, p);
    }

    function _assertThisInitialized$6(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$6(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$6(self);
    }

    function _superPropBase$4(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$6(object);
        if (object === null) break;
      }

      return object;
    }

    function _get$4(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$4 = Reflect.get;
      } else {
        _get$4 = function _get(target, property, receiver) {
          var base = _superPropBase$4(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get$4(target, property, receiver || target);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @template A
     */
    var MDCFoundation$5 =
    /*#__PURE__*/
    function () {
      _createClass$6(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$6(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$6(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$5 =
    /*#__PURE__*/
    function () {
      _createClass$6(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$5());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$6(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$6(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Ripple. Provides an interface for managing
     * - classes
     * - dom
     * - CSS variables
     * - position
     * - dimensions
     * - scroll position
     * - event handlers
     * - unbounded, active and disabled states
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCRippleAdapter$5 =
    /*#__PURE__*/
    function () {
      function MDCRippleAdapter() {
        _classCallCheck$6(this, MDCRippleAdapter);
      }

      _createClass$6(MDCRippleAdapter, [{
        key: "browserSupportsCssVars",

        /** @return {boolean} */
        value: function browserSupportsCssVars() {}
        /** @return {boolean} */

      }, {
        key: "isUnbounded",
        value: function isUnbounded() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceActive",
        value: function isSurfaceActive() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceDisabled",
        value: function isSurfaceDisabled() {}
        /** @param {string} className */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @param {!EventTarget} target */

      }, {
        key: "containsEventTarget",
        value: function containsEventTarget(target) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerDocumentInteractionHandler",
        value: function registerDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterDocumentInteractionHandler",
        value: function deregisterDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /**
         * @param {string} varName
         * @param {?number|string} value
         */

      }, {
        key: "updateCssVariable",
        value: function updateCssVariable(varName, value) {}
        /** @return {!ClientRect} */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}
        /** @return {{x: number, y: number}} */

      }, {
        key: "getWindowPageOffset",
        value: function getWindowPageOffset() {}
      }]);

      return MDCRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var cssClasses$5 = {
      // Ripple is a special case where the "root" component is really a "mixin" of sorts,
      // given that it's an 'upgrade' to an existing component. That being said it is the root
      // CSS class that all other CSS classes derive from.
      ROOT: 'mdc-ripple-upgraded',
      UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
      BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
      FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
      FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
    };
    var strings$5 = {
      VAR_LEFT: '--mdc-ripple-left',
      VAR_TOP: '--mdc-ripple-top',
      VAR_FG_SIZE: '--mdc-ripple-fg-size',
      VAR_FG_SCALE: '--mdc-ripple-fg-scale',
      VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
      VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
    };
    var numbers$5 = {
      PADDING: 10,
      INITIAL_ORIGIN_SCALE: 0.6,
      DEACTIVATION_TIMEOUT_MS: 225,
      // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
      FG_DEACTIVATION_MS: 150,
      // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
      TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

    };

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
     * @private {boolean|undefined}
     */
    var supportsCssVariables_$5;
    /**
     * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
     * @private {boolean|undefined}
     */

    var supportsPassive_$5;
    /**
     * @param {!Window} windowObj
     * @return {boolean}
     */

    function detectEdgePseudoVarBug$5(windowObj) {
      // Detect versions of Edge with buggy var() support
      // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
      var document = windowObj.document;
      var node = document.createElement('div');
      node.className = 'mdc-ripple-surface--test-edge-var-bug';
      document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
      // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
      // but Firefox is known to support CSS custom properties correctly.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

      var computedStyle = windowObj.getComputedStyle(node);
      var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
      node.remove();
      return hasPseudoVarBug;
    }
    /**
     * @param {!Window} windowObj
     * @param {boolean=} forceRefresh
     * @return {boolean|undefined}
     */


    function supportsCssVariables$5(windowObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var supportsCssVariables = supportsCssVariables_$5;

      if (typeof supportsCssVariables_$5 === 'boolean' && !forceRefresh) {
        return supportsCssVariables;
      }

      var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

      if (!supportsFunctionPresent) {
        return;
      }

      var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
      // See: README section on Safari

      var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

      if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVariables = !detectEdgePseudoVarBug$5(windowObj);
      } else {
        supportsCssVariables = false;
      }

      if (!forceRefresh) {
        supportsCssVariables_$5 = supportsCssVariables;
      }

      return supportsCssVariables;
    } //

    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|{passive: boolean}}
     */


    function applyPassive$5() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_$5 === undefined || forceRefresh) {
        var isSupported = false;

        try {
          globalObj.document.addEventListener('test', null, {
            get passive() {
              isSupported = true;
            }

          });
        } catch (e) {}

        supportsPassive_$5 = isSupported;
      }

      return supportsPassive_$5 ? {
        passive: true
      } : false;
    }
    /**
     * @param {!Object} HTMLElementPrototype
     * @return {!Array<string>}
     */


    function getMatchesProperty$5(HTMLElementPrototype) {
      return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(function (p) {
        return p in HTMLElementPrototype;
      }).pop();
    }
    /**
     * @param {!Event} ev
     * @param {{x: number, y: number}} pageOffset
     * @param {!ClientRect} clientRect
     * @return {{x: number, y: number}}
     */


    function getNormalizedEventCoords$5(ev, pageOffset, clientRect) {
      var x = pageOffset.x,
          y = pageOffset.y;
      var documentX = x + clientRect.left;
      var documentY = y + clientRect.top;
      var normalizedX;
      var normalizedY; // Determine touch point relative to the ripple container.

      if (ev.type === 'touchstart') {
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
      } else {
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
      }

      return {
        x: normalizedX,
        y: normalizedY
      };
    }

    var ACTIVATION_EVENT_TYPES$5 = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

    var POINTER_DEACTIVATION_EVENT_TYPES$5 = ['touchend', 'pointerup', 'mouseup']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

    /** @type {!Array<!EventTarget>} */

    var activatedTargets$5 = [];
    /**
     * @extends {MDCFoundation<!MDCRippleAdapter>}
     */

    var MDCRippleFoundation$5 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$6(MDCRippleFoundation, _MDCFoundation);

      _createClass$6(MDCRippleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$5;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$5;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers$5;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            browserSupportsCssVars: function browserSupportsCssVars()
            /* boolean - cached */
            {},
            isUnbounded: function isUnbounded()
            /* boolean */
            {},
            isSurfaceActive: function isSurfaceActive()
            /* boolean */
            {},
            isSurfaceDisabled: function isSurfaceDisabled()
            /* boolean */
            {},
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            containsEventTarget: function containsEventTarget()
            /* target: !EventTarget */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            updateCssVariable: function updateCssVariable()
            /* varName: string, value: string */
            {},
            computeBoundingRect: function computeBoundingRect()
            /* ClientRect */
            {},
            getWindowPageOffset: function getWindowPageOffset()
            /* {x: number, y: number} */
            {}
          };
        }
      }]);

      function MDCRippleFoundation(adapter) {
        var _this;

        _classCallCheck$6(this, MDCRippleFoundation);

        _this = _possibleConstructorReturn$6(this, _getPrototypeOf$6(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
        /** @private {number} */

        _this.layoutFrame_ = 0;
        /** @private {!ClientRect} */

        _this.frame_ =
        /** @type {!ClientRect} */
        {
          width: 0,
          height: 0
        };
        /** @private {!ActivationStateType} */

        _this.activationState_ = _this.defaultActivationState_();
        /** @private {number} */

        _this.initialSize_ = 0;
        /** @private {number} */

        _this.maxRadius_ = 0;
        /** @private {function(!Event)} */

        _this.activateHandler_ = function (e) {
          return _this.activate_(e);
        };
        /** @private {function(!Event)} */


        _this.deactivateHandler_ = function (e) {
          return _this.deactivate_(e);
        };
        /** @private {function(?Event=)} */


        _this.focusHandler_ = function () {
          return _this.handleFocus();
        };
        /** @private {function(?Event=)} */


        _this.blurHandler_ = function () {
          return _this.handleBlur();
        };
        /** @private {!Function} */


        _this.resizeHandler_ = function () {
          return _this.layout();
        };
        /** @private {{left: number, top:number}} */


        _this.unboundedCoords_ = {
          left: 0,
          top: 0
        };
        /** @private {number} */

        _this.fgScale_ = 0;
        /** @private {number} */

        _this.activationTimer_ = 0;
        /** @private {number} */

        _this.fgDeactivationRemovalTimer_ = 0;
        /** @private {boolean} */

        _this.activationAnimationHasEnded_ = false;
        /** @private {!Function} */

        _this.activationTimerCallback_ = function () {
          _this.activationAnimationHasEnded_ = true;

          _this.runDeactivationUXLogicIfReady_();
        };
        /** @private {?Event} */


        _this.previousActivationEvent_ = null;
        return _this;
      }
      /**
       * We compute this property so that we are not querying information about the client
       * until the point in time where the foundation requests it. This prevents scenarios where
       * client-side feature-detection may happen too early, such as when components are rendered on the server
       * and then initialized at mount time on the client.
       * @return {boolean}
       * @private
       */


      _createClass$6(MDCRippleFoundation, [{
        key: "isSupported_",
        value: function isSupported_() {
          return this.adapter_.browserSupportsCssVars();
        }
        /**
         * @return {!ActivationStateType}
         */

      }, {
        key: "defaultActivationState_",
        value: function defaultActivationState_() {
          return {
            isActivated: false,
            hasDeactivationUXRun: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
            activationEvent: null,
            isProgrammatic: false
          };
        }
        /** @override */

      }, {
        key: "init",
        value: function init() {
          var _this2 = this;

          if (!this.isSupported_()) {
            return;
          }

          this.registerRootHandlers_();
          var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$.ROOT,
              UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
          requestAnimationFrame(function () {
            _this2.adapter_.addClass(ROOT);

            if (_this2.adapter_.isUnbounded()) {
              _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


              _this2.layoutInternal_();
            }
          });
        }
        /** @override */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          if (!this.isSupported_()) {
            return;
          }

          if (this.activationTimer_) {
            clearTimeout(this.activationTimer_);
            this.activationTimer_ = 0;
            var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
            this.adapter_.removeClass(FG_ACTIVATION);
          }

          this.deregisterRootHandlers_();
          this.deregisterDeactivationHandlers_();
          var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$2.ROOT,
              UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
          requestAnimationFrame(function () {
            _this3.adapter_.removeClass(ROOT);

            _this3.adapter_.removeClass(UNBOUNDED);

            _this3.removeCssVars_();
          });
        }
        /** @private */

      }, {
        key: "registerRootHandlers_",
        value: function registerRootHandlers_() {
          var _this4 = this;

          ACTIVATION_EVENT_TYPES$5.forEach(function (type) {
            _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
          });
          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.registerResizeHandler(this.resizeHandler_);
          }
        }
        /**
         * @param {!Event} e
         * @private
         */

      }, {
        key: "registerDeactivationHandlers_",
        value: function registerDeactivationHandlers_(e) {
          var _this5 = this;

          if (e.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
          } else {
            POINTER_DEACTIVATION_EVENT_TYPES$5.forEach(function (type) {
              _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
            });
          }
        }
        /** @private */

      }, {
        key: "deregisterRootHandlers_",
        value: function deregisterRootHandlers_() {
          var _this6 = this;

          ACTIVATION_EVENT_TYPES$5.forEach(function (type) {
            _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
          });
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          }
        }
        /** @private */

      }, {
        key: "deregisterDeactivationHandlers_",
        value: function deregisterDeactivationHandlers_() {
          var _this7 = this;

          this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
          POINTER_DEACTIVATION_EVENT_TYPES$5.forEach(function (type) {
            _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
          });
        }
        /** @private */

      }, {
        key: "removeCssVars_",
        value: function removeCssVars_() {
          var _this8 = this;

          var strings$$1 = MDCRippleFoundation.strings;
          Object.keys(strings$$1).forEach(function (k) {
            if (k.indexOf('VAR_') === 0) {
              _this8.adapter_.updateCssVariable(strings$$1[k], null);
            }
          });
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "activate_",
        value: function activate_(e) {
          var _this9 = this;

          if (this.adapter_.isSurfaceDisabled()) {
            return;
          }

          var activationState = this.activationState_;

          if (activationState.isActivated) {
            return;
          } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


          var previousActivationEvent = this.previousActivationEvent_;
          var isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;

          if (isSameInteraction) {
            return;
          }

          activationState.isActivated = true;
          activationState.isProgrammatic = e === null;
          activationState.activationEvent = e;
          activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';
          var hasActivatedChild = e && activatedTargets$5.length > 0 && activatedTargets$5.some(function (target) {
            return _this9.adapter_.containsEventTarget(target);
          });

          if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
          }

          if (e) {
            activatedTargets$5.push(
            /** @type {!EventTarget} */
            e.target);
            this.registerDeactivationHandlers_(e);
          }

          activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

          if (activationState.wasElementMadeActive) {
            this.animateActivation_();
          }

          requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets$5 = [];

            if (!activationState.wasElementMadeActive && (e.key === ' ' || e.keyCode === 32)) {
              // If space was pressed, try again within an rAF call to detect :active, because different UAs report
              // active states inconsistently when they're called within event handling code:
              // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
              // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
              // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
              // variable is set within a rAF callback for a submit button interaction (#2241).
              activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

              if (activationState.wasElementMadeActive) {
                _this9.animateActivation_();
              }
            }

            if (!activationState.wasElementMadeActive) {
              // Reset activation state immediately if element was not made active.
              _this9.activationState_ = _this9.defaultActivationState_();
            }
          });
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "checkElementMadeActive_",
        value: function checkElementMadeActive_(e) {
          return e && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
        }
        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: "activate",
        value: function activate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          this.activate_(event);
        }
        /** @private */

      }, {
        key: "animateActivation_",
        value: function animateActivation_() {
          var _this10 = this;

          var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
              VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
              VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
          var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
              FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
              FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
          var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
          this.layoutInternal_();
          var translateStart = '';
          var translateEnd = '';

          if (!this.adapter_.isUnbounded()) {
            var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
                startPoint = _this$getFgTranslatio.startPoint,
                endPoint = _this$getFgTranslatio.endPoint;

            translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
            translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
          }

          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

          clearTimeout(this.activationTimer_);
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.rmBoundedActivationClasses_();
          this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

          this.adapter_.computeBoundingRect();
          this.adapter_.addClass(FG_ACTIVATION);
          this.activationTimer_ = setTimeout(function () {
            return _this10.activationTimerCallback_();
          }, DEACTIVATION_TIMEOUT_MS);
        }
        /**
         * @private
         * @return {{startPoint: PointType, endPoint: PointType}}
         */

      }, {
        key: "getFgTranslationCoordinates_",
        value: function getFgTranslationCoordinates_() {
          var _this$activationState = this.activationState_,
              activationEvent = _this$activationState.activationEvent,
              wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
          var startPoint;

          if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords$5(
            /** @type {!Event} */
            activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
          } else {
            startPoint = {
              x: this.frame_.width / 2,
              y: this.frame_.height / 2
            };
          } // Center the element around the start point.


          startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
          };
          var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
          };
          return {
            startPoint: startPoint,
            endPoint: endPoint
          };
        }
        /** @private */

      }, {
        key: "runDeactivationUXLogicIfReady_",
        value: function runDeactivationUXLogicIfReady_() {
          var _this11 = this;

          // This method is called both when a pointing device is released, and when the activation animation ends.
          // The deactivation animation should only run after both of those occur.
          var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
          var _this$activationState2 = this.activationState_,
              hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
              isActivated = _this$activationState2.isActivated;
          var activationHasEnded = hasDeactivationUXRun || !isActivated;

          if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
              _this11.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers$5.FG_DEACTIVATION_MS);
          }
        }
        /** @private */

      }, {
        key: "rmBoundedActivationClasses_",
        value: function rmBoundedActivationClasses_() {
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
          this.adapter_.removeClass(FG_ACTIVATION);
          this.activationAnimationHasEnded_ = false;
          this.adapter_.computeBoundingRect();
        }
      }, {
        key: "resetActivationState_",
        value: function resetActivationState_() {
          var _this12 = this;

          this.previousActivationEvent_ = this.activationState_.activationEvent;
          this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
          // Store the previous event until it's safe to assume that subsequent events are for new interactions.

          setTimeout(function () {
            return _this12.previousActivationEvent_ = null;
          }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "deactivate_",
        value: function deactivate_(e) {
          var _this13 = this;

          var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

          if (!activationState.isActivated) {
            return;
          }

          var state =
          /** @type {!ActivationStateType} */
          Object.assign({}, activationState);

          if (activationState.isProgrammatic) {
            var evtObject = null;
            requestAnimationFrame(function () {
              return _this13.animateDeactivation_(evtObject, state);
            });
            this.resetActivationState_();
          } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
              _this13.activationState_.hasDeactivationUXRun = true;

              _this13.animateDeactivation_(e, state);

              _this13.resetActivationState_();
            });
          }
        }
        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          this.deactivate_(event);
        }
        /**
         * @param {Event} e
         * @param {!ActivationStateType} options
         * @private
         */

      }, {
        key: "animateDeactivation_",
        value: function animateDeactivation_(e, _ref) {
          var wasActivatedByPointer = _ref.wasActivatedByPointer,
              wasElementMadeActive = _ref.wasElementMadeActive;

          if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this14 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }

          this.layoutFrame_ = requestAnimationFrame(function () {
            _this14.layoutInternal_();

            _this14.layoutFrame_ = 0;
          });
        }
        /** @private */

      }, {
        key: "layoutInternal_",
        value: function layoutInternal_() {
          var _this15 = this;

          this.frame_ = this.adapter_.computeBoundingRect();
          var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
          // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
          // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
          // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
          // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
          // `overflow: hidden`.

          var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
          };

          this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

          this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;
          this.fgScale_ = this.maxRadius_ / this.initialSize_;
          this.updateLayoutCssVars_();
        }
        /** @private */

      }, {
        key: "updateLayoutCssVars_",
        value: function updateLayoutCssVars_() {
          var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
              VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
              VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
              VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
              VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
          this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
          this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

          if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
              left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
              top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };
            this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
            this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
          }
        }
        /** @param {boolean} unbounded */

      }, {
        key: "setUnbounded",
        value: function setUnbounded(unbounded) {
          var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

          if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
          } else {
            this.adapter_.removeClass(UNBOUNDED);
          }
        }
      }, {
        key: "handleFocus",
        value: function handleFocus() {
          var _this16 = this;

          requestAnimationFrame(function () {
            return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }, {
        key: "handleBlur",
        value: function handleBlur() {
          var _this17 = this;

          requestAnimationFrame(function () {
            return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }]);

      return MDCRippleFoundation;
    }(MDCFoundation$5);

    /**
     * @extends MDCComponent<!MDCRippleFoundation>
     */

    var MDCRipple$5 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$6(MDCRipple, _MDCComponent);

      /** @param {...?} args */
      function MDCRipple() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$6(this, MDCRipple);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$6(this, (_getPrototypeOf2 = _getPrototypeOf$6(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {boolean} */

        _this.disabled = false;
        /** @private {boolean} */

        _this.unbounded_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @param {{isUnbounded: (boolean|undefined)}=} options
       * @return {!MDCRipple}
       */


      _createClass$6(MDCRipple, [{
        key: "setUnbounded_",

        /**
         * Closure Compiler throws an access control error when directly accessing a
         * protected or private property inside a getter/setter, like unbounded above.
         * By accessing the protected property inside a method, we solve that problem.
         * That's why this function exists.
         * @private
         */
        value: function setUnbounded_() {
          this.foundation_.setUnbounded(this.unbounded_);
        }
      }, {
        key: "activate",
        value: function activate() {
          this.foundation_.activate();
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
        /**
         * @return {!MDCRippleFoundation}
         * @override
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          return new MDCRippleFoundation$5(MDCRipple.createAdapter(this));
        }
        /** @override */

      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
        }
      }, {
        key: "unbounded",

        /** @return {boolean} */
        get: function get() {
          return this.unbounded_;
        }
        /** @param {boolean} unbounded */
        ,
        set: function set(unbounded) {
          this.unbounded_ = Boolean(unbounded);
          this.setUnbounded_();
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref$isUnbounded = _ref.isUnbounded,
              isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

          var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

          if (isUnbounded !== undefined) {
            ripple.unbounded =
            /** @type {boolean} */
            isUnbounded;
          }

          return ripple;
        }
        /**
         * @param {!RippleCapableSurface} instance
         * @return {!MDCRippleAdapter}
         */

      }, {
        key: "createAdapter",
        value: function createAdapter(instance) {
          var MATCHES = getMatchesProperty$5(HTMLElement.prototype);
          return {
            browserSupportsCssVars: function browserSupportsCssVars() {
              return supportsCssVariables$5(window);
            },
            isUnbounded: function isUnbounded() {
              return instance.unbounded;
            },
            isSurfaceActive: function isSurfaceActive() {
              return instance.root_[MATCHES](':active');
            },
            isSurfaceDisabled: function isSurfaceDisabled() {
              return instance.disabled;
            },
            addClass: function addClass(className) {
              return instance.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return instance.root_.classList.remove(className);
            },
            containsEventTarget: function containsEventTarget(target) {
              return instance.root_.contains(target);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return instance.root_.addEventListener(evtType, handler, applyPassive$5());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return instance.root_.removeEventListener(evtType, handler, applyPassive$5());
            },
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.addEventListener(evtType, handler, applyPassive$5());
            },
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.removeEventListener(evtType, handler, applyPassive$5());
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return instance.root_.style.setProperty(varName, value);
            },
            computeBoundingRect: function computeBoundingRect() {
              return instance.root_.getBoundingClientRect();
            },
            getWindowPageOffset: function getWindowPageOffset() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            }
          };
        }
      }]);

      return MDCRipple;
    }(MDCComponent$5);

    /**
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var cssClasses$1$5 = {
      ROOT: 'mdc-dialog',
      OPEN: 'mdc-dialog--open',
      ANIMATING: 'mdc-dialog--animating',
      BACKDROP: 'mdc-dialog__backdrop',
      SCROLL_LOCK: 'mdc-dialog-scroll-lock',
      ACCEPT_BTN: 'mdc-dialog__footer__button--accept',
      CANCEL_BTN: 'mdc-dialog__footer__button--cancel'
    };
    var strings$1$5 = {
      OPEN_DIALOG_SELECTOR: '.mdc-dialog--open',
      DIALOG_SURFACE_SELECTOR: '.mdc-dialog__surface',
      ACCEPT_SELECTOR: '.mdc-dialog__footer__button--accept',
      ACCEPT_EVENT: 'MDCDialog:accept',
      CANCEL_EVENT: 'MDCDialog:cancel'
    };

    var MDCDialogFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$6(MDCDialogFoundation, _MDCFoundation);

      _createClass$6(MDCDialogFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$1$5;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$1$5;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            addBodyClass: function addBodyClass()
            /* className: string */
            {},
            removeBodyClass: function removeBodyClass()
            /* className: string */
            {},
            eventTargetHasClass: function eventTargetHasClass() {
              return (
                /* target: EventTarget, className: string */

                /* boolean */
                false
              );
            },
            registerInteractionHandler: function registerInteractionHandler()
            /* evt: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* evt: string, handler: EventListener */
            {},
            registerSurfaceInteractionHandler: function registerSurfaceInteractionHandler()
            /* evt: string, handler: EventListener */
            {},
            deregisterSurfaceInteractionHandler: function deregisterSurfaceInteractionHandler()
            /* evt: string, handler: EventListener */
            {},
            registerDocumentKeydownHandler: function registerDocumentKeydownHandler()
            /* handler: EventListener */
            {},
            deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler()
            /* handler: EventListener */
            {},
            registerTransitionEndHandler: function registerTransitionEndHandler()
            /* handler: EventListener */
            {},
            deregisterTransitionEndHandler: function deregisterTransitionEndHandler()
            /* handler: EventListener */
            {},
            notifyAccept: function notifyAccept() {},
            notifyCancel: function notifyCancel() {},
            trapFocusOnSurface: function trapFocusOnSurface() {},
            untrapFocusOnSurface: function untrapFocusOnSurface() {},
            isDialog: function isDialog() {
              return (
                /* el: Element */

                /* boolean */
                false
              );
            }
          };
        }
      }]);

      function MDCDialogFoundation(adapter) {
        var _this;

        _classCallCheck$6(this, MDCDialogFoundation);

        _this = _possibleConstructorReturn$6(this, _getPrototypeOf$6(MDCDialogFoundation).call(this, Object.assign(MDCDialogFoundation.defaultAdapter, adapter)));
        _this.isOpen_ = false;

        _this.componentClickHandler_ = function (evt) {
          if (_this.adapter_.eventTargetHasClass(evt.target, cssClasses$1$5.BACKDROP)) {
            _this.cancel(true);
          }
        };

        _this.dialogClickHandler_ = function (evt) {
          return _this.handleDialogClick_(evt);
        };

        _this.documentKeydownHandler_ = function (evt) {
          if (evt.key && evt.key === 'Escape' || evt.keyCode === 27) {
            _this.cancel(true);
          }
        };

        _this.transitionEndHandler_ = function (evt) {
          return _this.handleTransitionEnd_(evt);
        };

        return _this;
      }

      _createClass$6(MDCDialogFoundation, [{
        key: "destroy",
        value: function destroy() {
          // Ensure that dialog is cleaned up when destroyed
          if (this.isOpen_) {
            this.adapter_.deregisterSurfaceInteractionHandler('click', this.dialogClickHandler_);
            this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
            this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
            this.adapter_.untrapFocusOnSurface();
            this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
            this.adapter_.removeClass(MDCDialogFoundation.cssClasses.ANIMATING);
            this.adapter_.removeClass(MDCDialogFoundation.cssClasses.OPEN);
            this.enableScroll_();
          }
        }
      }, {
        key: "open",
        value: function open() {
          this.isOpen_ = true;
          this.disableScroll_();
          this.adapter_.registerDocumentKeydownHandler(this.documentKeydownHandler_);
          this.adapter_.registerSurfaceInteractionHandler('click', this.dialogClickHandler_);
          this.adapter_.registerInteractionHandler('click', this.componentClickHandler_);
          this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
          this.adapter_.addClass(MDCDialogFoundation.cssClasses.ANIMATING);
          this.adapter_.addClass(MDCDialogFoundation.cssClasses.OPEN);
        }
      }, {
        key: "close",
        value: function close() {
          this.isOpen_ = false;
          this.enableScroll_();
          this.adapter_.deregisterSurfaceInteractionHandler('click', this.dialogClickHandler_);
          this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
          this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
          this.adapter_.untrapFocusOnSurface();
          this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
          this.adapter_.addClass(MDCDialogFoundation.cssClasses.ANIMATING);
          this.adapter_.removeClass(MDCDialogFoundation.cssClasses.OPEN);
        }
      }, {
        key: "isOpen",
        value: function isOpen() {
          return this.isOpen_;
        }
      }, {
        key: "accept",
        value: function accept(shouldNotify) {
          if (shouldNotify) {
            this.adapter_.notifyAccept();
          }

          this.close();
        }
      }, {
        key: "cancel",
        value: function cancel(shouldNotify) {
          if (shouldNotify) {
            this.adapter_.notifyCancel();
          }

          this.close();
        }
      }, {
        key: "handleDialogClick_",
        value: function handleDialogClick_(evt) {
          var target = evt.target;

          if (this.adapter_.eventTargetHasClass(target, cssClasses$1$5.ACCEPT_BTN)) {
            this.accept(true);
          } else if (this.adapter_.eventTargetHasClass(target, cssClasses$1$5.CANCEL_BTN)) {
            this.cancel(true);
          }
        }
      }, {
        key: "handleTransitionEnd_",
        value: function handleTransitionEnd_(evt) {
          if (this.adapter_.isDialog(evt.target)) {
            this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
            this.adapter_.removeClass(MDCDialogFoundation.cssClasses.ANIMATING);

            if (this.isOpen_) {
              this.adapter_.trapFocusOnSurface();
            }
          }
        }
      }, {
        key: "disableScroll_",
        value: function disableScroll_() {
          this.adapter_.addBodyClass(cssClasses$1$5.SCROLL_LOCK);
        }
      }, {
        key: "enableScroll_",
        value: function enableScroll_() {
          this.adapter_.removeBodyClass(cssClasses$1$5.SCROLL_LOCK);
        }
      }]);

      return MDCDialogFoundation;
    }(MDCFoundation$5);

    var tabbable = function tabbable(el, options) {
      options = options || {};
      var elementDocument = el.ownerDocument || el;
      var basicTabbables = [];
      var orderedTabbables = []; // A node is "available" if
      // - it's computed style

      var isUnavailable = createIsUnavailable(elementDocument);
      var candidateSelectors = ['input', 'select', 'a[href]', 'textarea', 'button', '[tabindex]'];
      var candidates = el.querySelectorAll(candidateSelectors.join(','));

      if (options.includeContainer) {
        var matches = Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

        if (candidateSelectors.some(function (candidateSelector) {
          return matches.call(el, candidateSelector);
        })) {
          candidates = Array.prototype.slice.apply(candidates);
          candidates.unshift(el);
        }
      }

      var candidate, candidateIndexAttr, candidateIndex;

      for (var i = 0, l = candidates.length; i < l; i++) {
        candidate = candidates[i];
        candidateIndexAttr = parseInt(candidate.getAttribute('tabindex'), 10);
        candidateIndex = isNaN(candidateIndexAttr) ? candidate.tabIndex : candidateIndexAttr;

        if (candidateIndex < 0 || candidate.tagName === 'INPUT' && candidate.type === 'hidden' || candidate.disabled || isUnavailable(candidate, elementDocument)) {
          continue;
        }

        if (candidateIndex === 0) {
          basicTabbables.push(candidate);
        } else {
          orderedTabbables.push({
            index: i,
            tabIndex: candidateIndex,
            node: candidate
          });
        }
      }

      var tabbableNodes = orderedTabbables.sort(function (a, b) {
        return a.tabIndex === b.tabIndex ? a.index - b.index : a.tabIndex - b.tabIndex;
      }).map(function (a) {
        return a.node;
      });
      Array.prototype.push.apply(tabbableNodes, basicTabbables);
      return tabbableNodes;
    };

    function createIsUnavailable(elementDocument) {
      // Node cache must be refreshed on every check, in case
      // the content of the element has changed
      var isOffCache = []; // "off" means `display: none;`, as opposed to "hidden",
      // which means `visibility: hidden;`. getComputedStyle
      // accurately reflects visiblity in context but not
      // "off" state, so we need to recursively check parents.

      function isOff(node, nodeComputedStyle) {
        if (node === elementDocument.documentElement) return false; // Find the cached node (Array.prototype.find not available in IE9)

        for (var i = 0, length = isOffCache.length; i < length; i++) {
          if (isOffCache[i][0] === node) return isOffCache[i][1];
        }

        nodeComputedStyle = nodeComputedStyle || elementDocument.defaultView.getComputedStyle(node);
        var result = false;

        if (nodeComputedStyle.display === 'none') {
          result = true;
        } else if (node.parentNode) {
          result = isOff(node.parentNode);
        }

        isOffCache.push([node, result]);
        return result;
      }

      return function isUnavailable(node) {
        if (node === elementDocument.documentElement) return false;
        var computedStyle = elementDocument.defaultView.getComputedStyle(node);
        if (isOff(node, computedStyle)) return true;
        return computedStyle.visibility === 'hidden';
      };
    }

    var listeningFocusTrap = null;

    function focusTrap(element, userOptions) {
      var tabbableNodes = [];
      var firstTabbableNode = null;
      var lastTabbableNode = null;
      var nodeFocusedBeforeActivation = null;
      var active = false;
      var paused = false;
      var tabEvent = null;
      var container = typeof element === 'string' ? document.querySelector(element) : element;
      var config = userOptions || {};
      config.returnFocusOnDeactivate = userOptions && userOptions.returnFocusOnDeactivate !== undefined ? userOptions.returnFocusOnDeactivate : true;
      config.escapeDeactivates = userOptions && userOptions.escapeDeactivates !== undefined ? userOptions.escapeDeactivates : true;
      var trap = {
        activate: activate,
        deactivate: deactivate,
        pause: pause,
        unpause: unpause
      };
      return trap;

      function activate(activateOptions) {
        if (active) return;
        var defaultedActivateOptions = {
          onActivate: activateOptions && activateOptions.onActivate !== undefined ? activateOptions.onActivate : config.onActivate
        };
        active = true;
        paused = false;
        nodeFocusedBeforeActivation = document.activeElement;

        if (defaultedActivateOptions.onActivate) {
          defaultedActivateOptions.onActivate();
        }

        addListeners();
        return trap;
      }

      function deactivate(deactivateOptions) {
        if (!active) return;
        var defaultedDeactivateOptions = {
          returnFocus: deactivateOptions && deactivateOptions.returnFocus !== undefined ? deactivateOptions.returnFocus : config.returnFocusOnDeactivate,
          onDeactivate: deactivateOptions && deactivateOptions.onDeactivate !== undefined ? deactivateOptions.onDeactivate : config.onDeactivate
        };
        removeListeners();

        if (defaultedDeactivateOptions.onDeactivate) {
          defaultedDeactivateOptions.onDeactivate();
        }

        if (defaultedDeactivateOptions.returnFocus) {
          setTimeout(function () {
            tryFocus(nodeFocusedBeforeActivation);
          }, 0);
        }

        active = false;
        paused = false;
        return this;
      }

      function pause() {
        if (paused || !active) return;
        paused = true;
        removeListeners();
      }

      function unpause() {
        if (!paused || !active) return;
        paused = false;
        addListeners();
      }

      function addListeners() {
        if (!active) return; // There can be only one listening focus trap at a time

        if (listeningFocusTrap) {
          listeningFocusTrap.pause();
        }

        listeningFocusTrap = trap;
        updateTabbableNodes(); // Ensure that the focused element doesn't capture the event that caused the focus trap activation

        setTimeout(function () {
          tryFocus(firstFocusNode());
        }, 0);
        document.addEventListener('focus', checkFocus, true);
        document.addEventListener('click', checkClick, true);
        document.addEventListener('mousedown', checkPointerDown, true);
        document.addEventListener('touchstart', checkPointerDown, true);
        document.addEventListener('keydown', checkKey, true);
        return trap;
      }

      function removeListeners() {
        if (!active || listeningFocusTrap !== trap) return;
        document.removeEventListener('focus', checkFocus, true);
        document.removeEventListener('click', checkClick, true);
        document.removeEventListener('mousedown', checkPointerDown, true);
        document.removeEventListener('touchstart', checkPointerDown, true);
        document.removeEventListener('keydown', checkKey, true);
        listeningFocusTrap = null;
        return trap;
      }

      function getNodeForOption(optionName) {
        var optionValue = config[optionName];
        var node = optionValue;

        if (!optionValue) {
          return null;
        }

        if (typeof optionValue === 'string') {
          node = document.querySelector(optionValue);

          if (!node) {
            throw new Error('`' + optionName + '` refers to no known node');
          }
        }

        if (typeof optionValue === 'function') {
          node = optionValue();

          if (!node) {
            throw new Error('`' + optionName + '` did not return a node');
          }
        }

        return node;
      }

      function firstFocusNode() {
        var node;

        if (getNodeForOption('initialFocus') !== null) {
          node = getNodeForOption('initialFocus');
        } else if (container.contains(document.activeElement)) {
          node = document.activeElement;
        } else {
          node = tabbableNodes[0] || getNodeForOption('fallbackFocus');
        }

        if (!node) {
          throw new Error('You can\'t have a focus-trap without at least one focusable element');
        }

        return node;
      } // This needs to be done on mousedown and touchstart instead of click
      // so that it precedes the focus event


      function checkPointerDown(e) {
        if (config.clickOutsideDeactivates && !container.contains(e.target)) {
          deactivate({
            returnFocus: false
          });
        }
      }

      function checkClick(e) {
        if (config.clickOutsideDeactivates) return;
        if (container.contains(e.target)) return;
        e.preventDefault();
        e.stopImmediatePropagation();
      }

      function checkFocus(e) {
        if (container.contains(e.target)) return;
        e.preventDefault();
        e.stopImmediatePropagation(); // Checking for a blur method here resolves a Firefox issue (#15)

        if (typeof e.target.blur === 'function') e.target.blur();

        if (tabEvent) {
          readjustFocus(tabEvent);
        }
      }

      function checkKey(e) {
        if (e.key === 'Tab' || e.keyCode === 9) {
          handleTab(e);
        }

        if (config.escapeDeactivates !== false && isEscapeEvent(e)) {
          deactivate();
        }
      }

      function handleTab(e) {
        updateTabbableNodes();

        if (e.target.hasAttribute('tabindex') && Number(e.target.getAttribute('tabindex')) < 0) {
          return tabEvent = e;
        }

        e.preventDefault();
        var currentFocusIndex = tabbableNodes.indexOf(e.target);

        if (e.shiftKey) {
          if (e.target === firstTabbableNode || tabbableNodes.indexOf(e.target) === -1) {
            return tryFocus(lastTabbableNode);
          }

          return tryFocus(tabbableNodes[currentFocusIndex - 1]);
        }

        if (e.target === lastTabbableNode) return tryFocus(firstTabbableNode);
        tryFocus(tabbableNodes[currentFocusIndex + 1]);
      }

      function updateTabbableNodes() {
        tabbableNodes = tabbable(container);
        firstTabbableNode = tabbableNodes[0];
        lastTabbableNode = tabbableNodes[tabbableNodes.length - 1];
      }

      function readjustFocus(e) {
        if (e.shiftKey) return tryFocus(lastTabbableNode);
        tryFocus(firstTabbableNode);
      }
    }

    function isEscapeEvent(e) {
      return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;
    }

    function tryFocus(node) {
      if (!node || !node.focus) return;
      if (node === document.activeElement) return;
      node.focus();

      if (node.tagName.toLowerCase() === 'input') {
        node.select();
      }
    }

    var focusTrap_1 = focusTrap;

    /**
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    function createFocusTrapInstance(surfaceEl, acceptButtonEl) {
      var focusTrapFactory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : focusTrap_1;
      return focusTrapFactory(surfaceEl, {
        initialFocus: acceptButtonEl,
        clickOutsideDeactivates: true
      });
    }

    var MDCDialog =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$6(MDCDialog, _MDCComponent);

      function MDCDialog() {
        _classCallCheck$6(this, MDCDialog);

        return _possibleConstructorReturn$6(this, _getPrototypeOf$6(MDCDialog).apply(this, arguments));
      }

      _createClass$6(MDCDialog, [{
        key: "initialize",
        value: function initialize() {
          this.focusTrap_ = createFocusTrapInstance(this.dialogSurface_, this.acceptButton_);
          this.footerBtnRipples_ = [];
          var footerBtns = this.root_.querySelectorAll('.mdc-dialog__footer__button');

          for (var i = 0, footerBtn; footerBtn = footerBtns[i]; i++) {
            this.footerBtnRipples_.push(new MDCRipple$5(footerBtn));
          }
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.footerBtnRipples_.forEach(function (ripple) {
            return ripple.destroy();
          });

          _get$4(_getPrototypeOf$6(MDCDialog.prototype), "destroy", this).call(this);
        }
      }, {
        key: "show",
        value: function show() {
          this.foundation_.open();
        }
      }, {
        key: "close",
        value: function close() {
          this.foundation_.close();
        }
      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCDialogFoundation({
            addClass: function addClass(className) {
              return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this.root_.classList.remove(className);
            },
            addBodyClass: function addBodyClass(className) {
              return document.body.classList.add(className);
            },
            removeBodyClass: function removeBodyClass(className) {
              return document.body.classList.remove(className);
            },
            eventTargetHasClass: function eventTargetHasClass(target, className) {
              return target.classList.contains(className);
            },
            registerInteractionHandler: function registerInteractionHandler(evt, handler) {
              return _this.root_.addEventListener(evt, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
              return _this.root_.removeEventListener(evt, handler);
            },
            registerSurfaceInteractionHandler: function registerSurfaceInteractionHandler(evt, handler) {
              return _this.dialogSurface_.addEventListener(evt, handler);
            },
            deregisterSurfaceInteractionHandler: function deregisterSurfaceInteractionHandler(evt, handler) {
              return _this.dialogSurface_.removeEventListener(evt, handler);
            },
            registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
              return document.addEventListener('keydown', handler);
            },
            deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
              return document.removeEventListener('keydown', handler);
            },
            registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
              return _this.dialogSurface_.addEventListener('transitionend', handler);
            },
            deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
              return _this.dialogSurface_.removeEventListener('transitionend', handler);
            },
            notifyAccept: function notifyAccept() {
              return _this.emit(MDCDialogFoundation.strings.ACCEPT_EVENT);
            },
            notifyCancel: function notifyCancel() {
              return _this.emit(MDCDialogFoundation.strings.CANCEL_EVENT);
            },
            trapFocusOnSurface: function trapFocusOnSurface() {
              return _this.focusTrap_.activate();
            },
            untrapFocusOnSurface: function untrapFocusOnSurface() {
              return _this.focusTrap_.deactivate();
            },
            isDialog: function isDialog(el) {
              return el === _this.dialogSurface_;
            }
          });
        }
      }, {
        key: "open",
        get: function get$$1() {
          return this.foundation_.isOpen();
        }
      }, {
        key: "acceptButton_",
        get: function get$$1() {
          return this.root_.querySelector(MDCDialogFoundation.strings.ACCEPT_SELECTOR);
        }
      }, {
        key: "dialogSurface_",
        get: function get$$1() {
          return this.root_.querySelector(MDCDialogFoundation.strings.DIALOG_SURFACE_SELECTOR);
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCDialog(root);
        }
      }]);

      return MDCDialog;
    }(MDCComponent$5);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcDialogComponent = /** @class */ (function () {
        function MdcDialogComponent(elementRef, _registry, dialogRef) {
            var _this = this;
            this.elementRef = elementRef;
            this._registry = _registry;
            this.dialogRef = dialogRef;
            this.clickOutsideToClose = true;
            this.escapeToClose = true;
            this.backdrop = true;
            this.isHostClass = true;
            this.alertDialog = 'alertdialog';
            this.ariaHidden = 'true';
            this.tabIndex = -1;
            /**
             * Event emitted when the dialog is closed.
             */
            this.closed = new core.EventEmitter();
            this._accept = new core.EventEmitter();
            this._cancel = new core.EventEmitter();
            this._mdcAdapter = {
                addClass: function (className) { return _this._getHostElement().classList.add(className); },
                removeClass: function (className) { return _this._getHostElement().classList.remove(className); },
                addBodyClass: function (className) {
                    if (isBrowser()) {
                        document.body.classList.add(className);
                    }
                },
                removeBodyClass: function (className) {
                    if (isBrowser()) {
                        document.body.classList.remove(className);
                    }
                },
                eventTargetHasClass: function (target, className) { return target.classList.contains(className); },
                registerInteractionHandler: function (evt, handler) {
                    var /** @type {?} */ clickOutsideToClose = _this.config ? _this.config.clickOutsideToClose : _this.clickOutsideToClose;
                    handler = _this._surface && clickOutsideToClose ? handler : function (event) {
                        if ((/** @type {?} */ (event.target)).classList.contains('mdc-dialog__footer__button--accept')) {
                            _this.accept();
                        }
                        else if ((/** @type {?} */ (event.target)).classList.contains('mdc-dialog__footer__button--cancel')) {
                            _this.cancel();
                        }
                    };
                    _this._registry.listen(evt, handler, _this._getHostElement());
                },
                deregisterInteractionHandler: function (evt, handler) { return _this._registry.unlisten(evt, handler); },
                registerSurfaceInteractionHandler: function (evt, handler) {
                    return _this._registry.listen(evt, handler, _this._surface.elementRef.nativeElement);
                },
                deregisterSurfaceInteractionHandler: function (evt, handler) { return _this._registry.unlisten(evt, handler); },
                registerDocumentKeydownHandler: function (handler) {
                    if (!isBrowser()) {
                        return;
                    }
                    var /** @type {?} */ escapeToClose = _this.config ? _this.config.escapeToClose : _this.escapeToClose;
                    handler = escapeToClose ? handler : _this._onKeyDown;
                    _this._registry.listen('keydown', handler, document);
                },
                deregisterDocumentKeydownHandler: function (handler) {
                    if (!isBrowser()) {
                        return;
                    }
                    var /** @type {?} */ escapeToClose = _this.config ? _this.config.escapeToClose : _this.escapeToClose;
                    _this._registry.unlisten('keydown', escapeToClose ? handler : _this._onKeyDown);
                },
                registerTransitionEndHandler: function (handler) {
                    return _this._registry.listen('transitionend', handler, _this._surface.elementRef.nativeElement);
                },
                deregisterTransitionEndHandler: function (handler) { return _this._registry.unlisten('transitionend', handler); },
                notifyAccept: function () {
                    _this._accept.emit();
                    _this._closeDialogRef();
                },
                notifyCancel: function () {
                    _this._cancel.emit();
                    _this._closeDialogRef();
                },
                trapFocusOnSurface: function () {
                    if (_this._focusTrap) {
                        _this._focusTrap.activate();
                    }
                },
                untrapFocusOnSurface: function () {
                    if (_this._focusTrap) {
                        _this._focusTrap.deactivate();
                    }
                },
                isDialog: function (el) { return _this._surface ? el === _this._surface.elementRef.nativeElement : false; }
            };
            this._foundation = new MDCDialogFoundation(this._mdcAdapter);
        }
        /**
         * @return {?}
         */
        MdcDialogComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.dialogRef) {
                this.config = this.dialogRef.componentInstance.config;
                setTimeout(function () {
                    _this.show();
                });
            }
        };
        /**
         * @return {?}
         */
        MdcDialogComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._foundation.destroy();
        };
        /**
         * @return {?}
         */
        MdcDialogComponent.prototype.initDeclarativeConfig = /**
         * @return {?}
         */
        function () {
            this.config = new MdcDialogConfig();
            this.config.backdrop = this.backdrop;
            this.config.clickOutsideToClose = this.clickOutsideToClose;
            this.config.escapeToClose = this.escapeToClose;
        };
        /**
         * @return {?}
         */
        MdcDialogComponent.prototype.show = /**
         * @return {?}
         */
        function () {
            if (!this.dialogRef) {
                this.initDeclarativeConfig();
            }
            this._foundation.init();
            var /** @type {?} */ focusedEl = this._actions.find(function (_) { return _.accept; });
            if (isBrowser()) {
                this._focusTrap = createFocusTrapInstance(this._surface.elementRef.nativeElement, {
                    initialFocus: focusedEl ? focusedEl.getHostElement() : this._getHostElement(),
                    clickOutsideDeactivates: this.config ? this.config.clickOutsideToClose : this.clickOutsideToClose,
                    escapeDeactivates: this.config ? this.config.escapeToClose : this.escapeToClose,
                });
            }
            this._foundation.open();
            if (focusedEl) {
                focusedEl.focus();
            }
        };
        /**
         * @param {?=} result
         * @return {?}
         */
        MdcDialogComponent.prototype._closeDialogRef = /**
         * @param {?=} result
         * @return {?}
         */
        function (result) {
            if (this.dialogRef) {
                this.dialogRef.close(result);
            }
        };
        /**
         * @return {?}
         */
        MdcDialogComponent.prototype.close = /**
         * @return {?}
         */
        function () {
            this.closed.emit();
            this._foundation.close();
        };
        /**
         * @return {?}
         */
        MdcDialogComponent.prototype.isOpen = /**
         * @return {?}
         */
        function () {
            return this._foundation.isOpen();
        };
        /**
         * @param {?=} shouldNotify
         * @return {?}
         */
        MdcDialogComponent.prototype.accept = /**
         * @param {?=} shouldNotify
         * @return {?}
         */
        function (shouldNotify) {
            if (shouldNotify === void 0) { shouldNotify = true; }
            this._foundation.accept(shouldNotify);
        };
        /**
         * @param {?=} shouldNotify
         * @return {?}
         */
        MdcDialogComponent.prototype.cancel = /**
         * @param {?=} shouldNotify
         * @return {?}
         */
        function (shouldNotify) {
            if (shouldNotify === void 0) { shouldNotify = true; }
            this._foundation.cancel(shouldNotify);
        };
        /**
         * @param {?} event
         * @return {?}
         */
        MdcDialogComponent.prototype._onKeyDown = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (ESCAPE === event.keyCode) {
                event.stopPropagation();
            }
        };
        /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        MdcDialogComponent.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcDialogComponent.decorators = [
            { type: core.Component, args: [{selector: 'mdc-dialog',
                        template: "\n  <ng-content></ng-content>\n  <div class=\"mdc-dialog__backdrop\" *ngIf=\"config?.backdrop\"></div>\n  ",
                        host: {
                            '[attr.aria-labelledby]': 'config?.ariaLabel',
                            '[attr.aria-label]': 'config?.ariaLabel',
                            '[attr.aria-describedby]': 'config?.ariaDescribedBy || null',
                        },
                        providers: [EventRegistry],
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcDialogComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: EventRegistry },
            { type: MdcDialogRef, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] }
        ]; };
        MdcDialogComponent.propDecorators = {
            clickOutsideToClose: [{ type: core.Input }],
            escapeToClose: [{ type: core.Input }],
            backdrop: [{ type: core.Input }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-dialog',] }],
            alertDialog: [{ type: core.HostBinding, args: ['attr.role',] }],
            ariaHidden: [{ type: core.HostBinding, args: ['attr.aria-hidden',] }],
            tabIndex: [{ type: core.HostBinding, args: ['tabindex',] }],
            closed: [{ type: core.Output }],
            _accept: [{ type: core.Output, args: ['accept',] }],
            _cancel: [{ type: core.Output, args: ['cancel',] }],
            _surface: [{ type: core.ContentChild, args: [MdcDialogSurface,] }],
            _dialogBody: [{ type: core.ContentChild, args: [MdcDialogBody,] }],
            _actions: [{ type: core.ContentChildren, args: [MdcDialogButton, { descendants: true },] }]
        };
        return MdcDialogComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcDialog = /** @class */ (function () {
        function MdcDialog(_portalService, injector, dialogRefConstructor) {
            var _this = this;
            this._portalService = _portalService;
            this.injector = injector;
            this.dialogRefConstructor = dialogRefConstructor;
            this._afterClosed = new rxjs.Subject();
            this.afterClosed = rxjs.defer(function () { return _this.openDialogs.length ?
                _this._afterAllClosed : _this._afterAllClosed.pipe(operators.startWith(undefined)); });
            this._openDialogs = [];
        }
        Object.defineProperty(MdcDialog.prototype, "_afterAllClosed", {
            /** Stream that emits when all dialogs are closed. */
            get: /**
             * Stream that emits when all dialogs are closed.
             * @return {?}
             */
            function () {
                return this._afterClosed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcDialog.prototype, "openDialogs", {
            /** Stream that emits when a dialog is opened. */
            get: /**
             * Stream that emits when a dialog is opened.
             * @return {?}
             */
            function () {
                return this._openDialogs;
            },
            enumerable: true,
            configurable: true
        });
        /** Gets an open dialog by id. */
        /**
         * Gets an open dialog by id.
         * @param {?} id
         * @return {?}
         */
        MdcDialog.prototype.getById = /**
         * Gets an open dialog by id.
         * @param {?} id
         * @return {?}
         */
        function (id) {
            return this._openDialogs.find(function (ref) { return ref.id === id; });
        };
        /** Closes all open dialogs. */
        /**
         * Closes all open dialogs.
         * @return {?}
         */
        MdcDialog.prototype.close = /**
         * Closes all open dialogs.
         * @return {?}
         */
        function () {
            this.openDialogs.forEach(function (ref) { return ref.close(); });
        };
        /**
         * Opens a dialog containing the given component.
         */
        /**
         * Opens a dialog containing the given component.
         * @template T
         * @param {?} component
         * @param {?=} config
         * @return {?}
         */
        MdcDialog.prototype.open = /**
         * Opens a dialog containing the given component.
         * @template T
         * @param {?} component
         * @param {?=} config
         * @return {?}
         */
        function (component, config) {
            config = this._applyConfigDefaults(config);
            if (config.id && this.getById(config.id)) {
                throw Error("Dialog with id \"" + config.id + "\" exists already. The dialog id must be unique.");
            }
            var /** @type {?} */ dialogContainer = this._attachDialogContainer(config);
            var /** @type {?} */ dialogRef = this._attachDialogContentForComponent(component, dialogContainer, config);
            this._registerDialogRef(dialogRef);
            dialogRef.componentInstance.config = config;
            return dialogRef;
        };
        /**
         * @param {?} config
         * @return {?}
         */
        MdcDialog.prototype._attachDialogContainer = /**
         * @param {?} config
         * @return {?}
         */
        function (config) {
            var /** @type {?} */ container = config.containerComponent || this.injector.get(DIALOG_CONTAINER);
            var /** @type {?} */ userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
            var /** @type {?} */ injector = new PortalInjector(userInjector || this.injector, new WeakMap([
                [MdcDialogConfig, config]
            ]));
            var /** @type {?} */ containerPortal = new ComponentPortal(container, config.viewContainerRef, injector);
            var /** @type {?} */ containerRef = this._portalService.createComponentRef(containerPortal.component);
            containerRef.instance.config = config;
            return containerRef.instance;
        };
        /**
         * @template T
         * @param {?} component
         * @param {?} dialogContainer
         * @param {?} config
         * @return {?}
         */
        MdcDialog.prototype._attachDialogContentForComponent = /**
         * @template T
         * @param {?} component
         * @param {?} dialogContainer
         * @param {?} config
         * @return {?}
         */
        function (component, dialogContainer, config) {
            // Create a reference to the dialog we're creating in order to give the user a handle
            // to modify and close it.
            var /** @type {?} */ dialogRef = new this.dialogRefConstructor(dialogContainer, config.id);
            var /** @type {?} */ injector = this._createInjector(config, dialogRef, dialogContainer);
            var /** @type {?} */ contentRef = dialogContainer.attachComponentPortal(new ComponentPortal(component, undefined, injector));
            dialogRef.componentInstance = contentRef.instance;
            return dialogRef;
        };
        /**
         * Forwards emitting events for when dialogs are opened and all dialogs are closed.
         * @param {?} dialogRef
         * @return {?}
         */
        MdcDialog.prototype._registerDialogRef = /**
         * Forwards emitting events for when dialogs are opened and all dialogs are closed.
         * @param {?} dialogRef
         * @return {?}
         */
        function (dialogRef) {
            var _this = this;
            this.openDialogs.push(dialogRef);
            var /** @type {?} */ dialogCloseSub = dialogRef.afterClosed().subscribe(function () {
                var /** @type {?} */ dialogIdx = _this._openDialogs.indexOf(dialogRef);
                if (dialogIdx !== -1) {
                    _this._openDialogs.splice(dialogIdx, 1);
                }
                if (!_this._openDialogs.length) {
                    _this._afterClosed.next();
                    dialogCloseSub.unsubscribe();
                }
                _this._portalService.dispose();
            });
        };
        /**
         * @template T
         * @param {?} config
         * @param {?} dialogRef
         * @param {?} dialogContainer
         * @return {?}
         */
        MdcDialog.prototype._createInjector = /**
         * @template T
         * @param {?} config
         * @param {?} dialogRef
         * @param {?} dialogContainer
         * @return {?}
         */
        function (config, dialogRef, dialogContainer) {
            var /** @type {?} */ userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
            var /** @type {?} */ injectionTokens = new WeakMap([
                [this.injector.get(DIALOG_REF), dialogRef],
                [this.injector.get(DIALOG_CONTAINER), dialogContainer],
                [DIALOG_DATA, config.data]
            ]);
            return new PortalInjector(userInjector || this.injector, injectionTokens);
        };
        /**
         * Expands the provided configuration object to include the default values for properties which
         * are undefined.
         * @param {?=} config
         * @return {?}
         */
        MdcDialog.prototype._applyConfigDefaults = /**
         * Expands the provided configuration object to include the default values for properties which
         * are undefined.
         * @param {?=} config
         * @return {?}
         */
        function (config) {
            var /** @type {?} */ dialogConfig = /** @type {?} */ (this.injector.get(DIALOG_CONFIG));
            return _assign({}, new dialogConfig(), config);
        };
        MdcDialog.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        MdcDialog.ctorParameters = function () { return [
            { type: MdcPortalService },
            { type: core.Injector },
            { type: undefined, decorators: [{ type: core.Inject, args: [DIALOG_REF,] }] }
        ]; };
        return MdcDialog;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DIALOG_DECLARATIONS = [
        MdcDialogBody,
        MdcDialogButton,
        MdcDialogComponent,
        MdcDialogContainer,
        MdcDialogFooter,
        MdcDialogHeader,
        MdcDialogHeaderTitle,
        MdcDialogSurface
    ];
    var ɵ0 = MdcDialogRef, ɵ1 = MdcDialogContainer, ɵ2 = MdcDialogConfig;
    var MdcDialogModule = /** @class */ (function () {
        function MdcDialogModule() {
        }
        MdcDialogModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, PortalModule],
                        exports: DIALOG_DECLARATIONS,
                        declarations: DIALOG_DECLARATIONS,
                        providers: [
                            MdcPortalService,
                            MdcDialog,
                            { provide: DIALOG_REF, useValue: ɵ0 },
                            { provide: DIALOG_CONTAINER, useValue: ɵ1 },
                            { provide: DIALOG_CONFIG, useValue: ɵ2 }
                        ],
                        entryComponents: [MdcDialogContainer]
                    },] },
        ];
        return MdcDialogModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcDrawerSpacer = /** @class */ (function () {
        function MdcDrawerSpacer(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcDrawerSpacer.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdc-drawer-spacer], mdc-drawer-spacer',
                        exportAs: 'mdcDrawerSpace'
                    },] },
        ];
        /** @nocollapse */
        MdcDrawerSpacer.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcDrawerSpacer.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-drawer__toolbar-spacer',] }]
        };
        return MdcDrawerSpacer;
    }());
    var MdcDrawerHeader = /** @class */ (function () {
        function MdcDrawerHeader(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcDrawerHeader.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdc-drawer-header], mdc-drawer-header',
                        exportAs: 'mdcDrawerHeader'
                    },] },
        ];
        /** @nocollapse */
        MdcDrawerHeader.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcDrawerHeader.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-drawer__header',] }]
        };
        return MdcDrawerHeader;
    }());
    var MdcDrawerHeaderContent = /** @class */ (function () {
        function MdcDrawerHeaderContent(elementRef) {
            this.elementRef = elementRef;
            this.primary = true;
            this.isHostClass = true;
        }
        Object.defineProperty(MdcDrawerHeaderContent.prototype, "classPrimaryBackground", {
            get: /**
             * @return {?}
             */
            function () {
                return this.primary ? 'mdc-theme--primary-bg' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcDrawerHeaderContent.prototype, "classPrimaryOnPrimary", {
            get: /**
             * @return {?}
             */
            function () {
                return this.primary ? 'mdc-theme--text-primary-on-primary' : '';
            },
            enumerable: true,
            configurable: true
        });
        MdcDrawerHeaderContent.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdc-drawer-header-content], mdc-drawer-header-content',
                        exportAs: 'mdcDrawerHeaderContent'
                    },] },
        ];
        /** @nocollapse */
        MdcDrawerHeaderContent.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcDrawerHeaderContent.propDecorators = {
            primary: [{ type: core.Input }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-drawer__header-content',] }],
            classPrimaryBackground: [{ type: core.HostBinding, args: ['class.mdc-theme--primary-bg',] }],
            classPrimaryOnPrimary: [{ type: core.HostBinding, args: ['class.mdc-theme--text-primary-on-primary',] }]
        };
        return MdcDrawerHeaderContent;
    }());
    var MdcDrawerContent = /** @class */ (function () {
        function MdcDrawerContent(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcDrawerContent.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdc-drawer-content], mdc-drawer-content',
                        exportAs: 'mdcDrawerContent'
                    },] },
        ];
        /** @nocollapse */
        MdcDrawerContent.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcDrawerContent.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-drawer__content',] }]
        };
        return MdcDrawerContent;
    }());
    var MdcDrawerNavigation = /** @class */ (function () {
        function MdcDrawerNavigation(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
            this.role = 'navigation';
        }
        MdcDrawerNavigation.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-drawer-navigation',
                        exportAs: 'mdcDrawerNavigation'
                    },] },
        ];
        /** @nocollapse */
        MdcDrawerNavigation.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcDrawerNavigation.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-drawer__drawer',] }],
            role: [{ type: core.HostBinding, args: ['attr.role',] }]
        };
        return MdcDrawerNavigation;
    }());

    /**
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var TAB_DATA = 'data-mdc-tabindex';
    var TAB_DATA_HANDLED = 'data-mdc-tabindex-handled';
    var storedTransformPropertyName_;
    var supportsPassive_$6; // Remap touch events to pointer events, if the browser doesn't support touch events.

    function remapEvent(eventName) {
      var globalObj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;

      if (!('ontouchstart' in globalObj.document)) {
        switch (eventName) {
          case 'touchstart':
            return 'pointerdown';

          case 'touchmove':
            return 'pointermove';

          case 'touchend':
            return 'pointerup';

          default:
            return eventName;
        }
      }

      return eventName;
    } // Choose the correct transform property to use on the current browser.

    function getTransformPropertyName() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (storedTransformPropertyName_ === undefined || forceRefresh) {
        var el = globalObj.document.createElement('div');
        var transformPropertyName = 'transform' in el.style ? 'transform' : '-webkit-transform';
        storedTransformPropertyName_ = transformPropertyName;
      }

      return storedTransformPropertyName_;
    } // Determine whether the current browser supports CSS properties.

    function supportsCssCustomProperties() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;

      if ('CSS' in globalObj) {
        return globalObj.CSS.supports('(--color: red)');
      }

      return false;
    } // Determine whether the current browser supports passive event listeners, and if so, use them.

    function applyPassive$6() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_$6 === undefined || forceRefresh) {
        var isSupported = false;

        try {
          globalObj.document.addEventListener('test', null, {
            get passive() {
              isSupported = true;
            }

          });
        } catch (e) {}

        supportsPassive_$6 = isSupported;
      }

      return supportsPassive_$6 ? {
        passive: true
      } : false;
    } // Save the tab state for an element.

    function saveElementTabState(el) {
      if (el.hasAttribute('tabindex')) {
        el.setAttribute(TAB_DATA, el.getAttribute('tabindex'));
      }

      el.setAttribute(TAB_DATA_HANDLED, true);
    } // Restore the tab state for an element, if it was saved.

    function restoreElementTabState(el) {
      // Only modify elements we've already handled, in case anything was dynamically added since we saved state.
      if (el.hasAttribute(TAB_DATA_HANDLED)) {
        if (el.hasAttribute(TAB_DATA)) {
          el.setAttribute('tabindex', el.getAttribute(TAB_DATA));
          el.removeAttribute(TAB_DATA);
        } else {
          el.removeAttribute('tabindex');
        }

        el.removeAttribute(TAB_DATA_HANDLED);
      }
    }

    function _classCallCheck$7(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$7(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$7(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$7(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$7(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$7(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$7(subClass, superClass);
    }

    function _getPrototypeOf$7(o) {
      _getPrototypeOf$7 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$7(o);
    }

    function _setPrototypeOf$7(o, p) {
      _setPrototypeOf$7 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$7(o, p);
    }

    function _assertThisInitialized$7(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$7(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$7(self);
    }

    function _superPropBase$5(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$7(object);
        if (object === null) break;
      }

      return object;
    }

    function _get$5(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$5 = Reflect.get;
      } else {
        _get$5 = function _get(target, property, receiver) {
          var base = _superPropBase$5(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get$5(target, property, receiver || target);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @template A
     */
    var MDCFoundation$6 =
    /*#__PURE__*/
    function () {
      _createClass$7(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$7(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$7(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$6 =
    /*#__PURE__*/
    function () {
      _createClass$7(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$6());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$7(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$7(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var FOCUSABLE_ELEMENTS = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), ' + 'button:not([disabled]), iframe, object, embed, [tabindex], [contenteditable]';

    var MDCSlidableDrawerFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$7(MDCSlidableDrawerFoundation, _MDCFoundation);

      _createClass$7(MDCSlidableDrawerFoundation, null, [{
        key: "defaultAdapter",
        get: function get() {
          return {
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            hasClass: function hasClass()
            /* className: string */
            {},
            hasNecessaryDom: function hasNecessaryDom() {
              return (
                /* boolean */
                false
              );
            },
            registerInteractionHandler: function registerInteractionHandler()
            /* evt: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* evt: string, handler: EventListener */
            {},
            registerDrawerInteractionHandler: function registerDrawerInteractionHandler()
            /* evt: string, handler: EventListener */
            {},
            deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler()
            /* evt: string, handler: EventListener */
            {},
            registerTransitionEndHandler: function registerTransitionEndHandler()
            /* handler: EventListener */
            {},
            deregisterTransitionEndHandler: function deregisterTransitionEndHandler()
            /* handler: EventListener */
            {},
            registerDocumentKeydownHandler: function registerDocumentKeydownHandler()
            /* handler: EventListener */
            {},
            deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler()
            /* handler: EventListener */
            {},
            setTranslateX: function setTranslateX()
            /* value: number | null */
            {},
            getFocusableElements: function getFocusableElements()
            /* NodeList */
            {},
            saveElementTabState: function saveElementTabState()
            /* el: Element */
            {},
            restoreElementTabState: function restoreElementTabState()
            /* el: Element */
            {},
            makeElementUntabbable: function makeElementUntabbable()
            /* el: Element */
            {},
            notifyOpen: function notifyOpen() {},
            notifyClose: function notifyClose() {},
            isRtl: function isRtl() {
              return (
                /* boolean */
                false
              );
            },
            getDrawerWidth: function getDrawerWidth() {
              return (
                /* number */
                0
              );
            }
          };
        }
      }]);

      function MDCSlidableDrawerFoundation(adapter, rootCssClass, animatingCssClass, openCssClass) {
        var _this;

        _classCallCheck$7(this, MDCSlidableDrawerFoundation);

        _this = _possibleConstructorReturn$7(this, _getPrototypeOf$7(MDCSlidableDrawerFoundation).call(this, Object.assign(MDCSlidableDrawerFoundation.defaultAdapter, adapter)));
        _this.rootCssClass_ = rootCssClass;
        _this.animatingCssClass_ = animatingCssClass;
        _this.openCssClass_ = openCssClass;

        _this.transitionEndHandler_ = function (evt) {
          return _this.handleTransitionEnd_(evt);
        };

        _this.inert_ = false;

        _this.componentTouchStartHandler_ = function (evt) {
          return _this.handleTouchStart_(evt);
        };

        _this.componentTouchMoveHandler_ = function (evt) {
          return _this.handleTouchMove_(evt);
        };

        _this.componentTouchEndHandler_ = function (evt) {
          return _this.handleTouchEnd_(evt);
        };

        _this.documentKeydownHandler_ = function (evt) {
          if (evt.key && evt.key === 'Escape' || evt.keyCode === 27) {
            _this.close();
          }
        };

        return _this;
      }

      _createClass$7(MDCSlidableDrawerFoundation, [{
        key: "init",
        value: function init() {
          var ROOT = this.rootCssClass_;
          var OPEN = this.openCssClass_;

          if (!this.adapter_.hasClass(ROOT)) {
            throw new Error("".concat(ROOT, " class required in root element."));
          }

          if (!this.adapter_.hasNecessaryDom()) {
            throw new Error("Required DOM nodes missing in ".concat(ROOT, " component."));
          }

          if (this.adapter_.hasClass(OPEN)) {
            this.isOpen_ = true;
          } else {
            this.detabinate_();
            this.isOpen_ = false;
          }

          this.adapter_.registerDrawerInteractionHandler('touchstart', this.componentTouchStartHandler_);
          this.adapter_.registerInteractionHandler('touchmove', this.componentTouchMoveHandler_);
          this.adapter_.registerInteractionHandler('touchend', this.componentTouchEndHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.adapter_.deregisterDrawerInteractionHandler('touchstart', this.componentTouchStartHandler_);
          this.adapter_.deregisterInteractionHandler('touchmove', this.componentTouchMoveHandler_);
          this.adapter_.deregisterInteractionHandler('touchend', this.componentTouchEndHandler_); // Deregister the document keydown handler just in case the component is destroyed while the menu is open.

          this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
        }
      }, {
        key: "open",
        value: function open() {
          this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
          this.adapter_.registerDocumentKeydownHandler(this.documentKeydownHandler_);
          this.adapter_.addClass(this.animatingCssClass_);
          this.adapter_.addClass(this.openCssClass_);
          this.retabinate_(); // Debounce multiple calls

          if (!this.isOpen_) {
            this.adapter_.notifyOpen();
          }

          this.isOpen_ = true;
        }
      }, {
        key: "close",
        value: function close() {
          this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
          this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
          this.adapter_.addClass(this.animatingCssClass_);
          this.adapter_.removeClass(this.openCssClass_);
          this.detabinate_(); // Debounce multiple calls

          if (this.isOpen_) {
            this.adapter_.notifyClose();
          }

          this.isOpen_ = false;
        }
      }, {
        key: "isOpen",
        value: function isOpen() {
          return this.isOpen_;
        }
        /**
         *  Render all children of the drawer inert when it's closed.
         */

      }, {
        key: "detabinate_",
        value: function detabinate_() {
          if (this.inert_) {
            return;
          }

          var elements = this.adapter_.getFocusableElements();

          if (elements) {
            for (var i = 0; i < elements.length; i++) {
              this.adapter_.saveElementTabState(elements[i]);
              this.adapter_.makeElementUntabbable(elements[i]);
            }
          }

          this.inert_ = true;
        }
        /**
         *  Make all children of the drawer tabbable again when it's open.
         */

      }, {
        key: "retabinate_",
        value: function retabinate_() {
          if (!this.inert_) {
            return;
          }

          var elements = this.adapter_.getFocusableElements();

          if (elements) {
            for (var i = 0; i < elements.length; i++) {
              this.adapter_.restoreElementTabState(elements[i]);
            }
          }

          this.inert_ = false;
        }
      }, {
        key: "handleTouchStart_",
        value: function handleTouchStart_(evt) {
          if (!this.adapter_.hasClass(this.openCssClass_)) {
            return;
          }

          if (evt.pointerType && evt.pointerType !== 'touch') {
            return;
          }

          this.direction_ = this.adapter_.isRtl() ? -1 : 1;
          this.drawerWidth_ = this.adapter_.getDrawerWidth();
          this.startX_ = evt.touches ? evt.touches[0].pageX : evt.pageX;
          this.currentX_ = this.startX_;
          this.updateRaf_ = requestAnimationFrame(this.updateDrawer_.bind(this));
        }
      }, {
        key: "handleTouchMove_",
        value: function handleTouchMove_(evt) {
          if (evt.pointerType && evt.pointerType !== 'touch') {
            return;
          }

          this.currentX_ = evt.touches ? evt.touches[0].pageX : evt.pageX;
        }
      }, {
        key: "handleTouchEnd_",
        value: function handleTouchEnd_(evt) {
          if (evt.pointerType && evt.pointerType !== 'touch') {
            return;
          }

          this.prepareForTouchEnd_(); // Did the user close the drawer by more than 50%?

          if (Math.abs(this.newPosition_ / this.drawerWidth_) >= 0.5) {
            this.close();
          } else {
            // Triggering an open here means we'll get a nice animation back to the fully open state.
            this.open();
          }
        }
      }, {
        key: "prepareForTouchEnd_",
        value: function prepareForTouchEnd_() {
          cancelAnimationFrame(this.updateRaf_);
          this.adapter_.setTranslateX(null);
        }
      }, {
        key: "updateDrawer_",
        value: function updateDrawer_() {
          this.updateRaf_ = requestAnimationFrame(this.updateDrawer_.bind(this));
          this.adapter_.setTranslateX(this.newPosition_);
        }
      }, {
        key: "isRootTransitioningEventTarget_",
        value: function isRootTransitioningEventTarget_() {
          // Classes extending MDCSlidableDrawerFoundation should implement this method to return true or false
          // if the event target is the root event target currently transitioning.
          return false;
        }
      }, {
        key: "handleTransitionEnd_",
        value: function handleTransitionEnd_(evt) {
          if (this.isRootTransitioningEventTarget_(evt.target)) {
            this.adapter_.removeClass(this.animatingCssClass_);
            this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
          }
        }
      }, {
        key: "newPosition_",
        get: function get() {
          var newPos = null;

          if (this.direction_ === 1) {
            newPos = Math.min(0, this.currentX_ - this.startX_);
          } else {
            newPos = Math.max(0, this.currentX_ - this.startX_);
          }

          return newPos;
        }
      }]);

      return MDCSlidableDrawerFoundation;
    }(MDCFoundation$6);

    /**
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var cssClasses$6 = {
      ROOT: 'mdc-drawer--temporary',
      OPEN: 'mdc-drawer--open',
      ANIMATING: 'mdc-drawer--animating',
      SCROLL_LOCK: 'mdc-drawer-scroll-lock'
    };
    var strings$6 = {
      DRAWER_SELECTOR: '.mdc-drawer--temporary .mdc-drawer__drawer',
      OPACITY_VAR_NAME: '--mdc-temporary-drawer-opacity',
      FOCUSABLE_ELEMENTS: FOCUSABLE_ELEMENTS,
      OPEN_EVENT: 'MDCTemporaryDrawer:open',
      CLOSE_EVENT: 'MDCTemporaryDrawer:close'
    };

    var MDCTemporaryDrawerFoundation =
    /*#__PURE__*/
    function (_MDCSlidableDrawerFou) {
      _inherits$7(MDCTemporaryDrawerFoundation, _MDCSlidableDrawerFou);

      _createClass$7(MDCTemporaryDrawerFoundation, null, [{
        key: "cssClasses",
        get: function get$$1() {
          return cssClasses$6;
        }
      }, {
        key: "strings",
        get: function get$$1() {
          return strings$6;
        }
      }, {
        key: "defaultAdapter",
        get: function get$$1() {
          return Object.assign(MDCSlidableDrawerFoundation.defaultAdapter, {
            addBodyClass: function addBodyClass()
            /* className: string */
            {},
            removeBodyClass: function removeBodyClass()
            /* className: string */
            {},
            isDrawer: function isDrawer() {
              return false;
            },
            updateCssVariable: function updateCssVariable()
            /* value: string */
            {},
            eventTargetHasClass: function eventTargetHasClass() {
              return (
                /* target: EventTarget, className: string */

                /* boolean */
                false
              );
            }
          });
        }
      }]);

      function MDCTemporaryDrawerFoundation(adapter) {
        var _this;

        _classCallCheck$7(this, MDCTemporaryDrawerFoundation);

        _this = _possibleConstructorReturn$7(this, _getPrototypeOf$7(MDCTemporaryDrawerFoundation).call(this, Object.assign(MDCTemporaryDrawerFoundation.defaultAdapter, adapter), MDCTemporaryDrawerFoundation.cssClasses.ROOT, MDCTemporaryDrawerFoundation.cssClasses.ANIMATING, MDCTemporaryDrawerFoundation.cssClasses.OPEN));

        _this.componentClickHandler_ = function (evt) {
          if (_this.adapter_.eventTargetHasClass(evt.target, cssClasses$6.ROOT)) {
            _this.close(true);
          }
        };

        return _this;
      }

      _createClass$7(MDCTemporaryDrawerFoundation, [{
        key: "init",
        value: function init() {
          _get$5(_getPrototypeOf$7(MDCTemporaryDrawerFoundation.prototype), "init", this).call(this); // Make browser aware of custom property being used in this element.
          // Workaround for certain types of hard-to-reproduce heisenbugs.


          this.adapter_.updateCssVariable(0);
          this.adapter_.registerInteractionHandler('click', this.componentClickHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          _get$5(_getPrototypeOf$7(MDCTemporaryDrawerFoundation.prototype), "destroy", this).call(this);

          this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
          this.enableScroll_();
        }
      }, {
        key: "open",
        value: function open() {
          this.disableScroll_(); // Make sure custom property values are cleared before starting.

          this.adapter_.updateCssVariable('');

          _get$5(_getPrototypeOf$7(MDCTemporaryDrawerFoundation.prototype), "open", this).call(this);
        }
      }, {
        key: "close",
        value: function close() {
          // Make sure custom property values are cleared before making any changes.
          this.adapter_.updateCssVariable('');

          _get$5(_getPrototypeOf$7(MDCTemporaryDrawerFoundation.prototype), "close", this).call(this);
        }
      }, {
        key: "prepareForTouchEnd_",
        value: function prepareForTouchEnd_() {
          _get$5(_getPrototypeOf$7(MDCTemporaryDrawerFoundation.prototype), "prepareForTouchEnd_", this).call(this);

          this.adapter_.updateCssVariable('');
        }
      }, {
        key: "updateDrawer_",
        value: function updateDrawer_() {
          _get$5(_getPrototypeOf$7(MDCTemporaryDrawerFoundation.prototype), "updateDrawer_", this).call(this);

          var newOpacity = Math.max(0, 1 + this.direction_ * (this.newPosition_ / this.drawerWidth_));
          this.adapter_.updateCssVariable(newOpacity);
        }
      }, {
        key: "isRootTransitioningEventTarget_",
        value: function isRootTransitioningEventTarget_(el) {
          return this.adapter_.isDrawer(el);
        }
      }, {
        key: "handleTransitionEnd_",
        value: function handleTransitionEnd_(evt) {
          _get$5(_getPrototypeOf$7(MDCTemporaryDrawerFoundation.prototype), "handleTransitionEnd_", this).call(this, evt);

          if (!this.isOpen_) {
            this.enableScroll_();
          }
        }
      }, {
        key: "disableScroll_",
        value: function disableScroll_() {
          this.adapter_.addBodyClass(cssClasses$6.SCROLL_LOCK);
        }
      }, {
        key: "enableScroll_",
        value: function enableScroll_() {
          this.adapter_.removeBodyClass(cssClasses$6.SCROLL_LOCK);
        }
      }]);

      return MDCTemporaryDrawerFoundation;
    }(MDCSlidableDrawerFoundation);

    var MDCTemporaryDrawer =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$7(MDCTemporaryDrawer, _MDCComponent);

      function MDCTemporaryDrawer() {
        _classCallCheck$7(this, MDCTemporaryDrawer);

        return _possibleConstructorReturn$7(this, _getPrototypeOf$7(MDCTemporaryDrawer).apply(this, arguments));
      }

      _createClass$7(MDCTemporaryDrawer, [{
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this = this;

          var _MDCTemporaryDrawerFo = MDCTemporaryDrawerFoundation.strings,
              FOCUSABLE_ELEMENTS = _MDCTemporaryDrawerFo.FOCUSABLE_ELEMENTS,
              OPACITY_VAR_NAME = _MDCTemporaryDrawerFo.OPACITY_VAR_NAME;
          return new MDCTemporaryDrawerFoundation({
            addClass: function addClass(className) {
              return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
              return _this.root_.classList.contains(className);
            },
            addBodyClass: function addBodyClass(className) {
              return document.body.classList.add(className);
            },
            removeBodyClass: function removeBodyClass(className) {
              return document.body.classList.remove(className);
            },
            eventTargetHasClass: function eventTargetHasClass(target, className) {
              return target.classList.contains(className);
            },
            hasNecessaryDom: function hasNecessaryDom() {
              return Boolean(_this.drawer);
            },
            registerInteractionHandler: function registerInteractionHandler(evt, handler) {
              return _this.root_.addEventListener(remapEvent(evt), handler, applyPassive$6());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
              return _this.root_.removeEventListener(remapEvent(evt), handler, applyPassive$6());
            },
            registerDrawerInteractionHandler: function registerDrawerInteractionHandler(evt, handler) {
              return _this.drawer.addEventListener(remapEvent(evt), handler);
            },
            deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler(evt, handler) {
              return _this.drawer.removeEventListener(remapEvent(evt), handler);
            },
            registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
              return _this.drawer.addEventListener('transitionend', handler);
            },
            deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
              return _this.drawer.removeEventListener('transitionend', handler);
            },
            registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
              return document.addEventListener('keydown', handler);
            },
            deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
              return document.removeEventListener('keydown', handler);
            },
            getDrawerWidth: function getDrawerWidth() {
              return _this.drawer.offsetWidth;
            },
            setTranslateX: function setTranslateX(value) {
              return _this.drawer.style.setProperty(getTransformPropertyName(), value === null ? null : "translateX(".concat(value, "px)"));
            },
            updateCssVariable: function updateCssVariable(value) {
              if (supportsCssCustomProperties()) {
                _this.root_.style.setProperty(OPACITY_VAR_NAME, value);
              }
            },
            getFocusableElements: function getFocusableElements() {
              return _this.drawer.querySelectorAll(FOCUSABLE_ELEMENTS);
            },
            saveElementTabState: function saveElementTabState$$1(el) {
              return saveElementTabState(el);
            },
            restoreElementTabState: function restoreElementTabState$$1(el) {
              return restoreElementTabState(el);
            },
            makeElementUntabbable: function makeElementUntabbable(el) {
              return el.setAttribute('tabindex', -1);
            },
            notifyOpen: function notifyOpen() {
              return _this.emit(MDCTemporaryDrawerFoundation.strings.OPEN_EVENT);
            },
            notifyClose: function notifyClose() {
              return _this.emit(MDCTemporaryDrawerFoundation.strings.CLOSE_EVENT);
            },
            isRtl: function isRtl() {
              return getComputedStyle(_this.root_).getPropertyValue('direction') === 'rtl';
            },
            isDrawer: function isDrawer(el) {
              return el === _this.drawer;
            }
          });
        }
      }, {
        key: "open",
        get: function get() {
          return this.foundation_.isOpen();
        },
        set: function set(value) {
          if (value) {
            this.foundation_.open();
          } else {
            this.foundation_.close();
          }
        }
        /* Return the drawer element inside the component. */

      }, {
        key: "drawer",
        get: function get() {
          return this.root_.querySelector(MDCTemporaryDrawerFoundation.strings.DRAWER_SELECTOR);
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCTemporaryDrawer(root);
        }
      }]);

      return MDCTemporaryDrawer;
    }(MDCComponent$6);

    /**
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var cssClasses$1$6 = {
      ROOT: 'mdc-drawer--persistent',
      OPEN: 'mdc-drawer--open',
      ANIMATING: 'mdc-drawer--animating'
    };
    var strings$1$6 = {
      DRAWER_SELECTOR: '.mdc-drawer--persistent .mdc-drawer__drawer',
      FOCUSABLE_ELEMENTS: FOCUSABLE_ELEMENTS,
      OPEN_EVENT: 'MDCPersistentDrawer:open',
      CLOSE_EVENT: 'MDCPersistentDrawer:close'
    };

    var MDCPersistentDrawerFoundation =
    /*#__PURE__*/
    function (_MDCSlidableDrawerFou) {
      _inherits$7(MDCPersistentDrawerFoundation, _MDCSlidableDrawerFou);

      _createClass$7(MDCPersistentDrawerFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$1$6;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$1$6;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return Object.assign(MDCSlidableDrawerFoundation.defaultAdapter, {
            isDrawer: function isDrawer() {
              return false;
            }
          });
        }
      }]);

      function MDCPersistentDrawerFoundation(adapter) {
        _classCallCheck$7(this, MDCPersistentDrawerFoundation);

        return _possibleConstructorReturn$7(this, _getPrototypeOf$7(MDCPersistentDrawerFoundation).call(this, Object.assign(MDCPersistentDrawerFoundation.defaultAdapter, adapter), MDCPersistentDrawerFoundation.cssClasses.ROOT, MDCPersistentDrawerFoundation.cssClasses.ANIMATING, MDCPersistentDrawerFoundation.cssClasses.OPEN));
      }

      _createClass$7(MDCPersistentDrawerFoundation, [{
        key: "isRootTransitioningEventTarget_",
        value: function isRootTransitioningEventTarget_(el) {
          return this.adapter_.isDrawer(el);
        }
      }]);

      return MDCPersistentDrawerFoundation;
    }(MDCSlidableDrawerFoundation);

    var MDCPersistentDrawer =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$7(MDCPersistentDrawer, _MDCComponent);

      function MDCPersistentDrawer() {
        _classCallCheck$7(this, MDCPersistentDrawer);

        return _possibleConstructorReturn$7(this, _getPrototypeOf$7(MDCPersistentDrawer).apply(this, arguments));
      }

      _createClass$7(MDCPersistentDrawer, [{
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this = this;

          var FOCUSABLE_ELEMENTS = MDCPersistentDrawerFoundation.strings.FOCUSABLE_ELEMENTS;
          return new MDCPersistentDrawerFoundation({
            addClass: function addClass(className) {
              return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
              return _this.root_.classList.contains(className);
            },
            hasNecessaryDom: function hasNecessaryDom() {
              return Boolean(_this.drawer);
            },
            registerInteractionHandler: function registerInteractionHandler(evt, handler) {
              return _this.root_.addEventListener(remapEvent(evt), handler, applyPassive$6());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
              return _this.root_.removeEventListener(remapEvent(evt), handler, applyPassive$6());
            },
            registerDrawerInteractionHandler: function registerDrawerInteractionHandler(evt, handler) {
              return _this.drawer.addEventListener(remapEvent(evt), handler);
            },
            deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler(evt, handler) {
              return _this.drawer.removeEventListener(remapEvent(evt), handler);
            },
            registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
              return _this.root_.addEventListener('transitionend', handler);
            },
            deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
              return _this.root_.removeEventListener('transitionend', handler);
            },
            registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
              return document.addEventListener('keydown', handler);
            },
            deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
              return document.removeEventListener('keydown', handler);
            },
            getDrawerWidth: function getDrawerWidth() {
              return _this.drawer.offsetWidth;
            },
            setTranslateX: function setTranslateX(value) {
              return _this.drawer.style.setProperty(getTransformPropertyName(), value === null ? null : "translateX(".concat(value, "px)"));
            },
            getFocusableElements: function getFocusableElements() {
              return _this.drawer.querySelectorAll(FOCUSABLE_ELEMENTS);
            },
            saveElementTabState: function saveElementTabState$$1(el) {
              return saveElementTabState(el);
            },
            restoreElementTabState: function restoreElementTabState$$1(el) {
              return restoreElementTabState(el);
            },
            makeElementUntabbable: function makeElementUntabbable(el) {
              return el.setAttribute('tabindex', -1);
            },
            notifyOpen: function notifyOpen() {
              return _this.emit(MDCPersistentDrawerFoundation.strings.OPEN_EVENT);
            },
            notifyClose: function notifyClose() {
              return _this.emit(MDCPersistentDrawerFoundation.strings.CLOSE_EVENT);
            },
            isRtl: function isRtl() {
              return getComputedStyle(_this.root_).getPropertyValue('direction') === 'rtl';
            },
            isDrawer: function isDrawer(el) {
              return el === _this.drawer;
            }
          });
        }
      }, {
        key: "open",
        get: function get() {
          return this.foundation_.isOpen();
        },
        set: function set(value) {
          if (value) {
            this.foundation_.open();
          } else {
            this.foundation_.close();
          }
        } // Return the drawer element inside the component.

      }, {
        key: "drawer",
        get: function get() {
          return this.root_.querySelector(MDCPersistentDrawerFoundation.strings.DRAWER_SELECTOR);
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCPersistentDrawer(root);
        }
      }]);

      return MDCPersistentDrawer;
    }(MDCComponent$6);

    /**
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ FOCUSABLE_ELEMENTS$1 = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), ' +
        'button:not([disabled]), iframe, object, embed, [tabindex], [contenteditable]';
    var MdcDrawer = /** @class */ (function () {
        function MdcDrawer(_changeDetectorRef, renderer, elementRef, _registry) {
            var _this = this;
            this._changeDetectorRef = _changeDetectorRef;
            this.renderer = renderer;
            this.elementRef = elementRef;
            this._registry = _registry;
            this._fixed = false;
            this._drawer = 'permanent';
            this.closeOnClick = true;
            this.opened = new core.EventEmitter();
            this.closed = new core.EventEmitter();
            this.isHostClass = true;
            this.role = 'navigation';
            this._mdcAdapter = {
                addClass: function (className) { return _this.renderer.addClass(_this._getHostElement(), className); },
                removeClass: function (className) { return _this.renderer.removeClass(_this._getHostElement(), className); },
                hasClass: function (className) { return _this._getHostElement().classList.contains(className); },
                addBodyClass: function (className) {
                    if (isBrowser()) {
                        _this.renderer.addClass(_this.fixedAdjustElement
                            ? _this.fixedAdjustElement : document.body, className);
                    }
                },
                removeBodyClass: function (className) {
                    if (isBrowser()) {
                        _this.renderer.removeClass(_this.fixedAdjustElement
                            ? _this.fixedAdjustElement : document.body, className);
                    }
                },
                eventTargetHasClass: function (target, className) { return target.classList.contains(className); },
                hasNecessaryDom: function () { return !!_this.drawerNav; },
                registerInteractionHandler: function (evt, handler) {
                    return _this._registry.listen(remapEvent(evt), handler, _this._getHostElement(), applyPassive$6());
                },
                deregisterInteractionHandler: function (evt, handler) { return _this._registry.unlisten(evt, handler); },
                registerDrawerInteractionHandler: function (evt, handler) {
                    if (_this.drawerElement) {
                        _this._registry.listen(remapEvent(evt), handler, _this.drawerElement.nativeElement);
                    }
                },
                deregisterDrawerInteractionHandler: function (evt, handler) { return _this._registry.unlisten(evt, handler); },
                registerTransitionEndHandler: function (handler) {
                    if (_this.drawerElement) {
                        _this._registry.listen('transitionend', handler, _this.drawerElement.nativeElement);
                    }
                },
                deregisterTransitionEndHandler: function (handler) { return _this._registry.unlisten('transitionend', handler); },
                registerDocumentKeydownHandler: function (handler) {
                    if (isBrowser()) {
                        _this._registry.listen('keydown', handler, document);
                    }
                },
                deregisterDocumentKeydownHandler: function (handler) { return _this._registry.unlisten('keydown', handler); },
                getDrawerWidth: function () { return _this._getHostElement().offsetWidth; },
                setTranslateX: function (value) {
                    if (_this.drawerNav) {
                        _this.renderer.setProperty(_this.drawerNav.elementRef, getTransformPropertyName(), value === null ? null : "translateX(" + value + "px)");
                    }
                },
                updateCssVariable: function (value) {
                    if (supportsCssCustomProperties()) {
                        _this.renderer.setStyle(_this._getHostElement(), '--mdc-temporary-drawer-opacity', value);
                    }
                },
                getFocusableElements: function () {
                    return _this.drawerNav ? _this.drawerNav.elementRef.nativeElement.querySelectorAll(FOCUSABLE_ELEMENTS$1) : null;
                },
                saveElementTabState: function (el) { return saveElementTabState(el); },
                restoreElementTabState: function (el) { return restoreElementTabState(el); },
                makeElementUntabbable: function (el) { return _this.renderer.setAttribute(el, 'tabindex', '-1'); },
                notifyOpen: function () { return _this.opened.emit(); },
                notifyClose: function () { return _this.closed.emit(); },
                isRtl: function () { return getComputedStyle(_this._getHostElement()).direction === 'rtl'; },
                isDrawer: function (el) {
                    return _this.drawerNav ? el === _this.drawerNav.elementRef.nativeElement : false;
                }
            };
            this._initializeFoundation(this._drawer);
        }
        Object.defineProperty(MdcDrawer.prototype, "fixed", {
            get: /**
             * @return {?}
             */
            function () { return this._fixed; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setFixed(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcDrawer.prototype, "drawer", {
            get: /**
             * @return {?}
             */
            function () { return this._drawer; },
            set: /**
             * @param {?} drawer
             * @return {?}
             */
            function (drawer) {
                this.setDrawer(drawer);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcDrawer.prototype, "fixedAdjustElement", {
            get: /**
             * @return {?}
             */
            function () { return this._fixedAdjustElement; },
            set: /**
             * @param {?} element
             * @return {?}
             */
            function (element) {
                this.setFixedAdjustElement(element);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcDrawer.prototype, "drawerElement", {
            get: /**
             * @return {?}
             */
            function () {
                return this.drawerNav && this.drawerNav.elementRef;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcDrawer.prototype, "classFixed", {
            get: /**
             * @return {?}
             */
            function () {
                return this.fixed && this.isDrawerPermanent() ? 'ng-mdc-drawer--fixed' : '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcDrawer.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this._foundation) {
                this._foundation.destroy();
            }
        };
        /**
         * @param {?} drawer
         * @return {?}
         */
        MdcDrawer.prototype.setDrawer = /**
         * @param {?} drawer
         * @return {?}
         */
        function (drawer) {
            var _this = this;
            this._drawer = drawer ? drawer : 'permanent';
            this._initializeFoundation(drawer);
            if (drawer === 'temporary') {
                this._registry.listen('click', function () {
                    if (_this.closeOnClick) {
                        _this._foundation.close();
                    }
                }, this.drawerElement.nativeElement);
            }
            else if (drawer === 'temporary') {
                this._registry.unlisten('click', function () {
                    if (_this.closeOnClick) {
                        _this._foundation.close();
                    }
                });
            }
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} element
         * @return {?}
         */
        MdcDrawer.prototype.setFixedAdjustElement = /**
         * @param {?} element
         * @return {?}
         */
        function (element) {
            this._fixedAdjustElement = element;
            if (element) {
                this.renderer.setStyle(this._getHostElement(), 'position', 'absolute');
            }
            else {
                this.renderer.removeStyle(this._getHostElement(), 'position');
            }
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} fixed
         * @return {?}
         */
        MdcDrawer.prototype.setFixed = /**
         * @param {?} fixed
         * @return {?}
         */
        function (fixed) {
            this._fixed = fixed;
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @return {?}
         */
        MdcDrawer.prototype.isDrawerPermanent = /**
         * @return {?}
         */
        function () {
            return this._drawer === 'permanent';
        };
        /**
         * @return {?}
         */
        MdcDrawer.prototype.isDrawerTemporary = /**
         * @return {?}
         */
        function () {
            return this._drawer === 'temporary';
        };
        /**
         * @return {?}
         */
        MdcDrawer.prototype.isDrawerPersistent = /**
         * @return {?}
         */
        function () {
            return this._drawer === 'persistent';
        };
        /**
         * @param {?} drawer
         * @return {?}
         */
        MdcDrawer.prototype._initializeFoundation = /**
         * @param {?} drawer
         * @return {?}
         */
        function (drawer) {
            this._removeDrawerModifierClass();
            this.renderer.addClass(this._getHostElement(), "mdc-drawer--" + drawer);
            if (!this.isDrawerPermanent()) {
                if (drawer === 'temporary') {
                    this._foundation = new MDCTemporaryDrawerFoundation(this._mdcAdapter);
                }
                else if (drawer === 'persistent') {
                    this._foundation = new MDCPersistentDrawerFoundation(this._mdcAdapter);
                }
                this._foundation.init();
            }
            else {
                if (this._foundation) {
                    this._foundation.destroy();
                }
            }
        };
        /**
         * @return {?}
         */
        MdcDrawer.prototype._removeDrawerModifierClass = /**
         * @return {?}
         */
        function () {
            this.renderer.removeClass(this._getHostElement(), 'mdc-drawer--temporary');
            this.renderer.removeClass(this._getHostElement(), 'mdc-drawer--persistent');
            this.renderer.removeClass(this._getHostElement(), 'mdc-drawer--permanent');
        };
        /**
         * @return {?}
         */
        MdcDrawer.prototype.isOpen = /**
         * @return {?}
         */
        function () {
            if (this.isDrawerPermanent()) {
                return true;
            }
            return this._foundation.isOpen();
        };
        /**
         * @return {?}
         */
        MdcDrawer.prototype.open = /**
         * @return {?}
         */
        function () {
            if (this._foundation) {
                this.isOpen() ? this._foundation.close() : this._foundation.open();
            }
        };
        /**
         * @return {?}
         */
        MdcDrawer.prototype.close = /**
         * @return {?}
         */
        function () {
            if (this._foundation) {
                this._foundation.close();
            }
        };
        /**
         * @return {?}
         */
        MdcDrawer.prototype.getDrawerWidth = /**
         * @return {?}
         */
        function () {
            return this._foundation ? this._mdcAdapter.getDrawerWidth() : this._getHostElement().offsetWidth;
        };
        /**
         * @return {?}
         */
        MdcDrawer.prototype._getHostElement = /**
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcDrawer.decorators = [
            { type: core.Component, args: [{selector: 'mdc-drawer',
                        exportAs: 'mdcDrawer',
                        template: "\n  <mdc-drawer-navigation>\n    <ng-content></ng-content>\n  </mdc-drawer-navigation>\n  ",
                        providers: [EventRegistry],
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcDrawer.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.Renderer2 },
            { type: core.ElementRef },
            { type: EventRegistry }
        ]; };
        MdcDrawer.propDecorators = {
            fixed: [{ type: core.Input }],
            drawer: [{ type: core.Input }],
            fixedAdjustElement: [{ type: core.Input }],
            closeOnClick: [{ type: core.Input }],
            opened: [{ type: core.Output }],
            closed: [{ type: core.Output }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-drawer',] }],
            role: [{ type: core.HostBinding, args: ['attr.role',] }],
            classFixed: [{ type: core.HostBinding, args: ['class.ng-mdc-drawer--fixed',] }],
            drawerNav: [{ type: core.ViewChild, args: [MdcDrawerNavigation,] }]
        };
        return MdcDrawer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DRAWER_COMPONENTS = [
        MdcDrawer,
        MdcDrawerContent,
        MdcDrawerHeader,
        MdcDrawerHeaderContent,
        MdcDrawerNavigation,
        MdcDrawerSpacer,
    ];
    var MdcDrawerModule = /** @class */ (function () {
        function MdcDrawerModule() {
        }
        MdcDrawerModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: DRAWER_COMPONENTS,
                        declarations: DRAWER_COMPONENTS,
                    },] },
        ];
        return MdcDrawerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcElevation = /** @class */ (function () {
        function MdcElevation(elementRef) {
            this.elementRef = elementRef;
            this._mdcElevation = 0;
        }
        Object.defineProperty(MdcElevation.prototype, "mdcElevation", {
            get: /**
             * @return {?}
             */
            function () { return this._mdcElevation; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._mdcElevation = toNumber(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} changes
         * @return {?}
         */
        MdcElevation.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            var /** @type {?} */ change = changes['mdcElevation'];
            if (change.currentValue < 0 || change.currentValue > 24) {
                throw new Error("Valid mdc-elevation values are 0 through 24");
            }
            if (!change.isFirstChange()) {
                this.elementRef.nativeElement.classList.remove("mdc-elevation--z" + change.previousValue);
            }
            this.elementRef.nativeElement.classList.add("mdc-elevation--z" + change.currentValue);
        };
        MdcElevation.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcElevation]',
                        exportAs: 'mdcElevation'
                    },] },
        ];
        /** @nocollapse */
        MdcElevation.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcElevation.propDecorators = {
            mdcElevation: [{ type: core.Input }]
        };
        return MdcElevation;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcElevationModule = /** @class */ (function () {
        function MdcElevationModule() {
        }
        MdcElevationModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [MdcElevation],
                        declarations: [MdcElevation],
                    },] },
        ];
        return MdcElevationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcFab = /** @class */ (function () {
        function MdcFab(_changeDetectionRef, _renderer, elementRef, _ripple) {
            this._changeDetectionRef = _changeDetectionRef;
            this._renderer = _renderer;
            this.elementRef = elementRef;
            this._ripple = _ripple;
            this.tabIndex = 0;
            this.isHostClass = true;
        }
        Object.defineProperty(MdcFab.prototype, "mini", {
            get: /**
             * @return {?}
             */
            function () { return this._mini; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setMini(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcFab.prototype, "exited", {
            get: /**
             * @return {?}
             */
            function () { return this._exited; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setExited(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcFab.prototype, "extended", {
            get: /**
             * @return {?}
             */
            function () { return this._extended; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setExtended(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcFab.prototype, "position", {
            get: /**
             * @return {?}
             */
            function () { return this._position; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setPosition(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcFab.prototype, "classMini", {
            get: /**
             * @return {?}
             */
            function () {
                return this.mini ? 'mdc-fab--mini' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcFab.prototype, "classExited", {
            get: /**
             * @return {?}
             */
            function () {
                return this.exited ? 'mdc-fab--exited' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcFab.prototype, "classExtended", {
            get: /**
             * @return {?}
             */
            function () {
                return this.extended ? 'mdc-fab--extended' : '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcFab.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            if (this.fabIcon) {
                this._renderer.addClass(this.fabIcon.elementRef.nativeElement, 'mdc-fab__icon');
            }
            this._ripple.attachTo(this._getHostElement());
        };
        /**
         * @return {?}
         */
        MdcFab.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._ripple.destroy();
        };
        /**
         * @param {?} mini
         * @return {?}
         */
        MdcFab.prototype.setMini = /**
         * @param {?} mini
         * @return {?}
         */
        function (mini) {
            this._mini = mini;
            this._changeDetectionRef.markForCheck();
        };
        /**
         * @param {?} exited
         * @return {?}
         */
        MdcFab.prototype.setExited = /**
         * @param {?} exited
         * @return {?}
         */
        function (exited) {
            this._exited = exited;
            this.tabIndex = exited ? -1 : this.tabIndex;
            this._changeDetectionRef.markForCheck();
        };
        /**
         * @param {?} extended
         * @return {?}
         */
        MdcFab.prototype.setExtended = /**
         * @param {?} extended
         * @return {?}
         */
        function (extended) {
            this._extended = extended;
        };
        /**
         * @param {?} position
         * @return {?}
         */
        MdcFab.prototype.setPosition = /**
         * @param {?} position
         * @return {?}
         */
        function (position) {
            this._renderer.removeClass(this._getHostElement(), "mdc-fab--" + this._position);
            this._position = position;
            if (this.position) {
                this._renderer.addClass(this._getHostElement(), "mdc-fab--" + position);
            }
        };
        /**
         * @param {?=} exited
         * @return {?}
         */
        MdcFab.prototype.toggleExited = /**
         * @param {?=} exited
         * @return {?}
         */
        function (exited) {
            this._exited = exited != null ? exited : !this._exited;
        };
        /** Focuses the button. */
        /**
         * Focuses the button.
         * @return {?}
         */
        MdcFab.prototype.focus = /**
         * Focuses the button.
         * @return {?}
         */
        function () {
            this._getHostElement().focus();
        };
        /**
         * @return {?}
         */
        MdcFab.prototype._getHostElement = /**
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcFab.decorators = [
            { type: core.Component, args: [{selector: 'button[mdc-fab], a[mdc-fab]',
                        template: "\n  <ng-content></ng-content>\n  <span class=\"mdc-fab__label\" *ngIf=\"label\">{{label}}</span>\n  ",
                        providers: [
                            MdcRipple,
                            EventRegistry
                        ],
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcFab.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.Renderer2 },
            { type: core.ElementRef },
            { type: MdcRipple }
        ]; };
        MdcFab.propDecorators = {
            mini: [{ type: core.Input }],
            exited: [{ type: core.Input }],
            extended: [{ type: core.Input }],
            position: [{ type: core.Input }],
            label: [{ type: core.Input }],
            tabIndex: [{ type: core.Input, args: ['attr.tabindex',] }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-fab',] }],
            classMini: [{ type: core.HostBinding, args: ['class.mdc-fab--mini',] }],
            classExited: [{ type: core.HostBinding, args: ['class.mdc-fab--exited',] }],
            classExtended: [{ type: core.HostBinding, args: ['class.mdc-fab--extended',] }],
            fabIcon: [{ type: core.ContentChild, args: [MdcIcon,] }]
        };
        return MdcFab;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcFabModule = /** @class */ (function () {
        function MdcFabModule() {
        }
        MdcFabModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [MdcIconModule, common.CommonModule],
                        exports: [MdcFab],
                        declarations: [MdcFab],
                    },] },
        ];
        return MdcFabModule;
    }());

    function _classCallCheck$8(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$8(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$8(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$8(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$8(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$8(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$8(subClass, superClass);
    }

    function _getPrototypeOf$8(o) {
      _getPrototypeOf$8 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$8(o);
    }

    function _setPrototypeOf$8(o, p) {
      _setPrototypeOf$8 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$8(o, p);
    }

    function _assertThisInitialized$8(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$8(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$8(self);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @template A
     */
    var MDCFoundation$7 =
    /*#__PURE__*/
    function () {
      _createClass$8(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$8(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$8(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$7 =
    /*#__PURE__*/
    function () {
      _createClass$8(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$7());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$8(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$8(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2017 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Floating Label.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the floating label into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCFloatingLabelAdapter =
    /*#__PURE__*/
    function () {
      function MDCFloatingLabelAdapter() {
        _classCallCheck$8(this, MDCFloatingLabelAdapter);
      }

      _createClass$8(MDCFloatingLabelAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the label element.
         * @param {string} className
         */
        value: function addClass(className) {}
        /**
         * Removes a class from the label element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Returns the width of the label element.
         * @return {number}
         */

      }, {
        key: "getWidth",
        value: function getWidth() {}
        /**
         * Registers an event listener on the root element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * Deregisters an event listener on the root element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
      }]);

      return MDCFloatingLabelAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var cssClasses$7 = {
      LABEL_FLOAT_ABOVE: 'mdc-floating-label--float-above',
      LABEL_SHAKE: 'mdc-floating-label--shake'
    };

    /**
     * @extends {MDCFoundation<!MDCFloatingLabelAdapter>}
     * @final
     */

    var MDCFloatingLabelFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$8(MDCFloatingLabelFoundation, _MDCFoundation);

      _createClass$8(MDCFloatingLabelFoundation, null, [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$7;
        }
        /**
         * {@see MDCFloatingLabelAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCFloatingLabelAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCFloatingLabelAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              getWidth: function getWidth() {},
              registerInteractionHandler: function registerInteractionHandler() {},
              deregisterInteractionHandler: function deregisterInteractionHandler() {}
            }
          );
        }
        /**
         * @param {!MDCFloatingLabelAdapter} adapter
         */

      }]);

      function MDCFloatingLabelFoundation(adapter) {
        var _this;

        _classCallCheck$8(this, MDCFloatingLabelFoundation);

        _this = _possibleConstructorReturn$8(this, _getPrototypeOf$8(MDCFloatingLabelFoundation).call(this, Object.assign(MDCFloatingLabelFoundation.defaultAdapter, adapter)));
        /** @private {function(!Event): undefined} */

        _this.shakeAnimationEndHandler_ = function () {
          return _this.handleShakeAnimationEnd_();
        };

        return _this;
      }

      _createClass$8(MDCFloatingLabelFoundation, [{
        key: "init",
        value: function init() {
          this.adapter_.registerInteractionHandler('animationend', this.shakeAnimationEndHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.adapter_.deregisterInteractionHandler('animationend', this.shakeAnimationEndHandler_);
        }
        /**
         * Returns the width of the label element.
         * @return {number}
         */

      }, {
        key: "getWidth",
        value: function getWidth() {
          return this.adapter_.getWidth();
        }
        /**
         * Styles the label to produce the label shake for errors.
         * @param {boolean} shouldShake adds shake class if true,
         * otherwise removes shake class.
         */

      }, {
        key: "shake",
        value: function shake(shouldShake) {
          var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;

          if (shouldShake) {
            this.adapter_.addClass(LABEL_SHAKE);
          } else {
            this.adapter_.removeClass(LABEL_SHAKE);
          }
        }
        /**
         * Styles the label to float or dock.
         * @param {boolean} shouldFloat adds float class if true, otherwise remove
         * float and shake class to dock label.
         */

      }, {
        key: "float",
        value: function float(shouldFloat) {
          var _MDCFloatingLabelFoun = MDCFloatingLabelFoundation.cssClasses,
              LABEL_FLOAT_ABOVE = _MDCFloatingLabelFoun.LABEL_FLOAT_ABOVE,
              LABEL_SHAKE = _MDCFloatingLabelFoun.LABEL_SHAKE;

          if (shouldFloat) {
            this.adapter_.addClass(LABEL_FLOAT_ABOVE);
          } else {
            this.adapter_.removeClass(LABEL_FLOAT_ABOVE);
            this.adapter_.removeClass(LABEL_SHAKE);
          }
        }
        /**
         * Handles an interaction event on the root element.
         */

      }, {
        key: "handleShakeAnimationEnd_",
        value: function handleShakeAnimationEnd_() {
          var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;
          this.adapter_.removeClass(LABEL_SHAKE);
        }
      }]);

      return MDCFloatingLabelFoundation;
    }(MDCFoundation$7);

    /**
     * @extends {MDCComponent<!MDCFloatingLabelFoundation>}
     * @final
     */

    var MDCFloatingLabel =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$8(MDCFloatingLabel, _MDCComponent);

      function MDCFloatingLabel() {
        _classCallCheck$8(this, MDCFloatingLabel);

        return _possibleConstructorReturn$8(this, _getPrototypeOf$8(MDCFloatingLabel).apply(this, arguments));
      }

      _createClass$8(MDCFloatingLabel, [{
        key: "shake",

        /**
         * Styles the label to produce the label shake for errors.
         * @param {boolean} shouldShake styles the label to shake by adding shake class
         * if true, otherwise will stop shaking by removing shake class.
         */
        value: function shake(shouldShake) {
          this.foundation_.shake(shouldShake);
        }
        /**
         * Styles label to float/dock.
         * @param {boolean} shouldFloat styles the label to float by adding float class
         * if true, otherwise docks the label by removing the float class.
         */

      }, {
        key: "float",
        value: function float(shouldFloat) {
          this.foundation_.float(shouldFloat);
        }
        /**
         * @return {number}
         */

      }, {
        key: "getWidth",
        value: function getWidth() {
          return this.foundation_.getWidth();
        }
        /**
         * @return {!MDCFloatingLabelFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCFloatingLabelFoundation({
            addClass: function addClass(className) {
              return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this.root_.classList.remove(className);
            },
            getWidth: function getWidth() {
              return _this.root_.offsetWidth;
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return _this.root_.addEventListener(evtType, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return _this.root_.removeEventListener(evtType, handler);
            }
          });
        }
      }], [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCFloatingLabel}
         */
        value: function attachTo(root) {
          return new MDCFloatingLabel(root);
        }
      }]);

      return MDCFloatingLabel;
    }(MDCComponent$7);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcFloatingLabel = /** @class */ (function () {
        function MdcFloatingLabel(elementRef, _registry) {
            var _this = this;
            this.elementRef = elementRef;
            this._registry = _registry;
            this.isHostClass = true;
            this._mdcAdapter = {
                addClass: function (className) { return _this._getHostElement().classList.add(className); },
                removeClass: function (className) { return _this._getHostElement().classList.remove(className); },
                getWidth: function () { return _this._getHostElement().offsetWidth; },
                registerInteractionHandler: function (evtType, handler) {
                    return _this._registry.listen(evtType, handler, _this._getHostElement());
                },
                deregisterInteractionHandler: function (evtType, handler) { return _this._registry.unlisten(evtType, handler); },
            };
            this.foundation = new MDCFloatingLabelFoundation(this._mdcAdapter);
        }
        /**
         * @return {?}
         */
        MdcFloatingLabel.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.foundation.init();
        };
        /**
         * @return {?}
         */
        MdcFloatingLabel.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.foundation.destroy();
        };
        /** Returns the width of the label element. */
        /**
         * Returns the width of the label element.
         * @return {?}
         */
        MdcFloatingLabel.prototype.getWidth = /**
         * Returns the width of the label element.
         * @return {?}
         */
        function () {
            return this.foundation.getWidth();
        };
        /** Styles the label to produce the label shake for errors. */
        /**
         * Styles the label to produce the label shake for errors.
         * @param {?} shouldShake
         * @return {?}
         */
        MdcFloatingLabel.prototype.shake = /**
         * Styles the label to produce the label shake for errors.
         * @param {?} shouldShake
         * @return {?}
         */
        function (shouldShake) {
            this.foundation.shake(shouldShake);
        };
        /** Styles the label to float or dock. */
        /**
         * Styles the label to float or dock.
         * @param {?} shouldFloat
         * @return {?}
         */
        MdcFloatingLabel.prototype.float = /**
         * Styles the label to float or dock.
         * @param {?} shouldFloat
         * @return {?}
         */
        function (shouldFloat) {
            this.foundation.float(shouldFloat);
        };
        /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        MdcFloatingLabel.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcFloatingLabel.decorators = [
            { type: core.Component, args: [{
                        selector: 'label[mdcFloatingLabel], mdc-floating-label',
                        template: '<ng-content></ng-content>',
                        exportAs: 'mdcFloatingLabel',
                        providers: [EventRegistry],
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcFloatingLabel.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: EventRegistry }
        ]; };
        MdcFloatingLabel.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-floating-label',] }]
        };
        return MdcFloatingLabel;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcFloatingLabelModule = /** @class */ (function () {
        function MdcFloatingLabelModule() {
        }
        MdcFloatingLabelModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [MdcFloatingLabel],
                        declarations: [MdcFloatingLabel],
                    },] },
        ];
        return MdcFloatingLabelModule;
    }());

    function _classCallCheck$9(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$9(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$9(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$9(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$9(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$9(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$9(subClass, superClass);
    }

    function _getPrototypeOf$9(o) {
      _getPrototypeOf$9 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$9(o);
    }

    function _setPrototypeOf$9(o, p) {
      _setPrototypeOf$9 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$9(o, p);
    }

    function _assertThisInitialized$9(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$9(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$9(self);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @template A
     */
    var MDCFoundation$8 =
    /*#__PURE__*/
    function () {
      _createClass$9(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$9(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$9(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$8 =
    /*#__PURE__*/
    function () {
      _createClass$9(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$8());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$9(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$9(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var strings$7 = {
      TILES_SELECTOR: '.mdc-grid-list__tiles',
      TILE_SELECTOR: '.mdc-grid-tile'
    };

    var MDCGridListFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$9(MDCGridListFoundation, _MDCFoundation);

      _createClass$9(MDCGridListFoundation, null, [{
        key: "strings",
        get: function get() {
          return strings$7;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            getOffsetWidth: function getOffsetWidth() {
              return (
                /* number */
                0
              );
            },
            getNumberOfTiles: function getNumberOfTiles() {
              return (
                /* number */
                0
              );
            },
            getOffsetWidthForTileAtIndex: function getOffsetWidthForTileAtIndex() {
              return (
                /* index: number */

                /* number */
                0
              );
            },
            setStyleForTilesElement: function setStyleForTilesElement()
            /* property: string, value: string */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {}
          };
        }
      }]);

      function MDCGridListFoundation(adapter) {
        var _this;

        _classCallCheck$9(this, MDCGridListFoundation);

        _this = _possibleConstructorReturn$9(this, _getPrototypeOf$9(MDCGridListFoundation).call(this, Object.assign(MDCGridListFoundation.defaultAdapter, adapter)));

        _this.resizeHandler_ = function () {
          return _this.alignCenter();
        };

        _this.resizeFrame_ = 0;
        return _this;
      }

      _createClass$9(MDCGridListFoundation, [{
        key: "init",
        value: function init() {
          this.alignCenter();
          this.adapter_.registerResizeHandler(this.resizeHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.adapter_.deregisterResizeHandler(this.resizeHandler_);
        }
      }, {
        key: "alignCenter",
        value: function alignCenter() {
          var _this2 = this;

          if (this.resizeFrame_ !== 0) {
            cancelAnimationFrame(this.resizeFrame_);
          }

          this.resizeFrame_ = requestAnimationFrame(function () {
            _this2.alignCenter_();

            _this2.resizeFrame_ = 0;
          });
        }
      }, {
        key: "alignCenter_",
        value: function alignCenter_() {
          if (this.adapter_.getNumberOfTiles() == 0) {
            return;
          }

          var gridWidth = this.adapter_.getOffsetWidth();
          var itemWidth = this.adapter_.getOffsetWidthForTileAtIndex(0);
          var tilesWidth = itemWidth * Math.floor(gridWidth / itemWidth);
          this.adapter_.setStyleForTilesElement('width', "".concat(tilesWidth, "px"));
        }
      }]);

      return MDCGridListFoundation;
    }(MDCFoundation$8);

    var MDCGridList =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$9(MDCGridList, _MDCComponent);

      function MDCGridList() {
        _classCallCheck$9(this, MDCGridList);

        return _possibleConstructorReturn$9(this, _getPrototypeOf$9(MDCGridList).apply(this, arguments));
      }

      _createClass$9(MDCGridList, [{
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCGridListFoundation({
            getOffsetWidth: function getOffsetWidth() {
              return _this.root_.offsetWidth;
            },
            getNumberOfTiles: function getNumberOfTiles() {
              return _this.root_.querySelectorAll(MDCGridListFoundation.strings.TILE_SELECTOR).length;
            },
            getOffsetWidthForTileAtIndex: function getOffsetWidthForTileAtIndex(index) {
              return _this.root_.querySelectorAll(MDCGridListFoundation.strings.TILE_SELECTOR)[index].offsetWidth;
            },
            setStyleForTilesElement: function setStyleForTilesElement(property, value) {
              _this.root_.querySelector(MDCGridListFoundation.strings.TILES_SELECTOR).style[property] = value;
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            }
          });
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCGridList(root);
        }
      }]);

      return MDCGridList;
    }(MDCComponent$8);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ MDC_VALID_ASPECTS = [
        '1x1',
        '16x9',
        '2x3',
        '3x2',
        '4x3',
        '3x4'
    ];
    var MdcGridTileTitle = /** @class */ (function () {
        function MdcGridTileTitle(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcGridTileTitle.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-grid-tile-title, [mdcGridTileTitle]',
                        exportAs: 'mdcGridTileTitle'
                    },] },
        ];
        /** @nocollapse */
        MdcGridTileTitle.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcGridTileTitle.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-grid-tile__title',] }]
        };
        return MdcGridTileTitle;
    }());
    var MdcGridTileSupportText = /** @class */ (function () {
        function MdcGridTileSupportText(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcGridTileSupportText.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-grid-tile-support-text, [mdcGridTileSupportText]',
                        exportAs: 'mdcGridTileSupportText'
                    },] },
        ];
        /** @nocollapse */
        MdcGridTileSupportText.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcGridTileSupportText.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-grid-tile__support-text',] }]
        };
        return MdcGridTileSupportText;
    }());
    var MdcGridTilePrimary = /** @class */ (function () {
        function MdcGridTilePrimary(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcGridTilePrimary.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-grid-tile-primary, [mdcGridTilePrimary]',
                        exportAs: 'mdcGridTilePrimary'
                    },] },
        ];
        /** @nocollapse */
        MdcGridTilePrimary.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcGridTilePrimary.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-grid-tile__primary',] }]
        };
        return MdcGridTilePrimary;
    }());
    var MdcGridTilePrimaryContent = /** @class */ (function () {
        function MdcGridTilePrimaryContent() {
            this.isHostClass = true;
        }
        MdcGridTilePrimaryContent.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcGridTilePrimaryContent], mdc-grid-tile-primary-content',
                        exportAs: 'mdcGridTilePrimaryContent'
                    },] },
        ];
        MdcGridTilePrimaryContent.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-grid-tile__primary-content',] }]
        };
        return MdcGridTilePrimaryContent;
    }());
    var MdcGridTileSecondary = /** @class */ (function () {
        function MdcGridTileSecondary(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcGridTileSecondary.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-grid-tile-secondary, [mdcGridTileSecondary]',
                        exportAs: 'mdcGridTileSecondary'
                    },] },
        ];
        /** @nocollapse */
        MdcGridTileSecondary.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcGridTileSecondary.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-grid-tile__secondary',] }]
        };
        return MdcGridTileSecondary;
    }());
    var MdcGridTile = /** @class */ (function () {
        function MdcGridTile(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcGridTile.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-grid-tile, [mdcGridTile]',
                        exportAs: 'mdcGridTile'
                    },] },
        ];
        /** @nocollapse */
        MdcGridTile.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcGridTile.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-grid-tile',] }]
        };
        return MdcGridTile;
    }());
    var MdcGridListTiles = /** @class */ (function () {
        function MdcGridListTiles(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcGridListTiles.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-grid-list-tiles, [mdcGridListTiles]',
                        exportAs: 'mdcGridListTiles'
                    },] },
        ];
        /** @nocollapse */
        MdcGridListTiles.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcGridListTiles.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-grid-list__tiles',] }]
        };
        return MdcGridListTiles;
    }());
    var MdcGridList = /** @class */ (function () {
        function MdcGridList(_changeDetectorRef, _renderer, elementRef, _registry) {
            var _this = this;
            this._changeDetectorRef = _changeDetectorRef;
            this._renderer = _renderer;
            this.elementRef = elementRef;
            this._registry = _registry;
            /**
             * Emits whenever the component is destroyed.
             */
            this._destroy = new rxjs.Subject();
            this._header = false;
            this._aspect = '1x1';
            this.iconAlign = 'start';
            this.isHostClass = true;
            this._mdcAdapter = {
                getOffsetWidth: function () { return _this._getHostElement().offsetWidth; },
                getNumberOfTiles: function () { return _this.tiles.length; },
                getOffsetWidthForTileAtIndex: function (index) {
                    var /** @type {?} */ tile = _this.getTile(index);
                    return tile ? tile.elementRef.nativeElement.offsetWidth : 0;
                },
                setStyleForTilesElement: function (property, value) {
                    return _this._renderer.setStyle(_this.gridListTiles.elementRef.nativeElement, property, value);
                },
                registerResizeHandler: function (handler) {
                    if (isBrowser()) {
                        _this._registry.listen('resize', handler, window);
                    }
                },
                deregisterResizeHandler: function (handler) {
                    if (isBrowser()) {
                        _this._registry.unlisten('resize', handler);
                    }
                }
            };
        }
        Object.defineProperty(MdcGridList.prototype, "narrow", {
            get: /**
             * @return {?}
             */
            function () { return this._narrow; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setNarrow(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcGridList.prototype, "header", {
            get: /**
             * @return {?}
             */
            function () { return this._header; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setHeader(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcGridList.prototype, "aspect", {
            get: /**
             * @return {?}
             */
            function () { return this._aspect; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (this._foundation && value !== this._aspect) {
                    this.setAspect(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcGridList.prototype, "classGutter", {
            get: /**
             * @return {?}
             */
            function () {
                return this.narrow ? 'mdc-grid-list--tile-gutter-1' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcGridList.prototype, "classheader", {
            get: /**
             * @return {?}
             */
            function () {
                return this.header ? 'mdc-grid-list--header-caption' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcGridList.prototype, "classIconAlignStart", {
            get: /**
             * @return {?}
             */
            function () {
                return this.icons.length > 0 && this.iconAlign === 'start' ? 'mdc-grid-list--with-icon-align-start' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcGridList.prototype, "classIconAlignEnd", {
            get: /**
             * @return {?}
             */
            function () {
                return this.icons.length > 0 && this.iconAlign === 'end' ? 'mdc-grid-list--with-icon-align-end' : '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcGridList.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this._foundation = new MDCGridListFoundation(this._mdcAdapter);
            this._foundation.init();
            this.setAspect(this.aspect);
        };
        /**
         * @return {?}
         */
        MdcGridList.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.captions.changes.pipe(operators.startWith(null), operators.takeUntil(this._destroy)).subscribe(function () {
                Promise.resolve().then(function () {
                    var /** @type {?} */ cssClass = 'mdc-grid-list--twoline-caption';
                    _this.captions.length > 0 ? _this._renderer.addClass(_this._getHostElement(), cssClass)
                        : _this._renderer.removeClass(_this._getHostElement(), cssClass);
                });
            });
            this.icons.changes.pipe(operators.startWith(null), operators.takeUntil(this._destroy)).subscribe(function () {
                Promise.resolve().then(function () {
                    _this.icons.forEach(function (icon) {
                        _this._renderer.addClass(icon.elementRef.nativeElement, 'mdc-grid-tile__icon');
                    });
                });
            });
        };
        /**
         * @return {?}
         */
        MdcGridList.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroy.next();
            this._destroy.complete();
            this._foundation.destroy();
        };
        /**
         * @param {?} narrow
         * @return {?}
         */
        MdcGridList.prototype.setNarrow = /**
         * @param {?} narrow
         * @return {?}
         */
        function (narrow) {
            this._narrow = toBoolean(narrow);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} header
         * @return {?}
         */
        MdcGridList.prototype.setHeader = /**
         * @param {?} header
         * @return {?}
         */
        function (header) {
            this._header = toBoolean(header);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} aspect
         * @return {?}
         */
        MdcGridList.prototype.setAspect = /**
         * @param {?} aspect
         * @return {?}
         */
        function (aspect) {
            if (this._isAspectValid(aspect)) {
                var /** @type {?} */ cssClass = 'mdc-grid-list--tile-aspect-';
                this._renderer.removeClass(this._getHostElement(), "" + cssClass + this.aspect);
                this._renderer.addClass(this._getHostElement(), "" + cssClass + aspect);
                this._aspect = aspect;
                this._changeDetectorRef.markForCheck();
            }
        };
        /**
         * @param {?} index
         * @return {?}
         */
        MdcGridList.prototype.getTile = /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            return this.tiles.toArray()[index];
        };
        /**
         * @return {?}
         */
        MdcGridList.prototype.alignCenter = /**
         * @return {?}
         */
        function () {
            this._foundation.alignCenter();
        };
        /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        MdcGridList.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        /** Make sure the aspect is supported. */
        /**
         * Make sure the aspect is supported.
         * @param {?} aspect
         * @return {?}
         */
        MdcGridList.prototype._isAspectValid = /**
         * Make sure the aspect is supported.
         * @param {?} aspect
         * @return {?}
         */
        function (aspect) {
            return MDC_VALID_ASPECTS.indexOf(aspect) > -1 ? true : false;
        };
        MdcGridList.decorators = [
            { type: core.Component, args: [{selector: '[mdc-grid-list], mdc-grid-list',
                        exportAs: 'mdcGridList',
                        template: "\n  <mdc-grid-list-tiles>\n    <ng-content></ng-content>\n  </mdc-grid-list-tiles>\n  ",
                        providers: [EventRegistry],
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcGridList.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.Renderer2 },
            { type: core.ElementRef },
            { type: EventRegistry }
        ]; };
        MdcGridList.propDecorators = {
            narrow: [{ type: core.Input }],
            header: [{ type: core.Input }],
            aspect: [{ type: core.Input }],
            iconAlign: [{ type: core.Input }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-grid-list',] }],
            tiles: [{ type: core.ContentChildren, args: [MdcGridTile,] }],
            captions: [{ type: core.ContentChildren, args: [MdcGridTileSupportText, { descendants: true },] }],
            icons: [{ type: core.ContentChildren, args: [MdcIcon, { descendants: true },] }],
            primaries: [{ type: core.ContentChildren, args: [MdcGridTilePrimary, { descendants: true },] }],
            gridListTiles: [{ type: core.ViewChild, args: [MdcGridListTiles,] }],
            classGutter: [{ type: core.HostBinding, args: ['class.mdc-grid-list--tile-gutter-1',] }],
            classheader: [{ type: core.HostBinding, args: ['class.mdc-grid-list--header-caption',] }],
            classIconAlignStart: [{ type: core.HostBinding, args: ['class.mdc-grid-list--with-icon-align-start',] }],
            classIconAlignEnd: [{ type: core.HostBinding, args: ['class.mdc-grid-list--with-icon-align-end',] }]
        };
        return MdcGridList;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ GRID_LIST_DECLARATIONS = [
        MdcGridList,
        MdcGridListTiles,
        MdcGridTile,
        MdcGridTilePrimary,
        MdcGridTilePrimaryContent,
        MdcGridTileSecondary,
        MdcGridTileSupportText,
        MdcGridTileTitle,
    ];
    var MdcGridListModule = /** @class */ (function () {
        function MdcGridListModule() {
        }
        MdcGridListModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: GRID_LIST_DECLARATIONS,
                        declarations: GRID_LIST_DECLARATIONS,
                    },] },
        ];
        return MdcGridListModule;
    }());

    function _classCallCheck$a(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$a(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$a(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$a(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$a(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$a(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$a(subClass, superClass);
    }

    function _getPrototypeOf$a(o) {
      _getPrototypeOf$a = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$a(o);
    }

    function _setPrototypeOf$a(o, p) {
      _setPrototypeOf$a = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$a(o, p);
    }

    function _assertThisInitialized$a(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$a(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$a(self);
    }

    function _superPropBase$6(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$a(object);
        if (object === null) break;
      }

      return object;
    }

    function _get$6(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$6 = Reflect.get;
      } else {
        _get$6 = function _get(target, property, receiver) {
          var base = _superPropBase$6(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get$6(target, property, receiver || target);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @template A
     */
    var MDCFoundation$9 =
    /*#__PURE__*/
    function () {
      _createClass$a(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$a(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$a(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$9 =
    /*#__PURE__*/
    function () {
      _createClass$a(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$9());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$a(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$a(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Icon Button Toggle. Provides an interface for managing
     * - classes
     * - dom
     * - inner text
     * - event handlers
     * - event dispatch
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCIconButtonToggleAdapter =
    /*#__PURE__*/
    function () {
      function MDCIconButtonToggleAdapter() {
        _classCallCheck$a(this, MDCIconButtonToggleAdapter);
      }

      _createClass$a(MDCIconButtonToggleAdapter, [{
        key: "addClass",

        /** @param {string} className */
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * @param {string} type
         * @param {!EventListener} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(type, handler) {}
        /**
         * @param {string} type
         * @param {!EventListener} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(type, handler) {}
        /** @param {string} text */

      }, {
        key: "setText",
        value: function setText(text) {}
        /**
         * @param {string} name
         * @return {string}
         */

      }, {
        key: "getAttr",
        value: function getAttr(name) {}
        /**
         * @param {string} name
         * @param {string} value
         */

      }, {
        key: "setAttr",
        value: function setAttr(name, value) {}
        /** @param {!IconButtonToggleEvent} evtData */

      }, {
        key: "notifyChange",
        value: function notifyChange(evtData) {}
      }]);

      return MDCIconButtonToggleAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var cssClasses$8 = {
      ROOT: 'mdc-icon-button'
    };
    /** @enum {string} */

    var strings$8 = {
      DATA_TOGGLE_ON_LABEL: 'data-toggle-on-label',
      DATA_TOGGLE_ON_CONTENT: 'data-toggle-on-content',
      DATA_TOGGLE_ON_CLASS: 'data-toggle-on-class',
      DATA_TOGGLE_OFF_LABEL: 'data-toggle-off-label',
      DATA_TOGGLE_OFF_CONTENT: 'data-toggle-off-content',
      DATA_TOGGLE_OFF_CLASS: 'data-toggle-off-class',
      ARIA_PRESSED: 'aria-pressed',
      ARIA_LABEL: 'aria-label',
      CHANGE_EVENT: 'MDCIconButtonToggle:change'
    };

    /**
     * @extends {MDCFoundation<!MDCIconButtonToggleAdapter>}
     */

    var MDCIconButtonToggleFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$a(MDCIconButtonToggleFoundation, _MDCFoundation);

      _createClass$a(MDCIconButtonToggleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$8;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$8;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* type: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* type: string, handler: EventListener */
            {},
            setText: function setText()
            /* text: string */
            {},
            getAttr: function getAttr() {
              return (
                /* name: string */

                /* string */
                ''
              );
            },
            setAttr: function setAttr()
            /* name: string, value: string */
            {},
            notifyChange: function notifyChange()
            /* evtData: IconButtonToggleEvent */
            {}
          };
        }
      }]);

      function MDCIconButtonToggleFoundation(adapter) {
        var _this;

        _classCallCheck$a(this, MDCIconButtonToggleFoundation);

        _this = _possibleConstructorReturn$a(this, _getPrototypeOf$a(MDCIconButtonToggleFoundation).call(this, Object.assign(MDCIconButtonToggleFoundation.defaultAdapter, adapter)));
        var ARIA_PRESSED = MDCIconButtonToggleFoundation.strings.ARIA_PRESSED;
        /** @private {boolean} */

        _this.on_ = _this.adapter_.getAttr(ARIA_PRESSED) === 'true';
        /** @private {boolean} */

        _this.disabled_ = false;
        /** @private {?IconButtonToggleState} */

        _this.toggleOnData_ = null;
        /** @private {?IconButtonToggleState} */

        _this.toggleOffData_ = null;

        _this.clickHandler_ =
        /** @private {!EventListener} */
        function () {
          return _this.toggleFromEvt_();
        };

        return _this;
      }

      _createClass$a(MDCIconButtonToggleFoundation, [{
        key: "init",
        value: function init() {
          this.refreshToggleData();
          this.adapter_.registerInteractionHandler('click', this.clickHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
        }
      }, {
        key: "refreshToggleData",
        value: function refreshToggleData() {
          this.toggleOnData_ = {
            label: this.adapter_.getAttr(strings$8.DATA_TOGGLE_ON_LABEL),
            content: this.adapter_.getAttr(strings$8.DATA_TOGGLE_ON_CONTENT),
            cssClass: this.adapter_.getAttr(strings$8.DATA_TOGGLE_ON_CLASS)
          };
          this.toggleOffData_ = {
            label: this.adapter_.getAttr(strings$8.DATA_TOGGLE_OFF_LABEL),
            content: this.adapter_.getAttr(strings$8.DATA_TOGGLE_OFF_CONTENT),
            cssClass: this.adapter_.getAttr(strings$8.DATA_TOGGLE_OFF_CLASS)
          };
        }
        /** @private */

      }, {
        key: "toggleFromEvt_",
        value: function toggleFromEvt_() {
          this.toggle();
          var isOn = this.on_;
          this.adapter_.notifyChange(
          /** @type {!IconButtonToggleEvent} */
          {
            isOn: isOn
          });
        }
        /** @return {boolean} */

      }, {
        key: "isOn",
        value: function isOn() {
          return this.on_;
        }
        /** @param {boolean=} isOn */

      }, {
        key: "toggle",
        value: function toggle() {
          var isOn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !this.on_;
          this.on_ = isOn;
          var _MDCIconButtonToggleF = MDCIconButtonToggleFoundation.strings,
              ARIA_LABEL = _MDCIconButtonToggleF.ARIA_LABEL,
              ARIA_PRESSED = _MDCIconButtonToggleF.ARIA_PRESSED;
          this.adapter_.setAttr(ARIA_PRESSED, this.on_.toString());

          var _ref = this.on_ ? this.toggleOffData_ : this.toggleOnData_,
              classToRemove = _ref.cssClass;

          if (classToRemove) {
            this.adapter_.removeClass(classToRemove);
          }

          var _ref2 = this.on_ ? this.toggleOnData_ : this.toggleOffData_,
              content = _ref2.content,
              label = _ref2.label,
              cssClass = _ref2.cssClass;

          if (cssClass) {
            this.adapter_.addClass(cssClass);
          }

          if (content) {
            this.adapter_.setText(content);
          }

          if (label) {
            this.adapter_.setAttr(ARIA_LABEL, label);
          }
        }
      }]);

      return MDCIconButtonToggleFoundation;
    }(MDCFoundation$9);

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Ripple. Provides an interface for managing
     * - classes
     * - dom
     * - CSS variables
     * - position
     * - dimensions
     * - scroll position
     * - event handlers
     * - unbounded, active and disabled states
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCRippleAdapter$6 =
    /*#__PURE__*/
    function () {
      function MDCRippleAdapter() {
        _classCallCheck$a(this, MDCRippleAdapter);
      }

      _createClass$a(MDCRippleAdapter, [{
        key: "browserSupportsCssVars",

        /** @return {boolean} */
        value: function browserSupportsCssVars() {}
        /** @return {boolean} */

      }, {
        key: "isUnbounded",
        value: function isUnbounded() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceActive",
        value: function isSurfaceActive() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceDisabled",
        value: function isSurfaceDisabled() {}
        /** @param {string} className */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @param {!EventTarget} target */

      }, {
        key: "containsEventTarget",
        value: function containsEventTarget(target) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerDocumentInteractionHandler",
        value: function registerDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterDocumentInteractionHandler",
        value: function deregisterDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /**
         * @param {string} varName
         * @param {?number|string} value
         */

      }, {
        key: "updateCssVariable",
        value: function updateCssVariable(varName, value) {}
        /** @return {!ClientRect} */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}
        /** @return {{x: number, y: number}} */

      }, {
        key: "getWindowPageOffset",
        value: function getWindowPageOffset() {}
      }]);

      return MDCRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var cssClasses$1$7 = {
      // Ripple is a special case where the "root" component is really a "mixin" of sorts,
      // given that it's an 'upgrade' to an existing component. That being said it is the root
      // CSS class that all other CSS classes derive from.
      ROOT: 'mdc-ripple-upgraded',
      UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
      BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
      FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
      FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
    };
    var strings$1$7 = {
      VAR_LEFT: '--mdc-ripple-left',
      VAR_TOP: '--mdc-ripple-top',
      VAR_FG_SIZE: '--mdc-ripple-fg-size',
      VAR_FG_SCALE: '--mdc-ripple-fg-scale',
      VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
      VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
    };
    var numbers$6 = {
      PADDING: 10,
      INITIAL_ORIGIN_SCALE: 0.6,
      DEACTIVATION_TIMEOUT_MS: 225,
      // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
      FG_DEACTIVATION_MS: 150,
      // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
      TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

    };

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
     * @private {boolean|undefined}
     */
    var supportsCssVariables_$6;
    /**
     * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
     * @private {boolean|undefined}
     */

    var supportsPassive_$7;
    /**
     * @param {!Window} windowObj
     * @return {boolean}
     */

    function detectEdgePseudoVarBug$6(windowObj) {
      // Detect versions of Edge with buggy var() support
      // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
      var document = windowObj.document;
      var node = document.createElement('div');
      node.className = 'mdc-ripple-surface--test-edge-var-bug';
      document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
      // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
      // but Firefox is known to support CSS custom properties correctly.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

      var computedStyle = windowObj.getComputedStyle(node);
      var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
      node.remove();
      return hasPseudoVarBug;
    }
    /**
     * @param {!Window} windowObj
     * @param {boolean=} forceRefresh
     * @return {boolean|undefined}
     */


    function supportsCssVariables$6(windowObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var supportsCssVariables = supportsCssVariables_$6;

      if (typeof supportsCssVariables_$6 === 'boolean' && !forceRefresh) {
        return supportsCssVariables;
      }

      var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

      if (!supportsFunctionPresent) {
        return;
      }

      var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
      // See: README section on Safari

      var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

      if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVariables = !detectEdgePseudoVarBug$6(windowObj);
      } else {
        supportsCssVariables = false;
      }

      if (!forceRefresh) {
        supportsCssVariables_$6 = supportsCssVariables;
      }

      return supportsCssVariables;
    } //

    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|{passive: boolean}}
     */


    function applyPassive$7() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_$7 === undefined || forceRefresh) {
        var isSupported = false;

        try {
          globalObj.document.addEventListener('test', null, {
            get passive() {
              isSupported = true;
            }

          });
        } catch (e) {}

        supportsPassive_$7 = isSupported;
      }

      return supportsPassive_$7 ? {
        passive: true
      } : false;
    }
    /**
     * @param {!Object} HTMLElementPrototype
     * @return {!Array<string>}
     */


    function getMatchesProperty$6(HTMLElementPrototype) {
      return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(function (p) {
        return p in HTMLElementPrototype;
      }).pop();
    }
    /**
     * @param {!Event} ev
     * @param {{x: number, y: number}} pageOffset
     * @param {!ClientRect} clientRect
     * @return {{x: number, y: number}}
     */


    function getNormalizedEventCoords$6(ev, pageOffset, clientRect) {
      var x = pageOffset.x,
          y = pageOffset.y;
      var documentX = x + clientRect.left;
      var documentY = y + clientRect.top;
      var normalizedX;
      var normalizedY; // Determine touch point relative to the ripple container.

      if (ev.type === 'touchstart') {
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
      } else {
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
      }

      return {
        x: normalizedX,
        y: normalizedY
      };
    }

    var ACTIVATION_EVENT_TYPES$6 = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

    var POINTER_DEACTIVATION_EVENT_TYPES$6 = ['touchend', 'pointerup', 'mouseup']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

    /** @type {!Array<!EventTarget>} */

    var activatedTargets$6 = [];
    /**
     * @extends {MDCFoundation<!MDCRippleAdapter>}
     */

    var MDCRippleFoundation$6 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$a(MDCRippleFoundation, _MDCFoundation);

      _createClass$a(MDCRippleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$1$7;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$1$7;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers$6;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            browserSupportsCssVars: function browserSupportsCssVars()
            /* boolean - cached */
            {},
            isUnbounded: function isUnbounded()
            /* boolean */
            {},
            isSurfaceActive: function isSurfaceActive()
            /* boolean */
            {},
            isSurfaceDisabled: function isSurfaceDisabled()
            /* boolean */
            {},
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            containsEventTarget: function containsEventTarget()
            /* target: !EventTarget */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            updateCssVariable: function updateCssVariable()
            /* varName: string, value: string */
            {},
            computeBoundingRect: function computeBoundingRect()
            /* ClientRect */
            {},
            getWindowPageOffset: function getWindowPageOffset()
            /* {x: number, y: number} */
            {}
          };
        }
      }]);

      function MDCRippleFoundation(adapter) {
        var _this;

        _classCallCheck$a(this, MDCRippleFoundation);

        _this = _possibleConstructorReturn$a(this, _getPrototypeOf$a(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
        /** @private {number} */

        _this.layoutFrame_ = 0;
        /** @private {!ClientRect} */

        _this.frame_ =
        /** @type {!ClientRect} */
        {
          width: 0,
          height: 0
        };
        /** @private {!ActivationStateType} */

        _this.activationState_ = _this.defaultActivationState_();
        /** @private {number} */

        _this.initialSize_ = 0;
        /** @private {number} */

        _this.maxRadius_ = 0;
        /** @private {function(!Event)} */

        _this.activateHandler_ = function (e) {
          return _this.activate_(e);
        };
        /** @private {function(!Event)} */


        _this.deactivateHandler_ = function (e) {
          return _this.deactivate_(e);
        };
        /** @private {function(?Event=)} */


        _this.focusHandler_ = function () {
          return _this.handleFocus();
        };
        /** @private {function(?Event=)} */


        _this.blurHandler_ = function () {
          return _this.handleBlur();
        };
        /** @private {!Function} */


        _this.resizeHandler_ = function () {
          return _this.layout();
        };
        /** @private {{left: number, top:number}} */


        _this.unboundedCoords_ = {
          left: 0,
          top: 0
        };
        /** @private {number} */

        _this.fgScale_ = 0;
        /** @private {number} */

        _this.activationTimer_ = 0;
        /** @private {number} */

        _this.fgDeactivationRemovalTimer_ = 0;
        /** @private {boolean} */

        _this.activationAnimationHasEnded_ = false;
        /** @private {!Function} */

        _this.activationTimerCallback_ = function () {
          _this.activationAnimationHasEnded_ = true;

          _this.runDeactivationUXLogicIfReady_();
        };
        /** @private {?Event} */


        _this.previousActivationEvent_ = null;
        return _this;
      }
      /**
       * We compute this property so that we are not querying information about the client
       * until the point in time where the foundation requests it. This prevents scenarios where
       * client-side feature-detection may happen too early, such as when components are rendered on the server
       * and then initialized at mount time on the client.
       * @return {boolean}
       * @private
       */


      _createClass$a(MDCRippleFoundation, [{
        key: "isSupported_",
        value: function isSupported_() {
          return this.adapter_.browserSupportsCssVars();
        }
        /**
         * @return {!ActivationStateType}
         */

      }, {
        key: "defaultActivationState_",
        value: function defaultActivationState_() {
          return {
            isActivated: false,
            hasDeactivationUXRun: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
            activationEvent: null,
            isProgrammatic: false
          };
        }
        /** @override */

      }, {
        key: "init",
        value: function init() {
          var _this2 = this;

          if (!this.isSupported_()) {
            return;
          }

          this.registerRootHandlers_();
          var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$.ROOT,
              UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
          requestAnimationFrame(function () {
            _this2.adapter_.addClass(ROOT);

            if (_this2.adapter_.isUnbounded()) {
              _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


              _this2.layoutInternal_();
            }
          });
        }
        /** @override */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          if (!this.isSupported_()) {
            return;
          }

          if (this.activationTimer_) {
            clearTimeout(this.activationTimer_);
            this.activationTimer_ = 0;
            var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
            this.adapter_.removeClass(FG_ACTIVATION);
          }

          this.deregisterRootHandlers_();
          this.deregisterDeactivationHandlers_();
          var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$2.ROOT,
              UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
          requestAnimationFrame(function () {
            _this3.adapter_.removeClass(ROOT);

            _this3.adapter_.removeClass(UNBOUNDED);

            _this3.removeCssVars_();
          });
        }
        /** @private */

      }, {
        key: "registerRootHandlers_",
        value: function registerRootHandlers_() {
          var _this4 = this;

          ACTIVATION_EVENT_TYPES$6.forEach(function (type) {
            _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
          });
          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.registerResizeHandler(this.resizeHandler_);
          }
        }
        /**
         * @param {!Event} e
         * @private
         */

      }, {
        key: "registerDeactivationHandlers_",
        value: function registerDeactivationHandlers_(e) {
          var _this5 = this;

          if (e.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
          } else {
            POINTER_DEACTIVATION_EVENT_TYPES$6.forEach(function (type) {
              _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
            });
          }
        }
        /** @private */

      }, {
        key: "deregisterRootHandlers_",
        value: function deregisterRootHandlers_() {
          var _this6 = this;

          ACTIVATION_EVENT_TYPES$6.forEach(function (type) {
            _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
          });
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          }
        }
        /** @private */

      }, {
        key: "deregisterDeactivationHandlers_",
        value: function deregisterDeactivationHandlers_() {
          var _this7 = this;

          this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
          POINTER_DEACTIVATION_EVENT_TYPES$6.forEach(function (type) {
            _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
          });
        }
        /** @private */

      }, {
        key: "removeCssVars_",
        value: function removeCssVars_() {
          var _this8 = this;

          var strings = MDCRippleFoundation.strings;
          Object.keys(strings).forEach(function (k) {
            if (k.indexOf('VAR_') === 0) {
              _this8.adapter_.updateCssVariable(strings[k], null);
            }
          });
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "activate_",
        value: function activate_(e) {
          var _this9 = this;

          if (this.adapter_.isSurfaceDisabled()) {
            return;
          }

          var activationState = this.activationState_;

          if (activationState.isActivated) {
            return;
          } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


          var previousActivationEvent = this.previousActivationEvent_;
          var isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;

          if (isSameInteraction) {
            return;
          }

          activationState.isActivated = true;
          activationState.isProgrammatic = e === null;
          activationState.activationEvent = e;
          activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';
          var hasActivatedChild = e && activatedTargets$6.length > 0 && activatedTargets$6.some(function (target) {
            return _this9.adapter_.containsEventTarget(target);
          });

          if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
          }

          if (e) {
            activatedTargets$6.push(
            /** @type {!EventTarget} */
            e.target);
            this.registerDeactivationHandlers_(e);
          }

          activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

          if (activationState.wasElementMadeActive) {
            this.animateActivation_();
          }

          requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets$6 = [];

            if (!activationState.wasElementMadeActive && (e.key === ' ' || e.keyCode === 32)) {
              // If space was pressed, try again within an rAF call to detect :active, because different UAs report
              // active states inconsistently when they're called within event handling code:
              // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
              // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
              // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
              // variable is set within a rAF callback for a submit button interaction (#2241).
              activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

              if (activationState.wasElementMadeActive) {
                _this9.animateActivation_();
              }
            }

            if (!activationState.wasElementMadeActive) {
              // Reset activation state immediately if element was not made active.
              _this9.activationState_ = _this9.defaultActivationState_();
            }
          });
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "checkElementMadeActive_",
        value: function checkElementMadeActive_(e) {
          return e && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
        }
        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: "activate",
        value: function activate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          this.activate_(event);
        }
        /** @private */

      }, {
        key: "animateActivation_",
        value: function animateActivation_() {
          var _this10 = this;

          var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
              VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
              VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
          var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
              FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
              FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
          var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
          this.layoutInternal_();
          var translateStart = '';
          var translateEnd = '';

          if (!this.adapter_.isUnbounded()) {
            var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
                startPoint = _this$getFgTranslatio.startPoint,
                endPoint = _this$getFgTranslatio.endPoint;

            translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
            translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
          }

          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

          clearTimeout(this.activationTimer_);
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.rmBoundedActivationClasses_();
          this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

          this.adapter_.computeBoundingRect();
          this.adapter_.addClass(FG_ACTIVATION);
          this.activationTimer_ = setTimeout(function () {
            return _this10.activationTimerCallback_();
          }, DEACTIVATION_TIMEOUT_MS);
        }
        /**
         * @private
         * @return {{startPoint: PointType, endPoint: PointType}}
         */

      }, {
        key: "getFgTranslationCoordinates_",
        value: function getFgTranslationCoordinates_() {
          var _this$activationState = this.activationState_,
              activationEvent = _this$activationState.activationEvent,
              wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
          var startPoint;

          if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords$6(
            /** @type {!Event} */
            activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
          } else {
            startPoint = {
              x: this.frame_.width / 2,
              y: this.frame_.height / 2
            };
          } // Center the element around the start point.


          startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
          };
          var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
          };
          return {
            startPoint: startPoint,
            endPoint: endPoint
          };
        }
        /** @private */

      }, {
        key: "runDeactivationUXLogicIfReady_",
        value: function runDeactivationUXLogicIfReady_() {
          var _this11 = this;

          // This method is called both when a pointing device is released, and when the activation animation ends.
          // The deactivation animation should only run after both of those occur.
          var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
          var _this$activationState2 = this.activationState_,
              hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
              isActivated = _this$activationState2.isActivated;
          var activationHasEnded = hasDeactivationUXRun || !isActivated;

          if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
              _this11.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers$6.FG_DEACTIVATION_MS);
          }
        }
        /** @private */

      }, {
        key: "rmBoundedActivationClasses_",
        value: function rmBoundedActivationClasses_() {
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
          this.adapter_.removeClass(FG_ACTIVATION);
          this.activationAnimationHasEnded_ = false;
          this.adapter_.computeBoundingRect();
        }
      }, {
        key: "resetActivationState_",
        value: function resetActivationState_() {
          var _this12 = this;

          this.previousActivationEvent_ = this.activationState_.activationEvent;
          this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
          // Store the previous event until it's safe to assume that subsequent events are for new interactions.

          setTimeout(function () {
            return _this12.previousActivationEvent_ = null;
          }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "deactivate_",
        value: function deactivate_(e) {
          var _this13 = this;

          var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

          if (!activationState.isActivated) {
            return;
          }

          var state =
          /** @type {!ActivationStateType} */
          Object.assign({}, activationState);

          if (activationState.isProgrammatic) {
            var evtObject = null;
            requestAnimationFrame(function () {
              return _this13.animateDeactivation_(evtObject, state);
            });
            this.resetActivationState_();
          } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
              _this13.activationState_.hasDeactivationUXRun = true;

              _this13.animateDeactivation_(e, state);

              _this13.resetActivationState_();
            });
          }
        }
        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          this.deactivate_(event);
        }
        /**
         * @param {Event} e
         * @param {!ActivationStateType} options
         * @private
         */

      }, {
        key: "animateDeactivation_",
        value: function animateDeactivation_(e, _ref) {
          var wasActivatedByPointer = _ref.wasActivatedByPointer,
              wasElementMadeActive = _ref.wasElementMadeActive;

          if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this14 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }

          this.layoutFrame_ = requestAnimationFrame(function () {
            _this14.layoutInternal_();

            _this14.layoutFrame_ = 0;
          });
        }
        /** @private */

      }, {
        key: "layoutInternal_",
        value: function layoutInternal_() {
          var _this15 = this;

          this.frame_ = this.adapter_.computeBoundingRect();
          var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
          // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
          // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
          // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
          // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
          // `overflow: hidden`.

          var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
          };

          this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

          this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;
          this.fgScale_ = this.maxRadius_ / this.initialSize_;
          this.updateLayoutCssVars_();
        }
        /** @private */

      }, {
        key: "updateLayoutCssVars_",
        value: function updateLayoutCssVars_() {
          var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
              VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
              VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
              VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
              VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
          this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
          this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

          if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
              left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
              top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };
            this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
            this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
          }
        }
        /** @param {boolean} unbounded */

      }, {
        key: "setUnbounded",
        value: function setUnbounded(unbounded) {
          var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

          if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
          } else {
            this.adapter_.removeClass(UNBOUNDED);
          }
        }
      }, {
        key: "handleFocus",
        value: function handleFocus() {
          var _this16 = this;

          requestAnimationFrame(function () {
            return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }, {
        key: "handleBlur",
        value: function handleBlur() {
          var _this17 = this;

          requestAnimationFrame(function () {
            return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }]);

      return MDCRippleFoundation;
    }(MDCFoundation$9);

    /**
     * @extends MDCComponent<!MDCRippleFoundation>
     */

    var MDCRipple$6 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$a(MDCRipple, _MDCComponent);

      /** @param {...?} args */
      function MDCRipple() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$a(this, MDCRipple);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$a(this, (_getPrototypeOf2 = _getPrototypeOf$a(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {boolean} */

        _this.disabled = false;
        /** @private {boolean} */

        _this.unbounded_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @param {{isUnbounded: (boolean|undefined)}=} options
       * @return {!MDCRipple}
       */


      _createClass$a(MDCRipple, [{
        key: "setUnbounded_",

        /**
         * Closure Compiler throws an access control error when directly accessing a
         * protected or private property inside a getter/setter, like unbounded above.
         * By accessing the protected property inside a method, we solve that problem.
         * That's why this function exists.
         * @private
         */
        value: function setUnbounded_() {
          this.foundation_.setUnbounded(this.unbounded_);
        }
      }, {
        key: "activate",
        value: function activate() {
          this.foundation_.activate();
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
        /**
         * @return {!MDCRippleFoundation}
         * @override
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          return new MDCRippleFoundation$6(MDCRipple.createAdapter(this));
        }
        /** @override */

      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
        }
      }, {
        key: "unbounded",

        /** @return {boolean} */
        get: function get() {
          return this.unbounded_;
        }
        /** @param {boolean} unbounded */
        ,
        set: function set(unbounded) {
          this.unbounded_ = Boolean(unbounded);
          this.setUnbounded_();
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref$isUnbounded = _ref.isUnbounded,
              isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

          var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

          if (isUnbounded !== undefined) {
            ripple.unbounded =
            /** @type {boolean} */
            isUnbounded;
          }

          return ripple;
        }
        /**
         * @param {!RippleCapableSurface} instance
         * @return {!MDCRippleAdapter}
         */

      }, {
        key: "createAdapter",
        value: function createAdapter(instance) {
          var MATCHES = getMatchesProperty$6(HTMLElement.prototype);
          return {
            browserSupportsCssVars: function browserSupportsCssVars() {
              return supportsCssVariables$6(window);
            },
            isUnbounded: function isUnbounded() {
              return instance.unbounded;
            },
            isSurfaceActive: function isSurfaceActive() {
              return instance.root_[MATCHES](':active');
            },
            isSurfaceDisabled: function isSurfaceDisabled() {
              return instance.disabled;
            },
            addClass: function addClass(className) {
              return instance.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return instance.root_.classList.remove(className);
            },
            containsEventTarget: function containsEventTarget(target) {
              return instance.root_.contains(target);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return instance.root_.addEventListener(evtType, handler, applyPassive$7());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return instance.root_.removeEventListener(evtType, handler, applyPassive$7());
            },
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.addEventListener(evtType, handler, applyPassive$7());
            },
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.removeEventListener(evtType, handler, applyPassive$7());
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return instance.root_.style.setProperty(varName, value);
            },
            computeBoundingRect: function computeBoundingRect() {
              return instance.root_.getBoundingClientRect();
            },
            getWindowPageOffset: function getWindowPageOffset() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            }
          };
        }
      }]);

      return MDCRipple;
    }(MDCComponent$9);

    /**
     * @extends {MDCComponent<!MDCIconButtonToggleFoundation>}
     */

    var MDCIconButtonToggle =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$a(MDCIconButtonToggle, _MDCComponent);

      _createClass$a(MDCIconButtonToggle, null, [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCIconButtonToggle(root);
        }
      }]);

      function MDCIconButtonToggle() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$a(this, MDCIconButtonToggle);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$a(this, (_getPrototypeOf2 = _getPrototypeOf$a(MDCIconButtonToggle)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {!MDCRipple} */

        _this.ripple_ = _this.initRipple_();
        return _this;
      }
      /** @return {!Element} */


      _createClass$a(MDCIconButtonToggle, [{
        key: "initRipple_",

        /**
         * @return {!MDCRipple}
         * @private
         */
        value: function initRipple_() {
          var ripple = new MDCRipple$6(this.root_);
          ripple.unbounded = true;
          return ripple;
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.ripple_.destroy();

          _get$6(_getPrototypeOf$a(MDCIconButtonToggle.prototype), "destroy", this).call(this);
        }
        /** @return {!MDCIconButtonToggleFoundation} */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this2 = this;

          return new MDCIconButtonToggleFoundation({
            addClass: function addClass(className) {
              return _this2.iconEl_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this2.iconEl_.classList.remove(className);
            },
            registerInteractionHandler: function registerInteractionHandler(type, handler) {
              return _this2.root_.addEventListener(type, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
              return _this2.root_.removeEventListener(type, handler);
            },
            setText: function setText(text) {
              return _this2.iconEl_.textContent = text;
            },
            getAttr: function getAttr(name) {
              return _this2.root_.getAttribute(name);
            },
            setAttr: function setAttr(name, value) {
              return _this2.root_.setAttribute(name, value);
            },
            notifyChange: function notifyChange(evtData) {
              return _this2.emit(MDCIconButtonToggleFoundation.strings.CHANGE_EVENT, evtData);
            }
          });
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.on = this.root_.getAttribute(MDCIconButtonToggleFoundation.strings.ARIA_PRESSED) === 'true';
        }
        /** @return {!MDCRipple} */

      }, {
        key: "refreshToggleData",
        value: function refreshToggleData() {
          this.foundation_.refreshToggleData();
        }
      }, {
        key: "iconEl_",
        get: function get$$1() {
          var sel = this.root_.dataset['iconInnerSelector'];
          return sel ?
          /** @type {!Element} */
          this.root_.querySelector(sel) : this.root_;
        }
      }, {
        key: "ripple",
        get: function get$$1() {
          return this.ripple_;
        }
        /** @return {boolean} */

      }, {
        key: "on",
        get: function get$$1() {
          return this.foundation_.isOn();
        }
        /** @param {boolean} isOn */
        ,
        set: function set(isOn) {
          this.foundation_.toggle(isOn);
        }
      }]);

      return MDCIconButtonToggle;
    }(MDCComponent$9);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ MDC_ICON_BUTTON_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return MdcIconButton; }),
        multi: true
    };
    /**
     * Change event object emitted by MdcIconButton.
     */
    var   /**
     * Change event object emitted by MdcIconButton.
     */
    MdcIconButtonChange = /** @class */ (function () {
        function MdcIconButtonChange(source, value) {
            this.source = source;
            this.value = value;
        }
        return MdcIconButtonChange;
    }());
    var /** @type {?} */ nextUniqueId$2 = 0;
    var MdcIconButton = /** @class */ (function () {
        function MdcIconButton(_changeDetectorRef, elementRef, ripple, _registry) {
            var _this = this;
            this._changeDetectorRef = _changeDetectorRef;
            this.elementRef = elementRef;
            this.ripple = ripple;
            this._registry = _registry;
            this._uniqueId = "mdc-icon-button-" + ++nextUniqueId$2;
            this.id = this._uniqueId;
            this.name = null;
            this.change = new core.EventEmitter();
            this.isHostClass = true;
            this.isMaterialIcons = true;
            this.ariaPressed = 'false';
            this._onChange = function () { };
            this._onTouched = function () { };
            this._mdcAdapter = {
                addClass: function (className) {
                    return _this._getIconInnerSelector() ? _this._getIconInnerSelector().classList.add(className) :
                        _this._getHostElement().classList.add(className);
                },
                removeClass: function (className) {
                    return _this._getIconInnerSelector() ? _this._getIconInnerSelector().classList.remove(className) :
                        _this._getHostElement().classList.remove(className);
                },
                registerInteractionHandler: function (type, handler) { return _this._registry.listen(type, handler, _this._getHostElement()); },
                deregisterInteractionHandler: function (type, handler) { return _this._registry.unlisten(type, handler); },
                setText: function (text) {
                    return _this._getIconInnerSelector() ? _this._getIconInnerSelector().textContent = text : _this._getHostElement().textContent = text;
                },
                getAttr: function (name) { return _this._getHostElement().getAttribute(name); },
                setAttr: function (name, value) { return _this._getHostElement().setAttribute(name, value); },
                notifyChange: function (evtData) {
                    _this.change.emit(new MdcIconButtonChange(_this, evtData.isOn));
                    _this._onChange(_this._foundation.isOn());
                }
            };
            this._foundation = new MDCIconButtonToggleFoundation(this._mdcAdapter);
        }
        Object.defineProperty(MdcIconButton.prototype, "inputId", {
            get: /**
             * @return {?}
             */
            function () { return "" + (this.id || this._uniqueId); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIconButton.prototype, "iconOn", {
            get: /**
             * @return {?}
             */
            function () { return this._iconOn; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setIconOn(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIconButton.prototype, "iconOff", {
            get: /**
             * @return {?}
             */
            function () { return this._iconOff; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setIconOff(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIconButton.prototype, "on", {
            get: /**
             * @return {?}
             */
            function () { return this._foundation.isOn(); },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setOn(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIconButton.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setDisabled(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIconButton.prototype, "primary", {
            get: /**
             * @return {?}
             */
            function () { return this._primary; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setPrimary(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIconButton.prototype, "secondary", {
            get: /**
             * @return {?}
             */
            function () { return this._secondary; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setSecondary(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIconButton.prototype, "tabindex", {
            get: /**
             * @return {?}
             */
            function () {
                return this.disabled ? -1 : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIconButton.prototype, "classPrimary", {
            get: /**
             * @return {?}
             */
            function () {
                return this.primary ? 'ng-mdc-icon-button--primary' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIconButton.prototype, "classSecondary", {
            get: /**
             * @return {?}
             */
            function () {
                return this.secondary ? 'ng-mdc-icon-button--secondary' : '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcIconButton.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this._foundation.init();
            this._foundation.toggle(this._on || this._foundation.isOn());
            this.ripple.attachTo(this._getHostElement(), true);
            this._changeDetectorRef.detectChanges();
        };
        /**
         * @return {?}
         */
        MdcIconButton.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.ripple.destroy();
            this._foundation.destroy();
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MdcIconButton.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._onChange(value);
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcIconButton.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcIconButton.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onTouched = fn;
        };
        /**
         * @param {?} isOn
         * @return {?}
         */
        MdcIconButton.prototype.toggle = /**
         * @param {?} isOn
         * @return {?}
         */
        function (isOn) {
            this._foundation.toggle(isOn);
        };
        /**
         * @return {?}
         */
        MdcIconButton.prototype.refreshToggleData = /**
         * @return {?}
         */
        function () {
            this._foundation.refreshToggleData();
        };
        /**
         * @return {?}
         */
        MdcIconButton.prototype.isOn = /**
         * @return {?}
         */
        function () {
            return this._foundation.isOn();
        };
        /**
         * @param {?} iconOn
         * @return {?}
         */
        MdcIconButton.prototype.setIconOn = /**
         * @param {?} iconOn
         * @return {?}
         */
        function (iconOn) {
            this._iconOn = iconOn;
            if (!this._getIconInnerSelector()) {
                this._getHostElement().removeAttribute('data-toggle-on-class');
                this._getHostElement().setAttribute('data-toggle-on-content', iconOn);
            }
            else {
                this._getHostElement().removeAttribute('data-toggle-on-content');
                this._getHostElement().setAttribute('data-toggle-on-class', iconOn);
            }
            this._foundation.refreshToggleData();
        };
        /**
         * @param {?} iconOff
         * @return {?}
         */
        MdcIconButton.prototype.setIconOff = /**
         * @param {?} iconOff
         * @return {?}
         */
        function (iconOff) {
            this._iconOff = iconOff;
            if (!this._getIconInnerSelector()) {
                this._getHostElement().removeAttribute('data-toggle-off-class');
                this._getHostElement().setAttribute('data-toggle-off-content', iconOff);
            }
            else {
                this._getHostElement().removeAttribute('data-toggle-off-content');
                this._getHostElement().setAttribute('data-toggle-on-class', iconOff);
            }
            this._foundation.refreshToggleData();
        };
        /**
         * @param {?} on
         * @return {?}
         */
        MdcIconButton.prototype.setOn = /**
         * @param {?} on
         * @return {?}
         */
        function (on) {
            if (on !== this._on) {
                this._on = on;
                this._foundation.toggle(on);
                this._changeDetectorRef.markForCheck();
            }
        };
        /**
         * @param {?} primary
         * @return {?}
         */
        MdcIconButton.prototype.setPrimary = /**
         * @param {?} primary
         * @return {?}
         */
        function (primary) {
            if (primary) {
                this.setSecondary(false);
            }
            this._primary = primary;
        };
        /**
         * @param {?} secondary
         * @return {?}
         */
        MdcIconButton.prototype.setSecondary = /**
         * @param {?} secondary
         * @return {?}
         */
        function (secondary) {
            if (secondary) {
                this.setPrimary(false);
            }
            this._secondary = secondary;
        };
        /** Sets the button disabled state */
        /**
         * Sets the button disabled state
         * @param {?} disabled
         * @return {?}
         */
        MdcIconButton.prototype.setDisabled = /**
         * Sets the button disabled state
         * @param {?} disabled
         * @return {?}
         */
        function (disabled) {
            this._disabled = disabled;
            disabled ? this._getHostElement().setAttribute('disabled', '') :
                this._getHostElement().removeAttribute('disabled');
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @return {?}
         */
        MdcIconButton.prototype._getHostElement = /**
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        /**
         * @return {?}
         */
        MdcIconButton.prototype._getIconInnerSelector = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ iconSelector = this.elementRef.nativeElement.firstElementChild;
            this.isMaterialIcons = !iconSelector ? true : false;
            return iconSelector;
        };
        MdcIconButton.decorators = [
            { type: core.Component, args: [{selector: 'button[mdcIconButton], a[mdcIconButton]',
                        exportAs: 'mdcIconButton',
                        template: '<ng-content></ng-content>',
                        host: {
                            '[id]': 'id',
                        },
                        providers: [
                            MDC_ICON_BUTTON_CONTROL_VALUE_ACCESSOR,
                            MdcRipple,
                            EventRegistry,
                        ],
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcIconButton.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: MdcRipple },
            { type: EventRegistry }
        ]; };
        MdcIconButton.propDecorators = {
            id: [{ type: core.Input }],
            name: [{ type: core.Input }],
            labelOn: [{ type: core.Input }],
            labelOff: [{ type: core.Input }],
            iconOn: [{ type: core.Input }],
            iconOff: [{ type: core.Input }],
            on: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            primary: [{ type: core.Input }],
            secondary: [{ type: core.Input }],
            change: [{ type: core.Output }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-icon-button',] }],
            isMaterialIcons: [{ type: core.HostBinding, args: ['class.material-icons',] }],
            ariaPressed: [{ type: core.HostBinding, args: ['attr.aria-pressed',] }],
            tabindex: [{ type: core.HostBinding, args: ['attr.tabIndex',] }],
            classPrimary: [{ type: core.HostBinding, args: ['class.ng-mdc-icon-button--primary',] }],
            classSecondary: [{ type: core.HostBinding, args: ['class.ng-mdc-icon-button--secondary',] }]
        };
        return MdcIconButton;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcIconButtonModule = /** @class */ (function () {
        function MdcIconButtonModule() {
        }
        MdcIconButtonModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [MdcIconButton],
                        declarations: [MdcIconButton]
                    },] },
        ];
        return MdcIconButtonModule;
    }());

    function _classCallCheck$b(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$b(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$b(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$b(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$b(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$b(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$b(subClass, superClass);
    }

    function _getPrototypeOf$b(o) {
      _getPrototypeOf$b = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$b(o);
    }

    function _setPrototypeOf$b(o, p) {
      _setPrototypeOf$b = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$b(o, p);
    }

    function _assertThisInitialized$b(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$b(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$b(self);
    }

    function _superPropBase$7(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$b(object);
        if (object === null) break;
      }

      return object;
    }

    function _get$7(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$7 = Reflect.get;
      } else {
        _get$7 = function _get(target, property, receiver) {
          var base = _superPropBase$7(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get$7(target, property, receiver || target);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @template A
     */
    var MDCFoundation$a =
    /*#__PURE__*/
    function () {
      _createClass$b(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$b(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$b(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$a =
    /*#__PURE__*/
    function () {
      _createClass$b(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$a());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$b(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$b(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2017 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Icon Toggle. Provides an interface for managing
     * - classes
     * - dom
     * - inner text
     * - event handlers
     * - event dispatch
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCIconToggleAdapter =
    /*#__PURE__*/
    function () {
      function MDCIconToggleAdapter() {
        _classCallCheck$b(this, MDCIconToggleAdapter);
      }

      _createClass$b(MDCIconToggleAdapter, [{
        key: "addClass",

        /** @param {string} className */
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * @param {string} type
         * @param {!EventListener} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(type, handler) {}
        /**
         * @param {string} type
         * @param {!EventListener} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(type, handler) {}
        /** @param {string} text */

      }, {
        key: "setText",
        value: function setText(text) {}
        /** @return {number} */

      }, {
        key: "getTabIndex",
        value: function getTabIndex() {}
        /** @param {number} tabIndex */

      }, {
        key: "setTabIndex",
        value: function setTabIndex(tabIndex) {}
        /**
         * @param {string} name
         * @return {string}
         */

      }, {
        key: "getAttr",
        value: function getAttr(name) {}
        /**
         * @param {string} name
         * @param {string} value
         */

      }, {
        key: "setAttr",
        value: function setAttr(name, value) {}
        /** @param {string} name */

      }, {
        key: "rmAttr",
        value: function rmAttr(name) {}
        /** @param {!IconToggleEvent} evtData */

      }, {
        key: "notifyChange",
        value: function notifyChange(evtData) {}
      }]);

      return MDCIconToggleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var cssClasses$9 = {
      ROOT: 'mdc-icon-toggle',
      DISABLED: 'mdc-icon-toggle--disabled'
    };
    /** @enum {string} */

    var strings$9 = {
      DATA_TOGGLE_ON: 'data-toggle-on',
      DATA_TOGGLE_OFF: 'data-toggle-off',
      ARIA_PRESSED: 'aria-pressed',
      ARIA_DISABLED: 'aria-disabled',
      ARIA_LABEL: 'aria-label',
      CHANGE_EVENT: 'MDCIconToggle:change'
    };

    /**
     * @extends {MDCFoundation<!MDCIconToggleAdapter>}
     */

    var MDCIconToggleFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$b(MDCIconToggleFoundation, _MDCFoundation);

      _createClass$b(MDCIconToggleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$9;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$9;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* type: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* type: string, handler: EventListener */
            {},
            setText: function setText()
            /* text: string */
            {},
            getTabIndex: function getTabIndex() {
              return (
                /* number */
                0
              );
            },
            setTabIndex: function setTabIndex()
            /* tabIndex: number */
            {},
            getAttr: function getAttr() {
              return (
                /* name: string */

                /* string */
                ''
              );
            },
            setAttr: function setAttr()
            /* name: string, value: string */
            {},
            rmAttr: function rmAttr()
            /* name: string */
            {},
            notifyChange: function notifyChange()
            /* evtData: IconToggleEvent */
            {}
          };
        }
      }]);

      function MDCIconToggleFoundation(adapter) {
        var _this;

        _classCallCheck$b(this, MDCIconToggleFoundation);

        _this = _possibleConstructorReturn$b(this, _getPrototypeOf$b(MDCIconToggleFoundation).call(this, Object.assign(MDCIconToggleFoundation.defaultAdapter, adapter)));
        /** @private {boolean} */

        _this.on_ = false;
        /** @private {boolean} */

        _this.disabled_ = false;
        /** @private {number} */

        _this.savedTabIndex_ = -1;
        /** @private {?IconToggleState} */

        _this.toggleOnData_ = null;
        /** @private {?IconToggleState} */

        _this.toggleOffData_ = null;

        _this.clickHandler_ =
        /** @private {!EventListener} */
        function () {
          return _this.toggleFromEvt_();
        };
        /** @private {boolean} */


        _this.isHandlingKeydown_ = false;

        _this.keydownHandler_ =
        /** @private {!EventListener} */
        function (
        /** @type {!KeyboardKey} */
        evt) {
          if (isSpace(evt)) {
            _this.isHandlingKeydown_ = true;
            return evt.preventDefault();
          }
        };

        _this.keyupHandler_ =
        /** @private {!EventListener} */
        function (
        /** @type {!KeyboardKey} */
        evt) {
          if (isSpace(evt)) {
            _this.isHandlingKeydown_ = false;

            _this.toggleFromEvt_();
          }
        };

        return _this;
      }

      _createClass$b(MDCIconToggleFoundation, [{
        key: "init",
        value: function init() {
          this.refreshToggleData();
          this.savedTabIndex_ = this.adapter_.getTabIndex();
          this.adapter_.registerInteractionHandler('click', this.clickHandler_);
          this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
          this.adapter_.registerInteractionHandler('keyup', this.keyupHandler_);
        }
      }, {
        key: "refreshToggleData",
        value: function refreshToggleData() {
          var _MDCIconToggleFoundat = MDCIconToggleFoundation.strings,
              DATA_TOGGLE_ON = _MDCIconToggleFoundat.DATA_TOGGLE_ON,
              DATA_TOGGLE_OFF = _MDCIconToggleFoundat.DATA_TOGGLE_OFF;
          this.toggleOnData_ = this.parseJsonDataAttr_(DATA_TOGGLE_ON);
          this.toggleOffData_ = this.parseJsonDataAttr_(DATA_TOGGLE_OFF);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
          this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
          this.adapter_.deregisterInteractionHandler('keyup', this.keyupHandler_);
        }
        /** @private */

      }, {
        key: "toggleFromEvt_",
        value: function toggleFromEvt_() {
          this.toggle();
          var isOn = this.on_;
          this.adapter_.notifyChange(
          /** @type {!IconToggleEvent} */
          {
            isOn: isOn
          });
        }
        /** @return {boolean} */

      }, {
        key: "isOn",
        value: function isOn() {
          return this.on_;
        }
        /** @param {boolean=} isOn */

      }, {
        key: "toggle",
        value: function toggle() {
          var isOn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !this.on_;
          this.on_ = isOn;
          var _MDCIconToggleFoundat2 = MDCIconToggleFoundation.strings,
              ARIA_LABEL = _MDCIconToggleFoundat2.ARIA_LABEL,
              ARIA_PRESSED = _MDCIconToggleFoundat2.ARIA_PRESSED;

          if (this.on_) {
            this.adapter_.setAttr(ARIA_PRESSED, 'true');
          } else {
            this.adapter_.setAttr(ARIA_PRESSED, 'false');
          }

          var _ref = this.on_ ? this.toggleOffData_ : this.toggleOnData_,
              classToRemove = _ref.cssClass;

          if (classToRemove) {
            this.adapter_.removeClass(classToRemove);
          }

          var _ref2 = this.on_ ? this.toggleOnData_ : this.toggleOffData_,
              content = _ref2.content,
              label = _ref2.label,
              cssClass = _ref2.cssClass;

          if (cssClass) {
            this.adapter_.addClass(cssClass);
          }

          if (content) {
            this.adapter_.setText(content);
          }

          if (label) {
            this.adapter_.setAttr(ARIA_LABEL, label);
          }
        }
        /**
         * @param {string} dataAttr
         * @return {!IconToggleState}
         */

      }, {
        key: "parseJsonDataAttr_",
        value: function parseJsonDataAttr_(dataAttr) {
          var val = this.adapter_.getAttr(dataAttr);

          if (!val) {
            return {};
          }

          return (
            /** @type {!IconToggleState} */
            JSON.parse(val)
          );
        }
        /** @return {boolean} */

      }, {
        key: "isDisabled",
        value: function isDisabled() {
          return this.disabled_;
        }
        /** @param {boolean} isDisabled */

      }, {
        key: "setDisabled",
        value: function setDisabled(isDisabled) {
          this.disabled_ = isDisabled;
          var DISABLED = MDCIconToggleFoundation.cssClasses.DISABLED;
          var ARIA_DISABLED = MDCIconToggleFoundation.strings.ARIA_DISABLED;

          if (this.disabled_) {
            this.savedTabIndex_ = this.adapter_.getTabIndex();
            this.adapter_.setTabIndex(-1);
            this.adapter_.setAttr(ARIA_DISABLED, 'true');
            this.adapter_.addClass(DISABLED);
          } else {
            this.adapter_.setTabIndex(this.savedTabIndex_);
            this.adapter_.rmAttr(ARIA_DISABLED);
            this.adapter_.removeClass(DISABLED);
          }
        }
        /** @return {boolean} */

      }, {
        key: "isKeyboardActivated",
        value: function isKeyboardActivated() {
          return this.isHandlingKeydown_;
        }
      }]);

      return MDCIconToggleFoundation;
    }(MDCFoundation$a);
    /**
     * @param {!KeyboardKey} keyboardKey
     * @return {boolean}
     */

    function isSpace(keyboardKey) {
      return keyboardKey.key === 'Space' || keyboardKey.keyCode === 32;
    }

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Ripple. Provides an interface for managing
     * - classes
     * - dom
     * - CSS variables
     * - position
     * - dimensions
     * - scroll position
     * - event handlers
     * - unbounded, active and disabled states
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCRippleAdapter$7 =
    /*#__PURE__*/
    function () {
      function MDCRippleAdapter() {
        _classCallCheck$b(this, MDCRippleAdapter);
      }

      _createClass$b(MDCRippleAdapter, [{
        key: "browserSupportsCssVars",

        /** @return {boolean} */
        value: function browserSupportsCssVars() {}
        /** @return {boolean} */

      }, {
        key: "isUnbounded",
        value: function isUnbounded() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceActive",
        value: function isSurfaceActive() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceDisabled",
        value: function isSurfaceDisabled() {}
        /** @param {string} className */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @param {!EventTarget} target */

      }, {
        key: "containsEventTarget",
        value: function containsEventTarget(target) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerDocumentInteractionHandler",
        value: function registerDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterDocumentInteractionHandler",
        value: function deregisterDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /**
         * @param {string} varName
         * @param {?number|string} value
         */

      }, {
        key: "updateCssVariable",
        value: function updateCssVariable(varName, value) {}
        /** @return {!ClientRect} */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}
        /** @return {{x: number, y: number}} */

      }, {
        key: "getWindowPageOffset",
        value: function getWindowPageOffset() {}
      }]);

      return MDCRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var cssClasses$1$8 = {
      // Ripple is a special case where the "root" component is really a "mixin" of sorts,
      // given that it's an 'upgrade' to an existing component. That being said it is the root
      // CSS class that all other CSS classes derive from.
      ROOT: 'mdc-ripple-upgraded',
      UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
      BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
      FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
      FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
    };
    var strings$1$8 = {
      VAR_LEFT: '--mdc-ripple-left',
      VAR_TOP: '--mdc-ripple-top',
      VAR_FG_SIZE: '--mdc-ripple-fg-size',
      VAR_FG_SCALE: '--mdc-ripple-fg-scale',
      VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
      VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
    };
    var numbers$7 = {
      PADDING: 10,
      INITIAL_ORIGIN_SCALE: 0.6,
      DEACTIVATION_TIMEOUT_MS: 225,
      // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
      FG_DEACTIVATION_MS: 150,
      // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
      TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

    };

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
     * @private {boolean|undefined}
     */
    var supportsCssVariables_$7;
    /**
     * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
     * @private {boolean|undefined}
     */

    var supportsPassive_$8;
    /**
     * @param {!Window} windowObj
     * @return {boolean}
     */

    function detectEdgePseudoVarBug$7(windowObj) {
      // Detect versions of Edge with buggy var() support
      // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
      var document = windowObj.document;
      var node = document.createElement('div');
      node.className = 'mdc-ripple-surface--test-edge-var-bug';
      document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
      // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
      // but Firefox is known to support CSS custom properties correctly.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

      var computedStyle = windowObj.getComputedStyle(node);
      var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
      node.remove();
      return hasPseudoVarBug;
    }
    /**
     * @param {!Window} windowObj
     * @param {boolean=} forceRefresh
     * @return {boolean|undefined}
     */


    function supportsCssVariables$7(windowObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var supportsCssVariables = supportsCssVariables_$7;

      if (typeof supportsCssVariables_$7 === 'boolean' && !forceRefresh) {
        return supportsCssVariables;
      }

      var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

      if (!supportsFunctionPresent) {
        return;
      }

      var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
      // See: README section on Safari

      var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

      if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVariables = !detectEdgePseudoVarBug$7(windowObj);
      } else {
        supportsCssVariables = false;
      }

      if (!forceRefresh) {
        supportsCssVariables_$7 = supportsCssVariables;
      }

      return supportsCssVariables;
    } //

    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|{passive: boolean}}
     */


    function applyPassive$8() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_$8 === undefined || forceRefresh) {
        var isSupported = false;

        try {
          globalObj.document.addEventListener('test', null, {
            get passive() {
              isSupported = true;
            }

          });
        } catch (e) {}

        supportsPassive_$8 = isSupported;
      }

      return supportsPassive_$8 ? {
        passive: true
      } : false;
    }
    /**
     * @param {!Object} HTMLElementPrototype
     * @return {!Array<string>}
     */


    function getMatchesProperty$7(HTMLElementPrototype) {
      return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(function (p) {
        return p in HTMLElementPrototype;
      }).pop();
    }
    /**
     * @param {!Event} ev
     * @param {{x: number, y: number}} pageOffset
     * @param {!ClientRect} clientRect
     * @return {{x: number, y: number}}
     */


    function getNormalizedEventCoords$7(ev, pageOffset, clientRect) {
      var x = pageOffset.x,
          y = pageOffset.y;
      var documentX = x + clientRect.left;
      var documentY = y + clientRect.top;
      var normalizedX;
      var normalizedY; // Determine touch point relative to the ripple container.

      if (ev.type === 'touchstart') {
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
      } else {
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
      }

      return {
        x: normalizedX,
        y: normalizedY
      };
    }

    var ACTIVATION_EVENT_TYPES$7 = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

    var POINTER_DEACTIVATION_EVENT_TYPES$7 = ['touchend', 'pointerup', 'mouseup']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

    /** @type {!Array<!EventTarget>} */

    var activatedTargets$7 = [];
    /**
     * @extends {MDCFoundation<!MDCRippleAdapter>}
     */

    var MDCRippleFoundation$7 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$b(MDCRippleFoundation, _MDCFoundation);

      _createClass$b(MDCRippleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$1$8;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$1$8;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers$7;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            browserSupportsCssVars: function browserSupportsCssVars()
            /* boolean - cached */
            {},
            isUnbounded: function isUnbounded()
            /* boolean */
            {},
            isSurfaceActive: function isSurfaceActive()
            /* boolean */
            {},
            isSurfaceDisabled: function isSurfaceDisabled()
            /* boolean */
            {},
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            containsEventTarget: function containsEventTarget()
            /* target: !EventTarget */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            updateCssVariable: function updateCssVariable()
            /* varName: string, value: string */
            {},
            computeBoundingRect: function computeBoundingRect()
            /* ClientRect */
            {},
            getWindowPageOffset: function getWindowPageOffset()
            /* {x: number, y: number} */
            {}
          };
        }
      }]);

      function MDCRippleFoundation(adapter) {
        var _this;

        _classCallCheck$b(this, MDCRippleFoundation);

        _this = _possibleConstructorReturn$b(this, _getPrototypeOf$b(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
        /** @private {number} */

        _this.layoutFrame_ = 0;
        /** @private {!ClientRect} */

        _this.frame_ =
        /** @type {!ClientRect} */
        {
          width: 0,
          height: 0
        };
        /** @private {!ActivationStateType} */

        _this.activationState_ = _this.defaultActivationState_();
        /** @private {number} */

        _this.initialSize_ = 0;
        /** @private {number} */

        _this.maxRadius_ = 0;
        /** @private {function(!Event)} */

        _this.activateHandler_ = function (e) {
          return _this.activate_(e);
        };
        /** @private {function(!Event)} */


        _this.deactivateHandler_ = function (e) {
          return _this.deactivate_(e);
        };
        /** @private {function(?Event=)} */


        _this.focusHandler_ = function () {
          return _this.handleFocus();
        };
        /** @private {function(?Event=)} */


        _this.blurHandler_ = function () {
          return _this.handleBlur();
        };
        /** @private {!Function} */


        _this.resizeHandler_ = function () {
          return _this.layout();
        };
        /** @private {{left: number, top:number}} */


        _this.unboundedCoords_ = {
          left: 0,
          top: 0
        };
        /** @private {number} */

        _this.fgScale_ = 0;
        /** @private {number} */

        _this.activationTimer_ = 0;
        /** @private {number} */

        _this.fgDeactivationRemovalTimer_ = 0;
        /** @private {boolean} */

        _this.activationAnimationHasEnded_ = false;
        /** @private {!Function} */

        _this.activationTimerCallback_ = function () {
          _this.activationAnimationHasEnded_ = true;

          _this.runDeactivationUXLogicIfReady_();
        };
        /** @private {?Event} */


        _this.previousActivationEvent_ = null;
        return _this;
      }
      /**
       * We compute this property so that we are not querying information about the client
       * until the point in time where the foundation requests it. This prevents scenarios where
       * client-side feature-detection may happen too early, such as when components are rendered on the server
       * and then initialized at mount time on the client.
       * @return {boolean}
       * @private
       */


      _createClass$b(MDCRippleFoundation, [{
        key: "isSupported_",
        value: function isSupported_() {
          return this.adapter_.browserSupportsCssVars();
        }
        /**
         * @return {!ActivationStateType}
         */

      }, {
        key: "defaultActivationState_",
        value: function defaultActivationState_() {
          return {
            isActivated: false,
            hasDeactivationUXRun: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
            activationEvent: null,
            isProgrammatic: false
          };
        }
        /** @override */

      }, {
        key: "init",
        value: function init() {
          var _this2 = this;

          if (!this.isSupported_()) {
            return;
          }

          this.registerRootHandlers_();
          var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$.ROOT,
              UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
          requestAnimationFrame(function () {
            _this2.adapter_.addClass(ROOT);

            if (_this2.adapter_.isUnbounded()) {
              _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


              _this2.layoutInternal_();
            }
          });
        }
        /** @override */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          if (!this.isSupported_()) {
            return;
          }

          if (this.activationTimer_) {
            clearTimeout(this.activationTimer_);
            this.activationTimer_ = 0;
            var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
            this.adapter_.removeClass(FG_ACTIVATION);
          }

          this.deregisterRootHandlers_();
          this.deregisterDeactivationHandlers_();
          var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$2.ROOT,
              UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
          requestAnimationFrame(function () {
            _this3.adapter_.removeClass(ROOT);

            _this3.adapter_.removeClass(UNBOUNDED);

            _this3.removeCssVars_();
          });
        }
        /** @private */

      }, {
        key: "registerRootHandlers_",
        value: function registerRootHandlers_() {
          var _this4 = this;

          ACTIVATION_EVENT_TYPES$7.forEach(function (type) {
            _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
          });
          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.registerResizeHandler(this.resizeHandler_);
          }
        }
        /**
         * @param {!Event} e
         * @private
         */

      }, {
        key: "registerDeactivationHandlers_",
        value: function registerDeactivationHandlers_(e) {
          var _this5 = this;

          if (e.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
          } else {
            POINTER_DEACTIVATION_EVENT_TYPES$7.forEach(function (type) {
              _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
            });
          }
        }
        /** @private */

      }, {
        key: "deregisterRootHandlers_",
        value: function deregisterRootHandlers_() {
          var _this6 = this;

          ACTIVATION_EVENT_TYPES$7.forEach(function (type) {
            _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
          });
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          }
        }
        /** @private */

      }, {
        key: "deregisterDeactivationHandlers_",
        value: function deregisterDeactivationHandlers_() {
          var _this7 = this;

          this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
          POINTER_DEACTIVATION_EVENT_TYPES$7.forEach(function (type) {
            _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
          });
        }
        /** @private */

      }, {
        key: "removeCssVars_",
        value: function removeCssVars_() {
          var _this8 = this;

          var strings = MDCRippleFoundation.strings;
          Object.keys(strings).forEach(function (k) {
            if (k.indexOf('VAR_') === 0) {
              _this8.adapter_.updateCssVariable(strings[k], null);
            }
          });
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "activate_",
        value: function activate_(e) {
          var _this9 = this;

          if (this.adapter_.isSurfaceDisabled()) {
            return;
          }

          var activationState = this.activationState_;

          if (activationState.isActivated) {
            return;
          } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


          var previousActivationEvent = this.previousActivationEvent_;
          var isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;

          if (isSameInteraction) {
            return;
          }

          activationState.isActivated = true;
          activationState.isProgrammatic = e === null;
          activationState.activationEvent = e;
          activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';
          var hasActivatedChild = e && activatedTargets$7.length > 0 && activatedTargets$7.some(function (target) {
            return _this9.adapter_.containsEventTarget(target);
          });

          if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
          }

          if (e) {
            activatedTargets$7.push(
            /** @type {!EventTarget} */
            e.target);
            this.registerDeactivationHandlers_(e);
          }

          activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

          if (activationState.wasElementMadeActive) {
            this.animateActivation_();
          }

          requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets$7 = [];

            if (!activationState.wasElementMadeActive && (e.key === ' ' || e.keyCode === 32)) {
              // If space was pressed, try again within an rAF call to detect :active, because different UAs report
              // active states inconsistently when they're called within event handling code:
              // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
              // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
              // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
              // variable is set within a rAF callback for a submit button interaction (#2241).
              activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

              if (activationState.wasElementMadeActive) {
                _this9.animateActivation_();
              }
            }

            if (!activationState.wasElementMadeActive) {
              // Reset activation state immediately if element was not made active.
              _this9.activationState_ = _this9.defaultActivationState_();
            }
          });
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "checkElementMadeActive_",
        value: function checkElementMadeActive_(e) {
          return e && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
        }
        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: "activate",
        value: function activate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          this.activate_(event);
        }
        /** @private */

      }, {
        key: "animateActivation_",
        value: function animateActivation_() {
          var _this10 = this;

          var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
              VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
              VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
          var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
              FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
              FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
          var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
          this.layoutInternal_();
          var translateStart = '';
          var translateEnd = '';

          if (!this.adapter_.isUnbounded()) {
            var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
                startPoint = _this$getFgTranslatio.startPoint,
                endPoint = _this$getFgTranslatio.endPoint;

            translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
            translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
          }

          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

          clearTimeout(this.activationTimer_);
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.rmBoundedActivationClasses_();
          this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

          this.adapter_.computeBoundingRect();
          this.adapter_.addClass(FG_ACTIVATION);
          this.activationTimer_ = setTimeout(function () {
            return _this10.activationTimerCallback_();
          }, DEACTIVATION_TIMEOUT_MS);
        }
        /**
         * @private
         * @return {{startPoint: PointType, endPoint: PointType}}
         */

      }, {
        key: "getFgTranslationCoordinates_",
        value: function getFgTranslationCoordinates_() {
          var _this$activationState = this.activationState_,
              activationEvent = _this$activationState.activationEvent,
              wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
          var startPoint;

          if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords$7(
            /** @type {!Event} */
            activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
          } else {
            startPoint = {
              x: this.frame_.width / 2,
              y: this.frame_.height / 2
            };
          } // Center the element around the start point.


          startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
          };
          var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
          };
          return {
            startPoint: startPoint,
            endPoint: endPoint
          };
        }
        /** @private */

      }, {
        key: "runDeactivationUXLogicIfReady_",
        value: function runDeactivationUXLogicIfReady_() {
          var _this11 = this;

          // This method is called both when a pointing device is released, and when the activation animation ends.
          // The deactivation animation should only run after both of those occur.
          var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
          var _this$activationState2 = this.activationState_,
              hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
              isActivated = _this$activationState2.isActivated;
          var activationHasEnded = hasDeactivationUXRun || !isActivated;

          if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
              _this11.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers$7.FG_DEACTIVATION_MS);
          }
        }
        /** @private */

      }, {
        key: "rmBoundedActivationClasses_",
        value: function rmBoundedActivationClasses_() {
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
          this.adapter_.removeClass(FG_ACTIVATION);
          this.activationAnimationHasEnded_ = false;
          this.adapter_.computeBoundingRect();
        }
      }, {
        key: "resetActivationState_",
        value: function resetActivationState_() {
          var _this12 = this;

          this.previousActivationEvent_ = this.activationState_.activationEvent;
          this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
          // Store the previous event until it's safe to assume that subsequent events are for new interactions.

          setTimeout(function () {
            return _this12.previousActivationEvent_ = null;
          }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "deactivate_",
        value: function deactivate_(e) {
          var _this13 = this;

          var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

          if (!activationState.isActivated) {
            return;
          }

          var state =
          /** @type {!ActivationStateType} */
          Object.assign({}, activationState);

          if (activationState.isProgrammatic) {
            var evtObject = null;
            requestAnimationFrame(function () {
              return _this13.animateDeactivation_(evtObject, state);
            });
            this.resetActivationState_();
          } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
              _this13.activationState_.hasDeactivationUXRun = true;

              _this13.animateDeactivation_(e, state);

              _this13.resetActivationState_();
            });
          }
        }
        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          this.deactivate_(event);
        }
        /**
         * @param {Event} e
         * @param {!ActivationStateType} options
         * @private
         */

      }, {
        key: "animateDeactivation_",
        value: function animateDeactivation_(e, _ref) {
          var wasActivatedByPointer = _ref.wasActivatedByPointer,
              wasElementMadeActive = _ref.wasElementMadeActive;

          if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this14 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }

          this.layoutFrame_ = requestAnimationFrame(function () {
            _this14.layoutInternal_();

            _this14.layoutFrame_ = 0;
          });
        }
        /** @private */

      }, {
        key: "layoutInternal_",
        value: function layoutInternal_() {
          var _this15 = this;

          this.frame_ = this.adapter_.computeBoundingRect();
          var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
          // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
          // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
          // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
          // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
          // `overflow: hidden`.

          var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
          };

          this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

          this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;
          this.fgScale_ = this.maxRadius_ / this.initialSize_;
          this.updateLayoutCssVars_();
        }
        /** @private */

      }, {
        key: "updateLayoutCssVars_",
        value: function updateLayoutCssVars_() {
          var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
              VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
              VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
              VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
              VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
          this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
          this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

          if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
              left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
              top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };
            this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
            this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
          }
        }
        /** @param {boolean} unbounded */

      }, {
        key: "setUnbounded",
        value: function setUnbounded(unbounded) {
          var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

          if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
          } else {
            this.adapter_.removeClass(UNBOUNDED);
          }
        }
      }, {
        key: "handleFocus",
        value: function handleFocus() {
          var _this16 = this;

          requestAnimationFrame(function () {
            return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }, {
        key: "handleBlur",
        value: function handleBlur() {
          var _this17 = this;

          requestAnimationFrame(function () {
            return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }]);

      return MDCRippleFoundation;
    }(MDCFoundation$a);

    /**
     * @extends MDCComponent<!MDCRippleFoundation>
     */

    var MDCRipple$7 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$b(MDCRipple, _MDCComponent);

      /** @param {...?} args */
      function MDCRipple() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$b(this, MDCRipple);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$b(this, (_getPrototypeOf2 = _getPrototypeOf$b(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {boolean} */

        _this.disabled = false;
        /** @private {boolean} */

        _this.unbounded_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @param {{isUnbounded: (boolean|undefined)}=} options
       * @return {!MDCRipple}
       */


      _createClass$b(MDCRipple, [{
        key: "setUnbounded_",

        /**
         * Closure Compiler throws an access control error when directly accessing a
         * protected or private property inside a getter/setter, like unbounded above.
         * By accessing the protected property inside a method, we solve that problem.
         * That's why this function exists.
         * @private
         */
        value: function setUnbounded_() {
          this.foundation_.setUnbounded(this.unbounded_);
        }
      }, {
        key: "activate",
        value: function activate() {
          this.foundation_.activate();
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
        /**
         * @return {!MDCRippleFoundation}
         * @override
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          return new MDCRippleFoundation$7(MDCRipple.createAdapter(this));
        }
        /** @override */

      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
        }
      }, {
        key: "unbounded",

        /** @return {boolean} */
        get: function get() {
          return this.unbounded_;
        }
        /** @param {boolean} unbounded */
        ,
        set: function set(unbounded) {
          this.unbounded_ = Boolean(unbounded);
          this.setUnbounded_();
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref$isUnbounded = _ref.isUnbounded,
              isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

          var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

          if (isUnbounded !== undefined) {
            ripple.unbounded =
            /** @type {boolean} */
            isUnbounded;
          }

          return ripple;
        }
        /**
         * @param {!RippleCapableSurface} instance
         * @return {!MDCRippleAdapter}
         */

      }, {
        key: "createAdapter",
        value: function createAdapter(instance) {
          var MATCHES = getMatchesProperty$7(HTMLElement.prototype);
          return {
            browserSupportsCssVars: function browserSupportsCssVars() {
              return supportsCssVariables$7(window);
            },
            isUnbounded: function isUnbounded() {
              return instance.unbounded;
            },
            isSurfaceActive: function isSurfaceActive() {
              return instance.root_[MATCHES](':active');
            },
            isSurfaceDisabled: function isSurfaceDisabled() {
              return instance.disabled;
            },
            addClass: function addClass(className) {
              return instance.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return instance.root_.classList.remove(className);
            },
            containsEventTarget: function containsEventTarget(target) {
              return instance.root_.contains(target);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return instance.root_.addEventListener(evtType, handler, applyPassive$8());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return instance.root_.removeEventListener(evtType, handler, applyPassive$8());
            },
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.addEventListener(evtType, handler, applyPassive$8());
            },
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.removeEventListener(evtType, handler, applyPassive$8());
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return instance.root_.style.setProperty(varName, value);
            },
            computeBoundingRect: function computeBoundingRect() {
              return instance.root_.getBoundingClientRect();
            },
            getWindowPageOffset: function getWindowPageOffset() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            }
          };
        }
      }]);

      return MDCRipple;
    }(MDCComponent$a);

    /**
     * @extends {MDCComponent<!MDCIconToggleFoundation>}
     */

    var MDCIconToggle =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$b(MDCIconToggle, _MDCComponent);

      _createClass$b(MDCIconToggle, null, [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCIconToggle(root);
        }
      }]);

      function MDCIconToggle() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$b(this, MDCIconToggle);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$b(this, (_getPrototypeOf2 = _getPrototypeOf$b(MDCIconToggle)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {!MDCRipple} */

        _this.ripple_ = _this.initRipple_();
        return _this;
      }
      /** @return {!Element} */


      _createClass$b(MDCIconToggle, [{
        key: "initRipple_",

        /**
         * @return {!MDCRipple}
         * @private
         */
        value: function initRipple_() {
          var _this2 = this;

          var adapter = Object.assign(MDCRipple$7.createAdapter(this), {
            isUnbounded: function isUnbounded() {
              return true;
            },
            isSurfaceActive: function isSurfaceActive() {
              return _this2.foundation_.isKeyboardActivated();
            }
          });
          var foundation = new MDCRippleFoundation$7(adapter);
          return new MDCRipple$7(this.root_, foundation);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.ripple_.destroy();

          _get$7(_getPrototypeOf$b(MDCIconToggle.prototype), "destroy", this).call(this);
        }
        /** @return {!MDCIconToggleFoundation} */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this3 = this;

          return new MDCIconToggleFoundation({
            addClass: function addClass(className) {
              return _this3.iconEl_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this3.iconEl_.classList.remove(className);
            },
            registerInteractionHandler: function registerInteractionHandler(type, handler) {
              return _this3.root_.addEventListener(type, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
              return _this3.root_.removeEventListener(type, handler);
            },
            setText: function setText(text) {
              return _this3.iconEl_.textContent = text;
            },
            getTabIndex: function getTabIndex() {
              return (
                /* number */
                _this3.root_.tabIndex
              );
            },
            setTabIndex: function setTabIndex(tabIndex) {
              return _this3.root_.tabIndex = tabIndex;
            },
            getAttr: function getAttr(name, value) {
              return _this3.root_.getAttribute(name, value);
            },
            setAttr: function setAttr(name, value) {
              return _this3.root_.setAttribute(name, value);
            },
            rmAttr: function rmAttr(name) {
              return _this3.root_.removeAttribute(name);
            },
            notifyChange: function notifyChange(evtData) {
              return _this3.emit(MDCIconToggleFoundation.strings.CHANGE_EVENT, evtData);
            }
          });
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.on = this.root_.getAttribute(MDCIconToggleFoundation.strings.ARIA_PRESSED) === 'true';
          this.disabled = this.root_.getAttribute(MDCIconToggleFoundation.strings.ARIA_DISABLED) === 'true';
        }
        /** @return {!MDCRipple} */

      }, {
        key: "refreshToggleData",
        value: function refreshToggleData() {
          this.foundation_.refreshToggleData();
        }
      }, {
        key: "iconEl_",
        get: function get$$1() {
          var sel = this.root_.dataset['iconInnerSelector'];
          return sel ?
          /** @type {!Element} */
          this.root_.querySelector(sel) : this.root_;
        }
      }, {
        key: "ripple",
        get: function get$$1() {
          return this.ripple_;
        }
        /** @return {boolean} */

      }, {
        key: "on",
        get: function get$$1() {
          return this.foundation_.isOn();
        }
        /** @param {boolean} isOn */
        ,
        set: function set(isOn) {
          this.foundation_.toggle(isOn);
        }
        /** @return {boolean} */

      }, {
        key: "disabled",
        get: function get$$1() {
          return this.foundation_.isDisabled();
        }
        /** @param {boolean} isDisabled */
        ,
        set: function set(isDisabled) {
          this.foundation_.setDisabled(isDisabled);
        }
      }]);

      return MDCIconToggle;
    }(MDCComponent$a);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ MD_ICON_TOGGLE_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return MdcIconToggle; }),
        multi: true
    };
    var MdcIconToggle = /** @class */ (function () {
        function MdcIconToggle(_changeDetectorRef, _renderer, elementRef, ripple, _registry) {
            var _this = this;
            this._changeDetectorRef = _changeDetectorRef;
            this._renderer = _renderer;
            this.elementRef = elementRef;
            this.ripple = ripple;
            this._registry = _registry;
            this.onChange = function () { };
            this.onTouched = function () { };
            this.change = new core.EventEmitter();
            this.isHostClass = true;
            this.role = 'button';
            this.ariaPressed = 'false';
            this.tabindex = '0';
            this._mdcAdapter = {
                addClass: function (className) { return _this._renderer.addClass(_this.iconClass ? _this._getIconElement() : _this._getHostElement(), className); },
                removeClass: function (className) {
                    return _this._renderer.removeClass(_this.iconClass ? _this._getIconElement() : _this._getHostElement(), className);
                },
                registerInteractionHandler: function (type, handler) { return _this._registry.listen(type, handler, _this._getHostElement()); },
                deregisterInteractionHandler: function (type, handler) { return _this._registry.unlisten(type, handler); },
                setText: function (text) { return _this._getIconElement().textContent = text; },
                getTabIndex: function () { return _this._getHostElement().tabIndex; },
                setTabIndex: function (tabIndex) { return _this._getHostElement().tabIndex = tabIndex; },
                getAttr: function (name) { return _this._getHostElement().getAttribute(name); },
                setAttr: function (name, value) { return _this._renderer.setAttribute(_this._getHostElement(), name, value); },
                rmAttr: function (name) { return _this._renderer.removeAttribute(_this._getHostElement(), name); },
                notifyChange: function (evtData) {
                    _this.change.emit(evtData.isOn);
                    _this.onChange(_this._foundation.isOn());
                }
            };
            this._foundation = new MDCIconToggleFoundation(this._mdcAdapter);
        }
        Object.defineProperty(MdcIconToggle.prototype, "iconClass", {
            get: /**
             * @return {?}
             */
            function () { return this._iconClass; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setIconClass(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIconToggle.prototype, "on", {
            get: /**
             * @return {?}
             */
            function () { return this._foundation.isOn(); },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setOn(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIconToggle.prototype, "value", {
            get: /**
             * @return {?}
             */
            function () { return this._foundation.isOn(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIconToggle.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setDisabled(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIconToggle.prototype, "primary", {
            get: /**
             * @return {?}
             */
            function () { return this._primary; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setPrimary(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIconToggle.prototype, "secondary", {
            get: /**
             * @return {?}
             */
            function () { return this._secondary; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setSecondary(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIconToggle.prototype, "classPrimary", {
            get: /**
             * @return {?}
             */
            function () {
                return this.primary ? 'ng-mdc-icon-toggle--primary' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIconToggle.prototype, "classSecondary", {
            get: /**
             * @return {?}
             */
            function () {
                return this.secondary ? 'ng-mdc-icon-toggle--secondary' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIconToggle.prototype, "dataToggleOn", {
            get: /**
             * @return {?}
             */
            function () {
                return JSON.stringify({
                    content: this.iconOn,
                    label: this.labelOn,
                    cssClass: this.cssClassOn
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcIconToggle.prototype, "dataToggleOff", {
            get: /**
             * @return {?}
             */
            function () {
                return JSON.stringify({
                    content: this.iconOff,
                    label: this.labelOff,
                    cssClass: this.cssClassOff
                });
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcIconToggle.prototype.onclick = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            this._onClick(evt);
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcIconToggle.prototype.onkeydown = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            this._onKeydown(evt);
        };
        /**
         * @return {?}
         */
        MdcIconToggle.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this._foundation.init();
            this._foundation.refreshToggleData();
            this._foundation.toggle(this._on || this._foundation.isOn());
            this.ripple.attachTo(this._getHostElement(), true);
            this._changeDetectorRef.detectChanges();
        };
        /**
         * @return {?}
         */
        MdcIconToggle.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.ripple.destroy();
            this._foundation.destroy();
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MdcIconToggle.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.onChange(value);
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcIconToggle.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcIconToggle.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onTouched = fn;
        };
        /**
         * @param {?=} isOn
         * @return {?}
         */
        MdcIconToggle.prototype.toggle = /**
         * @param {?=} isOn
         * @return {?}
         */
        function (isOn) {
            this._foundation.toggle(isOn);
        };
        /**
         * @return {?}
         */
        MdcIconToggle.prototype.refreshToggleData = /**
         * @return {?}
         */
        function () {
            this._foundation.refreshToggleData();
        };
        /**
         * @param {?} iconClass
         * @return {?}
         */
        MdcIconToggle.prototype.setIconClass = /**
         * @param {?} iconClass
         * @return {?}
         */
        function (iconClass) {
            this._renderer.removeClass(this._getIconElement(), this._iconClass);
            this._iconClass = iconClass ? iconClass : 'material-icons';
            this._renderer.addClass(this._getIconElement(), this._iconClass);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @return {?}
         */
        MdcIconToggle.prototype.isOn = /**
         * @return {?}
         */
        function () {
            return this._foundation.isOn();
        };
        /**
         * @param {?} on
         * @return {?}
         */
        MdcIconToggle.prototype.setOn = /**
         * @param {?} on
         * @return {?}
         */
        function (on) {
            if (on !== this._on) {
                this._on = on;
                this._foundation.refreshToggleData();
                this._foundation.toggle(on);
                this._changeDetectorRef.markForCheck();
            }
        };
        /**
         * @param {?} primary
         * @return {?}
         */
        MdcIconToggle.prototype.setPrimary = /**
         * @param {?} primary
         * @return {?}
         */
        function (primary) {
            this._primary = toBoolean(primary);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} secondary
         * @return {?}
         */
        MdcIconToggle.prototype.setSecondary = /**
         * @param {?} secondary
         * @return {?}
         */
        function (secondary) {
            this._secondary = toBoolean(secondary);
            this._changeDetectorRef.markForCheck();
        };
        /** Sets the button disabled state */
        /**
         * Sets the button disabled state
         * @param {?} disabled
         * @return {?}
         */
        MdcIconToggle.prototype.setDisabled = /**
         * Sets the button disabled state
         * @param {?} disabled
         * @return {?}
         */
        function (disabled) {
            this._disabled = disabled;
            this._foundation.setDisabled(disabled);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} event
         * @return {?}
         */
        MdcIconToggle.prototype._onClick = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            // A disabled button shouldn't apply any actions
            if (this.disabled) {
                event.preventDefault();
                event.stopImmediatePropagation();
            }
        };
        /**
         * @param {?} event
         * @return {?}
         */
        MdcIconToggle.prototype._onKeydown = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (this.disabled) {
                return;
            }
            if (event.keyCode === SPACE) {
                this.ripple.setSurfaceActive(true);
            }
            else {
                this.ripple.setSurfaceActive(false);
            }
        };
        /**
         * @return {?}
         */
        MdcIconToggle.prototype._getIconElement = /**
         * @return {?}
         */
        function () {
            return this.icon.elementRef.nativeElement;
        };
        /**
         * @return {?}
         */
        MdcIconToggle.prototype._getHostElement = /**
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcIconToggle.decorators = [
            { type: core.Component, args: [{selector: 'mdc-icon-toggle',
                        exportAs: 'mdcIconToggle',
                        template: '<mdc-icon></mdc-icon>',
                        providers: [
                            MD_ICON_TOGGLE_CONTROL_VALUE_ACCESSOR,
                            MdcRipple,
                            EventRegistry,
                        ],
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcIconToggle.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.Renderer2 },
            { type: core.ElementRef },
            { type: MdcRipple },
            { type: EventRegistry }
        ]; };
        MdcIconToggle.propDecorators = {
            iconOn: [{ type: core.Input }],
            iconOff: [{ type: core.Input }],
            labelOn: [{ type: core.Input }],
            labelOff: [{ type: core.Input }],
            cssClassOn: [{ type: core.Input }],
            cssClassOff: [{ type: core.Input }],
            iconClass: [{ type: core.Input }],
            on: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            primary: [{ type: core.Input }],
            secondary: [{ type: core.Input }],
            change: [{ type: core.Output }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-icon-toggle',] }],
            role: [{ type: core.HostBinding, args: ['attr.role',] }],
            ariaPressed: [{ type: core.HostBinding, args: ['attr.aria-pressed',] }],
            tabindex: [{ type: core.HostBinding, args: ['attr.tabIndex',] }],
            classPrimary: [{ type: core.HostBinding, args: ['class.ng-mdc-icon-toggle--primary',] }],
            classSecondary: [{ type: core.HostBinding, args: ['class.ng-mdc-icon-toggle--secondary',] }],
            dataToggleOn: [{ type: core.HostBinding, args: ['attr.data-toggle-on',] }],
            dataToggleOff: [{ type: core.HostBinding, args: ['attr.data-toggle-off',] }],
            onclick: [{ type: core.HostListener, args: ['click', ['$event'],] }],
            onkeydown: [{ type: core.HostListener, args: ['keydown', ['$event'],] }],
            icon: [{ type: core.ViewChild, args: [MdcIcon,] }]
        };
        return MdcIconToggle;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcIconToggleModule = /** @class */ (function () {
        function MdcIconToggleModule() {
        }
        MdcIconToggleModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            forms.FormsModule,
                            MdcIconModule
                        ],
                        exports: [
                            MdcIconToggle,
                            MdcIconModule,
                        ],
                        declarations: [MdcIconToggle]
                    },] },
        ];
        return MdcIconToggleModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcImageListItem = /** @class */ (function () {
        function MdcImageListItem(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcImageListItem.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcImageListItem], mdc-image-list-item',
                        exportAs: 'mdcImageListItem'
                    },] },
        ];
        /** @nocollapse */
        MdcImageListItem.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcImageListItem.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-image-list__item',] }]
        };
        return MdcImageListItem;
    }());
    var MdcImageListImageAspect = /** @class */ (function () {
        function MdcImageListImageAspect(elementRef) {
            this.elementRef = elementRef;
        }
        MdcImageListImageAspect.decorators = [
            { type: core.Component, args: [{selector: '[mdcImageListImageAspect], mdc-image-list-image-aspect',
                        exportAs: 'mdcImageListImageAspect',
                        template: "\n  <div class=\"mdc-image-list__image-aspect-container\">\n    <ng-content></ng-content>\n  </div>\n  ",
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcImageListImageAspect.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcImageListImageAspect;
    }());
    var MdcImageListImage = /** @class */ (function () {
        function MdcImageListImage(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcImageListImage.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcImageListImage], mdc-image-list-image',
                        exportAs: 'mdcImageListImage'
                    },] },
        ];
        /** @nocollapse */
        MdcImageListImage.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcImageListImage.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-image-list__image',] }]
        };
        return MdcImageListImage;
    }());
    var MdcImageListSupporting = /** @class */ (function () {
        function MdcImageListSupporting(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcImageListSupporting.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcImageListSupporting], mdc-image-list-supporting',
                        exportAs: 'mdcImageListSupporting',
                    },] },
        ];
        /** @nocollapse */
        MdcImageListSupporting.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcImageListSupporting.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-image-list__supporting',] }]
        };
        return MdcImageListSupporting;
    }());
    var MdcImageListLabel = /** @class */ (function () {
        function MdcImageListLabel(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcImageListLabel.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcImageListLabel], mdc-image-list-label',
                        exportAs: 'mdcImageListLabel'
                    },] },
        ];
        /** @nocollapse */
        MdcImageListLabel.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcImageListLabel.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-image-list__label',] }]
        };
        return MdcImageListLabel;
    }());
    var MdcImageList = /** @class */ (function () {
        function MdcImageList(_changeDetectorRef, elementRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        Object.defineProperty(MdcImageList.prototype, "masonry", {
            get: /**
             * @return {?}
             */
            function () { return this._masonry; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setMasonry(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcImageList.prototype, "textProtection", {
            get: /**
             * @return {?}
             */
            function () { return this._textProtection; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setTextProtection(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcImageList.prototype, "classMasonry", {
            get: /**
             * @return {?}
             */
            function () {
                return this.masonry ? 'mdc-image-list--masonry' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcImageList.prototype, "classTextProtection", {
            get: /**
             * @return {?}
             */
            function () {
                return this.textProtection ? 'mdc-image-list--with-text-protection' : '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} masonry
         * @return {?}
         */
        MdcImageList.prototype.setMasonry = /**
         * @param {?} masonry
         * @return {?}
         */
        function (masonry) {
            this._masonry = masonry;
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} textProtection
         * @return {?}
         */
        MdcImageList.prototype.setTextProtection = /**
         * @param {?} textProtection
         * @return {?}
         */
        function (textProtection) {
            this._textProtection = textProtection;
            this._changeDetectorRef.markForCheck();
        };
        MdcImageList.decorators = [
            { type: core.Component, args: [{selector: '[mdc-image-list], mdc-image-list',
                        exportAs: 'mdcImageList',
                        template: '<ng-content></ng-content>',
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcImageList.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef }
        ]; };
        MdcImageList.propDecorators = {
            masonry: [{ type: core.Input }],
            textProtection: [{ type: core.Input }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-image-list',] }],
            classMasonry: [{ type: core.HostBinding, args: ['class.mdc-image-list--masonry',] }],
            classTextProtection: [{ type: core.HostBinding, args: ['class.mdc-image-list--with-text-protection',] }]
        };
        return MdcImageList;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ IMAGE_LIST_DECLARATIONS = [
        MdcImageList,
        MdcImageListImage,
        MdcImageListImageAspect,
        MdcImageListItem,
        MdcImageListLabel,
        MdcImageListSupporting
    ];
    var MdcImageListModule = /** @class */ (function () {
        function MdcImageListModule() {
        }
        MdcImageListModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: IMAGE_LIST_DECLARATIONS,
                        declarations: IMAGE_LIST_DECLARATIONS,
                    },] },
        ];
        return MdcImageListModule;
    }());

    function _classCallCheck$c(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$c(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$c(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$c(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$c(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$c(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$c(subClass, superClass);
    }

    function _getPrototypeOf$c(o) {
      _getPrototypeOf$c = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$c(o);
    }

    function _setPrototypeOf$c(o, p) {
      _setPrototypeOf$c = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$c(o, p);
    }

    function _assertThisInitialized$c(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$c(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$c(self);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @template A
     */
    var MDCFoundation$b =
    /*#__PURE__*/
    function () {
      _createClass$c(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$c(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$c(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$b =
    /*#__PURE__*/
    function () {
      _createClass$c(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$b());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$c(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$c(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC TextField Line Ripple.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the line ripple into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCLineRippleAdapter =
    /*#__PURE__*/
    function () {
      function MDCLineRippleAdapter() {
        _classCallCheck$c(this, MDCLineRippleAdapter);
      }

      _createClass$c(MDCLineRippleAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the line ripple element.
         * @param {string} className
         */
        value: function addClass(className) {}
        /**
         * Removes a class from the line ripple element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * @param {string} className
         * @return {boolean}
         */

      }, {
        key: "hasClass",
        value: function hasClass(className) {}
        /**
         * Sets the style property with propertyName to value on the root element.
         * @param {string} propertyName
         * @param {string} value
         */

      }, {
        key: "setStyle",
        value: function setStyle(propertyName, value) {}
        /**
         * Registers an event listener on the line ripple element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerEventHandler",
        value: function registerEventHandler(evtType, handler) {}
        /**
         * Deregisters an event listener on the line ripple element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterEventHandler",
        value: function deregisterEventHandler(evtType, handler) {}
      }]);

      return MDCLineRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var cssClasses$a = {
      LINE_RIPPLE_ACTIVE: 'mdc-line-ripple--active',
      LINE_RIPPLE_DEACTIVATING: 'mdc-line-ripple--deactivating'
    };

    /**
     * @extends {MDCFoundation<!MDCLineRippleAdapter>}
     * @final
     */

    var MDCLineRippleFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$c(MDCLineRippleFoundation, _MDCFoundation);

      _createClass$c(MDCLineRippleFoundation, null, [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$a;
        }
        /**
         * {@see MDCLineRippleAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCLineRippleAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCLineRippleAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              hasClass: function hasClass() {},
              setStyle: function setStyle() {},
              registerEventHandler: function registerEventHandler() {},
              deregisterEventHandler: function deregisterEventHandler() {}
            }
          );
        }
        /**
         * @param {!MDCLineRippleAdapter=} adapter
         */

      }]);

      function MDCLineRippleFoundation() {
        var _this;

        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] :
        /** @type {!MDCLineRippleAdapter} */
        {};

        _classCallCheck$c(this, MDCLineRippleFoundation);

        _this = _possibleConstructorReturn$c(this, _getPrototypeOf$c(MDCLineRippleFoundation).call(this, Object.assign(MDCLineRippleFoundation.defaultAdapter, adapter)));
        /** @private {function(!Event): undefined} */

        _this.transitionEndHandler_ = function (evt) {
          return _this.handleTransitionEnd(evt);
        };

        return _this;
      }

      _createClass$c(MDCLineRippleFoundation, [{
        key: "init",
        value: function init() {
          this.adapter_.registerEventHandler('transitionend', this.transitionEndHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.adapter_.deregisterEventHandler('transitionend', this.transitionEndHandler_);
        }
        /**
         * Activates the line ripple
         */

      }, {
        key: "activate",
        value: function activate() {
          this.adapter_.removeClass(cssClasses$a.LINE_RIPPLE_DEACTIVATING);
          this.adapter_.addClass(cssClasses$a.LINE_RIPPLE_ACTIVE);
        }
        /**
         * Sets the center of the ripple animation to the given X coordinate.
         * @param {number} xCoordinate
         */

      }, {
        key: "setRippleCenter",
        value: function setRippleCenter(xCoordinate) {
          this.adapter_.setStyle('transform-origin', "".concat(xCoordinate, "px center"));
        }
        /**
         * Deactivates the line ripple
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          this.adapter_.addClass(cssClasses$a.LINE_RIPPLE_DEACTIVATING);
        }
        /**
         * Handles a transition end event
         * @param {!Event} evt
         */

      }, {
        key: "handleTransitionEnd",
        value: function handleTransitionEnd(evt) {
          // Wait for the line ripple to be either transparent or opaque
          // before emitting the animation end event
          var isDeactivating = this.adapter_.hasClass(cssClasses$a.LINE_RIPPLE_DEACTIVATING);

          if (evt.propertyName === 'opacity') {
            if (isDeactivating) {
              this.adapter_.removeClass(cssClasses$a.LINE_RIPPLE_ACTIVE);
              this.adapter_.removeClass(cssClasses$a.LINE_RIPPLE_DEACTIVATING);
            }
          }
        }
      }]);

      return MDCLineRippleFoundation;
    }(MDCFoundation$b);

    /**
     * @extends {MDCComponent<!MDCLineRippleFoundation>}
     * @final
     */

    var MDCLineRipple =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$c(MDCLineRipple, _MDCComponent);

      function MDCLineRipple() {
        _classCallCheck$c(this, MDCLineRipple);

        return _possibleConstructorReturn$c(this, _getPrototypeOf$c(MDCLineRipple).apply(this, arguments));
      }

      _createClass$c(MDCLineRipple, [{
        key: "activate",

        /**
         * Activates the line ripple
         */
        value: function activate() {
          this.foundation_.activate();
        }
        /**
         * Deactivates the line ripple
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
        /**
         * Sets the transform origin given a user's click location. The `rippleCenter` is the
         * x-coordinate of the middle of the ripple.
         * @param {number} xCoordinate
         */

      }, {
        key: "setRippleCenter",
        value: function setRippleCenter(xCoordinate) {
          this.foundation_.setRippleCenter(xCoordinate);
        }
        /**
         * @return {!MDCLineRippleFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCLineRippleFoundation(
          /** @type {!MDCLineRippleAdapter} */
          Object.assign({
            addClass: function addClass(className) {
              return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
              return _this.root_.classList.contains(className);
            },
            setStyle: function setStyle(propertyName, value) {
              return _this.root_.style[propertyName] = value;
            },
            registerEventHandler: function registerEventHandler(evtType, handler) {
              return _this.root_.addEventListener(evtType, handler);
            },
            deregisterEventHandler: function deregisterEventHandler(evtType, handler) {
              return _this.root_.removeEventListener(evtType, handler);
            }
          }));
        }
      }], [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCLineRipple}
         */
        value: function attachTo(root) {
          return new MDCLineRipple(root);
        }
      }]);

      return MDCLineRipple;
    }(MDCComponent$b);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcLineRipple = /** @class */ (function () {
        function MdcLineRipple(elementRef, _registry) {
            var _this = this;
            this.elementRef = elementRef;
            this._registry = _registry;
            this.isHostClass = true;
            this._mdcAdapter = {
                addClass: function (className) { return _this._getHostElement().classList.add(className); },
                removeClass: function (className) { return _this._getHostElement().classList.remove(className); },
                hasClass: function (className) { return _this._getHostElement().classList.contains(className); },
                setStyle: function (propertyName, value) { return _this._getHostElement().style.setProperty(propertyName, value); },
                registerEventHandler: function (evtType, handler) {
                    return _this._registry.listen(evtType, handler, _this._getHostElement());
                },
                deregisterEventHandler: function (evtType, handler) { return _this._registry.unlisten(evtType, handler); }
            };
            this.foundation = new MDCLineRippleFoundation(this._mdcAdapter);
        }
        /**
         * @return {?}
         */
        MdcLineRipple.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.foundation.init();
        };
        /**
         * @return {?}
         */
        MdcLineRipple.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.foundation.destroy();
        };
        /** Activates the line ripple */
        /**
         * Activates the line ripple
         * @return {?}
         */
        MdcLineRipple.prototype.activate = /**
         * Activates the line ripple
         * @return {?}
         */
        function () {
            this.foundation.activate();
        };
        /** Deactivates the line ripple */
        /**
         * Deactivates the line ripple
         * @return {?}
         */
        MdcLineRipple.prototype.deactivate = /**
         * Deactivates the line ripple
         * @return {?}
         */
        function () {
            this.foundation.deactivate();
        };
        /**
         * Sets the transform origin given a user's click location.
         * The `rippleCenter` is the x-coordinate of the middle of the ripple.
        */
        /**
         * Sets the transform origin given a user's click location.
         * The `rippleCenter` is the x-coordinate of the middle of the ripple.
         * @param {?} xCoordinate
         * @return {?}
         */
        MdcLineRipple.prototype.setRippleCenter = /**
         * Sets the transform origin given a user's click location.
         * The `rippleCenter` is the x-coordinate of the middle of the ripple.
         * @param {?} xCoordinate
         * @return {?}
         */
        function (xCoordinate) {
            this.foundation.setRippleCenter(xCoordinate);
        };
        /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        MdcLineRipple.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcLineRipple.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcLineRipple], mdc-line-ripple',
                        providers: [EventRegistry]
                    },] },
        ];
        /** @nocollapse */
        MdcLineRipple.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: EventRegistry }
        ]; };
        MdcLineRipple.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-line-ripple',] }]
        };
        return MdcLineRipple;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcLineRippleModule = /** @class */ (function () {
        function MdcLineRippleModule() {
        }
        MdcLineRippleModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [MdcLineRipple],
                        declarations: [MdcLineRipple],
                    },] },
        ];
        return MdcLineRippleModule;
    }());

    function _classCallCheck$d(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$d(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$d(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$d(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$d(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$d(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$d(subClass, superClass);
    }

    function _getPrototypeOf$d(o) {
      _getPrototypeOf$d = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$d(o);
    }

    function _setPrototypeOf$d(o, p) {
      _setPrototypeOf$d = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$d(o, p);
    }

    function _assertThisInitialized$d(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$d(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$d(self);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @template A
     */
    var MDCFoundation$c =
    /*#__PURE__*/
    function () {
      _createClass$d(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$d(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$d(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$c =
    /*#__PURE__*/
    function () {
      _createClass$d(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$c());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$d(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$d(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // property names.


    var transformStyleProperties = ['transform', 'WebkitTransform', 'MozTransform', 'OTransform', 'MSTransform'];

    /**
     * Copyright 2017 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var cssClasses$b = {
      CLOSED_CLASS: 'mdc-linear-progress--closed',
      INDETERMINATE_CLASS: 'mdc-linear-progress--indeterminate',
      REVERSED_CLASS: 'mdc-linear-progress--reversed'
    };
    var strings$a = {
      PRIMARY_BAR_SELECTOR: '.mdc-linear-progress__primary-bar',
      BUFFER_SELECTOR: '.mdc-linear-progress__buffer'
    };

    var MDCLinearProgressFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$d(MDCLinearProgressFoundation, _MDCFoundation);

      _createClass$d(MDCLinearProgressFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$b;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$a;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            addClass: function addClass()
            /* className: string */
            {},
            getPrimaryBar: function getPrimaryBar()
            /* el: Element */
            {},
            getBuffer: function getBuffer()
            /* el: Element */
            {},
            hasClass: function hasClass() {
              return (
                /* className: string */
                false
              );
            },
            removeClass: function removeClass()
            /* className: string */
            {},
            setStyle: function setStyle()
            /* el: Element, styleProperty: string, value: string */
            {}
          };
        }
      }]);

      function MDCLinearProgressFoundation(adapter) {
        _classCallCheck$d(this, MDCLinearProgressFoundation);

        return _possibleConstructorReturn$d(this, _getPrototypeOf$d(MDCLinearProgressFoundation).call(this, Object.assign(MDCLinearProgressFoundation.defaultAdapter, adapter)));
      }

      _createClass$d(MDCLinearProgressFoundation, [{
        key: "init",
        value: function init() {
          this.determinate_ = !this.adapter_.hasClass(cssClasses$b.INDETERMINATE_CLASS);
          this.reverse_ = this.adapter_.hasClass(cssClasses$b.REVERSED_CLASS);
          this.progress_ = 0;
        }
      }, {
        key: "setDeterminate",
        value: function setDeterminate(isDeterminate) {
          this.determinate_ = isDeterminate;

          if (this.determinate_) {
            this.adapter_.removeClass(cssClasses$b.INDETERMINATE_CLASS);
            this.setScale_(this.adapter_.getPrimaryBar(), this.progress_);
          } else {
            this.adapter_.addClass(cssClasses$b.INDETERMINATE_CLASS);
            this.setScale_(this.adapter_.getPrimaryBar(), 1);
            this.setScale_(this.adapter_.getBuffer(), 1);
          }
        }
      }, {
        key: "setProgress",
        value: function setProgress(value) {
          this.progress_ = value;

          if (this.determinate_) {
            this.setScale_(this.adapter_.getPrimaryBar(), value);
          }
        }
      }, {
        key: "setBuffer",
        value: function setBuffer(value) {
          if (this.determinate_) {
            this.setScale_(this.adapter_.getBuffer(), value);
          }
        }
      }, {
        key: "setReverse",
        value: function setReverse(isReversed) {
          this.reverse_ = isReversed;

          if (this.reverse_) {
            this.adapter_.addClass(cssClasses$b.REVERSED_CLASS);
          } else {
            this.adapter_.removeClass(cssClasses$b.REVERSED_CLASS);
          }
        }
      }, {
        key: "open",
        value: function open() {
          this.adapter_.removeClass(cssClasses$b.CLOSED_CLASS);
        }
      }, {
        key: "close",
        value: function close() {
          this.adapter_.addClass(cssClasses$b.CLOSED_CLASS);
        }
      }, {
        key: "setScale_",
        value: function setScale_(el, scaleValue) {
          var _this = this;

          var value = 'scaleX(' + scaleValue + ')';
          transformStyleProperties.forEach(function (transformStyleProperty) {
            _this.adapter_.setStyle(el, transformStyleProperty, value);
          });
        }
      }]);

      return MDCLinearProgressFoundation;
    }(MDCFoundation$c);

    var MDCLinearProgress =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$d(MDCLinearProgress, _MDCComponent);

      function MDCLinearProgress() {
        _classCallCheck$d(this, MDCLinearProgress);

        return _possibleConstructorReturn$d(this, _getPrototypeOf$d(MDCLinearProgress).apply(this, arguments));
      }

      _createClass$d(MDCLinearProgress, [{
        key: "open",
        value: function open() {
          this.foundation_.open();
        }
      }, {
        key: "close",
        value: function close() {
          this.foundation_.close();
        }
      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCLinearProgressFoundation({
            addClass: function addClass(className) {
              return _this.root_.classList.add(className);
            },
            getPrimaryBar: function getPrimaryBar() {
              return _this.root_.querySelector(MDCLinearProgressFoundation.strings.PRIMARY_BAR_SELECTOR);
            },
            getBuffer: function getBuffer() {
              return _this.root_.querySelector(MDCLinearProgressFoundation.strings.BUFFER_SELECTOR);
            },
            hasClass: function hasClass(className) {
              return _this.root_.classList.contains(className);
            },
            removeClass: function removeClass(className) {
              return _this.root_.classList.remove(className);
            },
            setStyle: function setStyle(el, styleProperty, value) {
              return el.style[styleProperty] = value;
            }
          });
        }
      }, {
        key: "determinate",
        set: function set(value) {
          this.foundation_.setDeterminate(value);
        }
      }, {
        key: "progress",
        set: function set(value) {
          this.foundation_.setProgress(value);
        }
      }, {
        key: "buffer",
        set: function set(value) {
          this.foundation_.setBuffer(value);
        }
      }, {
        key: "reverse",
        set: function set(value) {
          this.foundation_.setReverse(value);
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCLinearProgress(root);
        }
      }]);

      return MDCLinearProgress;
    }(MDCComponent$c);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcLinearProgress = /** @class */ (function () {
        function MdcLinearProgress(_changeDetectorRef, _renderer, elementRef) {
            var _this = this;
            this._changeDetectorRef = _changeDetectorRef;
            this._renderer = _renderer;
            this.elementRef = elementRef;
            this._reversed = false;
            this.secondary = false;
            this.closed = false;
            this.role = 'progressbar';
            this.isHostClass = true;
            this._mdcAdapter = {
                addClass: function (className) { return _this._renderer.addClass(_this._getHostElement(), className); },
                getPrimaryBar: function () { return _this._getHostElement().querySelector('.mdc-linear-progress__primary-bar'); },
                getBuffer: function () { return _this._getHostElement().querySelector('.mdc-linear-progress__buffer'); },
                hasClass: function (className) { return _this._getHostElement().classList.contains(className); },
                removeClass: function (className) { return _this._renderer.removeClass(_this._getHostElement(), className); },
                setStyle: function (el, styleProperty, value) { return _this._renderer.setStyle(el, styleProperty, value); }
            };
            this._foundation = new MDCLinearProgressFoundation(this._mdcAdapter);
        }
        Object.defineProperty(MdcLinearProgress.prototype, "determinate", {
            get: /**
             * @return {?}
             */
            function () { return this._determinate; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setDeterminate(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcLinearProgress.prototype, "reversed", {
            get: /**
             * @return {?}
             */
            function () { return this._reversed; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setReverse(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcLinearProgress.prototype, "progress", {
            get: /**
             * @return {?}
             */
            function () { return this._progress; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setProgress(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcLinearProgress.prototype, "buffer", {
            get: /**
             * @return {?}
             */
            function () { return this._buffer; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setBuffer(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcLinearProgress.prototype, "classSecondary", {
            get: /**
             * @return {?}
             */
            function () {
                return this.secondary ? 'mdc-linear-progress--secondary' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcLinearProgress.prototype, "classClosed", {
            get: /**
             * @return {?}
             */
            function () {
                return this.closed ? 'mdc-linear-progress--closed' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcLinearProgress.prototype, "classIndeterminate", {
            get: /**
             * @return {?}
             */
            function () {
                return !this.determinate ? 'mdc-linear-progress--indeterminate' : '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcLinearProgress.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this._foundation.init();
        };
        /**
         * @return {?}
         */
        MdcLinearProgress.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._foundation.destroy();
        };
        /**
         * @return {?}
         */
        MdcLinearProgress.prototype.open = /**
         * @return {?}
         */
        function () {
            this._foundation.open();
        };
        /**
         * @return {?}
         */
        MdcLinearProgress.prototype.close = /**
         * @return {?}
         */
        function () {
            this._foundation.close();
        };
        /**
         * @param {?} progress
         * @return {?}
         */
        MdcLinearProgress.prototype.setProgress = /**
         * @param {?} progress
         * @return {?}
         */
        function (progress) {
            this._progress = progress;
            this._foundation.setProgress(progress);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} buffer
         * @return {?}
         */
        MdcLinearProgress.prototype.setBuffer = /**
         * @param {?} buffer
         * @return {?}
         */
        function (buffer) {
            this._buffer = buffer;
            this._foundation.setBuffer(buffer);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} reverse
         * @return {?}
         */
        MdcLinearProgress.prototype.setReverse = /**
         * @param {?} reverse
         * @return {?}
         */
        function (reverse) {
            this._reversed = reverse;
            this._foundation.setReverse(reverse);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} determinate
         * @return {?}
         */
        MdcLinearProgress.prototype.setDeterminate = /**
         * @param {?} determinate
         * @return {?}
         */
        function (determinate) {
            this._determinate = determinate;
            this._foundation.setDeterminate(determinate);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        MdcLinearProgress.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcLinearProgress.decorators = [
            { type: core.Component, args: [{selector: 'mdc-linear-progress',
                        exportAs: 'mdcLinearProgress',
                        template: "\n  <div class=\"mdc-linear-progress__buffering-dots\"></div>\n  <div class=\"mdc-linear-progress__buffer\"></div>\n  <div class=\"mdc-linear-progress__bar mdc-linear-progress__primary-bar\">\n   <span class=\"mdc-linear-progress__bar-inner\"></span>\n  </div>\n  <div class=\"mdc-linear-progress__bar mdc-linear-progress__secondary-bar\">\n   <span class=\"mdc-linear-progress__bar-inner\"></span>\n  </div>\n  ",
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcLinearProgress.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.Renderer2 },
            { type: core.ElementRef }
        ]; };
        MdcLinearProgress.propDecorators = {
            determinate: [{ type: core.Input }],
            reversed: [{ type: core.Input }],
            secondary: [{ type: core.Input }],
            closed: [{ type: core.Input }],
            progress: [{ type: core.Input }],
            buffer: [{ type: core.Input }],
            role: [{ type: core.HostBinding, args: ['attr.role',] }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-linear-progress',] }],
            classSecondary: [{ type: core.HostBinding, args: ['class.mdc-linear-progress--secondary',] }],
            classClosed: [{ type: core.HostBinding, args: ['class.mdc-linear-progress--closed',] }],
            classIndeterminate: [{ type: core.HostBinding, args: ['class.mdc-linear-progress--indeterminate',] }]
        };
        return MdcLinearProgress;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcLinearProgressModule = /** @class */ (function () {
        function MdcLinearProgressModule() {
        }
        MdcLinearProgressModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [MdcLinearProgress],
                        declarations: [MdcLinearProgress],
                    },] },
        ];
        return MdcLinearProgressModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Change event that is fired whenever the selected state of an option changes.
     */
    var   /**
     * Change event that is fired whenever the selected state of an option changes.
     */
    MdcListSelectionChange = /** @class */ (function () {
        function MdcListSelectionChange(source) {
            this.source = source;
        }
        return MdcListSelectionChange;
    }());
    var /** @type {?} */ uniqueIdCounter = 0;
    var MdcListItemGraphic = /** @class */ (function () {
        function MdcListItemGraphic(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
            this.ariaHidden = 'true';
        }
        MdcListItemGraphic.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcListItemGraphic], mdc-list-item-graphic',
                        exportAs: 'mdcListItemGraphic',
                    },] },
        ];
        /** @nocollapse */
        MdcListItemGraphic.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcListItemGraphic.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-list-item__graphic',] }],
            ariaHidden: [{ type: core.HostBinding, args: ['attr.aria-hidden',] }]
        };
        return MdcListItemGraphic;
    }());
    var MdcListItemMeta = /** @class */ (function () {
        function MdcListItemMeta(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcListItemMeta.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcListItemMeta], mdc-list-item-meta',
                        exportAs: 'mdcListItemMeta',
                    },] },
        ];
        /** @nocollapse */
        MdcListItemMeta.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcListItemMeta.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-list-item__meta',] }]
        };
        return MdcListItemMeta;
    }());
    var MdcListItemText = /** @class */ (function () {
        function MdcListItemText(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcListItemText.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcListItemText], mdc-list-item-text',
                        exportAs: 'mdcListItemText',
                    },] },
        ];
        /** @nocollapse */
        MdcListItemText.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcListItemText.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-list-item__text',] }]
        };
        return MdcListItemText;
    }());
    var MdcListItemSecondary = /** @class */ (function () {
        function MdcListItemSecondary(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcListItemSecondary.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcListItemSecondary], mdc-list-item-secondary',
                        exportAs: 'mdcListItemSecondary',
                    },] },
        ];
        /** @nocollapse */
        MdcListItemSecondary.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcListItemSecondary.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-list-item__secondary-text',] }]
        };
        return MdcListItemSecondary;
    }());
    var MdcListItem = /** @class */ (function () {
        function MdcListItem(ripple, _changeDetector, elementRef) {
            this.ripple = ripple;
            this._changeDetector = _changeDetector;
            this.elementRef = elementRef;
            this._id = "mdc-list-item-" + uniqueIdCounter++;
            this.isHostClass = true;
            this.tabIndex = -1;
            this.role = 'listitem';
            this.selectionChange = new core.EventEmitter();
        }
        Object.defineProperty(MdcListItem.prototype, "id", {
            /** The unique ID of the option. */
            get: /**
             * The unique ID of the option.
             * @return {?}
             */
            function () { return this._id; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcListItem.prototype, "classSelected", {
            get: /**
             * @return {?}
             */
            function () {
                return this.selected && this.ripple.isAttached() ? 'mdc-list-item--selected' : '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcListItem.prototype.onclick = /**
         * @return {?}
         */
        function () {
            this.setSelected(!this.selected);
            this._emitChangeEvent();
        };
        Object.defineProperty(MdcListItem.prototype, "selected", {
            /** Whether the option is selected. */
            get: /**
             * Whether the option is selected.
             * @return {?}
             */
            function () { return this._selected; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setSelected(value);
            },
            enumerable: true,
            configurable: true
        });
        /** Sets the selected state of the option. */
        /**
         * Sets the selected state of the option.
         * @param {?} selected
         * @return {?}
         */
        MdcListItem.prototype.setSelected = /**
         * Sets the selected state of the option.
         * @param {?} selected
         * @return {?}
         */
        function (selected) {
            this._selected = selected;
            this._changeDetector.markForCheck();
        };
        /**
         * @return {?}
         */
        MdcListItem.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.ripple.destroy();
        };
        /**
         * @param {?} interactive
         * @return {?}
         */
        MdcListItem.prototype.setInteractive = /**
         * @param {?} interactive
         * @return {?}
         */
        function (interactive) {
            interactive ? this.ripple.attachTo(this.getListItemElement()) : this.ripple.destroy();
        };
        /**
         * @return {?}
         */
        MdcListItem.prototype.getListItemElement = /**
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        /**
         * Emits a change event if the selected state of an option changed.
         * @return {?}
         */
        MdcListItem.prototype._emitChangeEvent = /**
         * Emits a change event if the selected state of an option changed.
         * @return {?}
         */
        function () {
            this.selectionChange.emit(new MdcListSelectionChange(this));
        };
        MdcListItem.decorators = [
            { type: core.Component, args: [{selector: 'mdc-list-item, a[mdc-list-item]',
                        exportAs: 'mdcListItem',
                        host: {
                            '[id]': 'id',
                        },
                        template: '<ng-content></ng-content>',
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [
                            EventRegistry,
                            MdcRipple
                        ]
                    },] },
        ];
        /** @nocollapse */
        MdcListItem.ctorParameters = function () { return [
            { type: MdcRipple },
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef }
        ]; };
        MdcListItem.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-list-item',] }],
            tabIndex: [{ type: core.HostBinding, args: ['tabindex',] }],
            role: [{ type: core.HostBinding, args: ['attr.role',] }],
            classSelected: [{ type: core.HostBinding, args: ['class.mdc-list-item--selected',] }],
            onclick: [{ type: core.HostListener, args: ['click',] }],
            selectionChange: [{ type: core.Output }],
            listItemStart: [{ type: core.ContentChild, args: [MdcListItemGraphic,] }],
            selected: [{ type: core.Input }]
        };
        return MdcListItem;
    }());

    function _classCallCheck$e(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$e(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$e(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$e(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$e(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$e(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$e(subClass, superClass);
    }

    function _getPrototypeOf$e(o) {
      _getPrototypeOf$e = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$e(o);
    }

    function _setPrototypeOf$e(o, p) {
      _setPrototypeOf$e = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$e(o, p);
    }

    function _assertThisInitialized$e(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$e(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$e(self);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @template A
     */
    var MDCFoundation$d =
    /*#__PURE__*/
    function () {
      _createClass$e(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$e(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$e(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var cssClasses$c = {
      LIST_ITEM_CLASS: 'mdc-list-item'
    };
    /** @enum {string} */

    var strings$b = {
      ARIA_ORIENTATION: 'aria-orientation',
      ARIA_ORIENTATION_VERTICAL: 'vertical',
      FOCUSABLE_CHILD_ELEMENTS: 'button:not(:disabled), a',
      ITEMS_SELECTOR: '.mdc-list-item'
    };

    var ELEMENTS_KEY_ALLOWED_IN = ['input', 'button', 'textarea', 'select'];

    var MDCListFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$e(MDCListFoundation, _MDCFoundation);

      _createClass$e(MDCListFoundation, null, [{
        key: "strings",
        get: function get() {
          return strings$b;
        }
      }, {
        key: "cssClasses",
        get: function get() {
          return cssClasses$c;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** {MDCListAdapter */
            {
              getListItemCount: function getListItemCount() {},
              getFocusedElementIndex: function getFocusedElementIndex() {},
              getListItemIndex: function getListItemIndex() {},
              focusItemAtIndex: function focusItemAtIndex() {},
              setTabIndexForListItemChildren: function setTabIndexForListItemChildren() {}
            }
          );
        }
      }]);

      function MDCListFoundation() {
        var _this;

        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] :
        /** @type {!MDCListFoundation} */
        {};

        _classCallCheck$e(this, MDCListFoundation);

        _this = _possibleConstructorReturn$e(this, _getPrototypeOf$e(MDCListFoundation).call(this, Object.assign(MDCListFoundation.defaultAdapter, adapter)));
        /** {boolean} */

        _this.wrapFocus_ = false;
        /** {boolean} */

        _this.isVertical_ = true;
        return _this;
      }
      /**
       * Sets the private wrapFocus_ variable.
       * @param {boolean} value
       */


      _createClass$e(MDCListFoundation, [{
        key: "setWrapFocus",
        value: function setWrapFocus(value) {
          this.wrapFocus_ = value;
        }
        /**
         * Sets the isVertical_ private variable.
         * @param {boolean} value
         */

      }, {
        key: "setVerticalOrientation",
        value: function setVerticalOrientation(value) {
          this.isVertical_ = value;
        }
        /**
         * Focus in handler for the list items.
         * @param evt
         */

      }, {
        key: "handleFocusIn",
        value: function handleFocusIn(evt) {
          var listItem = this.getListItem_(evt.target);
          if (!listItem) return;
          this.adapter_.setTabIndexForListItemChildren(this.adapter_.getListItemIndex(listItem), 0);
        }
        /**
         * Focus out handler for the list items.
         * @param {Event} evt
         */

      }, {
        key: "handleFocusOut",
        value: function handleFocusOut(evt) {
          var listItem = this.getListItem_(evt.target);
          if (!listItem) return;
          this.adapter_.setTabIndexForListItemChildren(this.adapter_.getListItemIndex(listItem), -1);
        }
        /**
         * Key handler for the list.
         * @param {Event} evt
         */

      }, {
        key: "handleKeydown",
        value: function handleKeydown(evt) {
          var arrowLeft = evt.key === 'ArrowLeft' || evt.keyCode === 37;
          var arrowUp = evt.key === 'ArrowUp' || evt.keyCode === 38;
          var arrowRight = evt.key === 'ArrowRight' || evt.keyCode === 39;
          var arrowDown = evt.key === 'ArrowDown' || evt.keyCode === 40;
          var isHome = evt.key === 'Home' || evt.keyCode === 36;
          var isEnd = evt.key === 'End' || evt.keyCode === 35;
          var currentIndex = this.adapter_.getFocusedElementIndex();

          if (currentIndex === -1) {
            currentIndex = this.adapter_.getListItemIndex(this.getListItem_(evt.target));

            if (currentIndex < 0) {
              // If this event doesn't have a mdc-list-item ancestor from the
              // current list (not from a sublist), return early.
              return;
            }
          }

          if (this.isVertical_ && arrowDown || !this.isVertical_ && arrowRight) {
            this.preventDefaultEvent_(evt);
            this.focusNextElement(currentIndex);
          } else if (this.isVertical_ && arrowUp || !this.isVertical_ && arrowLeft) {
            this.preventDefaultEvent_(evt);
            this.focusPrevElement(currentIndex);
          } else if (isHome) {
            this.preventDefaultEvent_(evt);
            this.focusFirstElement();
          } else if (isEnd) {
            this.preventDefaultEvent_(evt);
            this.focusLastElement();
          }
        }
        /**
         * Ensures that preventDefault is only called if the containing element doesn't
         * consume the event, and it will cause an unintended scroll.
         * @param {Event} evt
         * @private
         */

      }, {
        key: "preventDefaultEvent_",
        value: function preventDefaultEvent_(evt) {
          var tagName = "".concat(evt.target.tagName).toLowerCase();

          if (ELEMENTS_KEY_ALLOWED_IN.indexOf(tagName) === -1) {
            evt.preventDefault();
          }
        }
        /**
         * Focuses the next element on the list.
         * @param {Number} index
         */

      }, {
        key: "focusNextElement",
        value: function focusNextElement(index) {
          var count = this.adapter_.getListItemCount();
          var nextIndex = index + 1;

          if (nextIndex >= count) {
            if (this.wrapFocus_) {
              nextIndex = 0;
            } else {
              // Return early because last item is already focused.
              return;
            }
          }

          this.adapter_.focusItemAtIndex(nextIndex);
        }
        /**
         * Focuses the previous element on the list.
         * @param {Number} index
         */

      }, {
        key: "focusPrevElement",
        value: function focusPrevElement(index) {
          var prevIndex = index - 1;

          if (prevIndex < 0) {
            if (this.wrapFocus_) {
              prevIndex = this.adapter_.getListItemCount() - 1;
            } else {
              // Return early because first item is already focused.
              return;
            }
          }

          this.adapter_.focusItemAtIndex(prevIndex);
        }
      }, {
        key: "focusFirstElement",
        value: function focusFirstElement() {
          if (this.adapter_.getListItemCount() > 0) {
            this.adapter_.focusItemAtIndex(0);
          }
        }
      }, {
        key: "focusLastElement",
        value: function focusLastElement() {
          var lastIndex = this.adapter_.getListItemCount() - 1;

          if (lastIndex >= 0) {
            this.adapter_.focusItemAtIndex(lastIndex);
          }
        }
        /**
         * Utility method to find the first ancestor with the mdc-list-item class.
         * @param {EventTarget} target
         * @return {?Element}
         * @private
         */

      }, {
        key: "getListItem_",
        value: function getListItem_(target) {
          while (!target.classList.contains(cssClasses$c.LIST_ITEM_CLASS)) {
            if (!target.parentElement) return null;
            target = target.parentElement;
          }

          return target;
        }
      }]);

      return MDCListFoundation;
    }(MDCFoundation$d);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Change event that is being fired whenever the selected state of an option changes.
     */
    var   /**
     * Change event that is being fired whenever the selected state of an option changes.
     */
    MdcListItemChange = /** @class */ (function () {
        function MdcListItemChange(source, option) {
            this.source = source;
            this.option = option;
        }
        return MdcListItemChange;
    }());
    var MdcListGroup = /** @class */ (function () {
        function MdcListGroup(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcListGroup.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcListGroup], mdc-list-group',
                        exportAs: 'mdcListGroup',
                    },] },
        ];
        /** @nocollapse */
        MdcListGroup.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcListGroup.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-list-group',] }]
        };
        return MdcListGroup;
    }());
    var MdcListGroupSubheader = /** @class */ (function () {
        function MdcListGroupSubheader(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcListGroupSubheader.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcListGroupSubheader], mdc-list-group-subheader',
                        exportAs: 'mdcListGroupSubheader',
                    },] },
        ];
        /** @nocollapse */
        MdcListGroupSubheader.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcListGroupSubheader.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-list-group__subheader',] }]
        };
        return MdcListGroupSubheader;
    }());
    var MdcListDivider = /** @class */ (function () {
        function MdcListDivider() {
            this._inset = false;
            this._padded = false;
        }
        Object.defineProperty(MdcListDivider.prototype, "inset", {
            get: /**
             * @return {?}
             */
            function () { return this._inset; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._inset = toBoolean(value);
                this._inset ? this._divider.nativeElement.classList.add('mdc-list-divider--inset')
                    : this._divider.nativeElement.classList.remove('mdc-list-divider--inset');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcListDivider.prototype, "padded", {
            get: /**
             * @return {?}
             */
            function () { return this._padded; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._padded = toBoolean(value);
                this._padded ? this._divider.nativeElement.classList.add('mdc-list-divider--padded')
                    : this._divider.nativeElement.classList.remove('mdc-list-divider--padded');
            },
            enumerable: true,
            configurable: true
        });
        MdcListDivider.decorators = [
            { type: core.Component, args: [{selector: '[mdcListDivider], mdc-list-divider',
                        exportAs: 'mdcListDivider',
                        template: '<div #divider class="mdc-list-divider" role="seperator"></div>',
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        MdcListDivider.propDecorators = {
            inset: [{ type: core.Input }],
            padded: [{ type: core.Input }],
            _divider: [{ type: core.ViewChild, args: ['divider',] }]
        };
        return MdcListDivider;
    }());
    var MdcList = /** @class */ (function () {
        function MdcList(_changeDetectorRef, _ngZone, elementRef) {
            var _this = this;
            this._changeDetectorRef = _changeDetectorRef;
            this._ngZone = _ngZone;
            this.elementRef = elementRef;
            /**
             * Emits whenever the component is destroyed.
             */
            this._destroy = new rxjs.Subject();
            this.dense = false;
            this.lines = 1;
            this.border = false;
            this._interactive = true;
            this.isHostClass = true;
            this.role = 'list';
            this.ariaOrientation = 'vertical';
            /**
             * Emits a change event whenever the selected state of an option changes.
             */
            this.selectionChange = new core.EventEmitter();
            this._mdcAdapter = {
                getListItemCount: function () { return _this._listItems.length; },
                getFocusedElementIndex: function () { return _this._listItems.toArray().findIndex(function (_) { return _.getListItemElement() === document.activeElement; }); },
                getListItemIndex: function (node) { return _this._listItems.toArray().findIndex(function (_) { return _.getListItemElement() === node; }); },
                focusItemAtIndex: function (ndx) { return _this._listItems.toArray()[ndx].getListItemElement().focus(); },
                setTabIndexForListItemChildren: function (listItemIndex, tabIndexValue) {
                    var /** @type {?} */ listItemChildren = [].slice.call(_this._listItems.toArray()[listItemIndex].getListItemElement()
                        .querySelectorAll('button:not(:disabled), a'));
                    listItemChildren.forEach(function (ele) { return ele.setAttribute('tabindex', tabIndexValue); });
                }
            };
            this._foundation = new MDCListFoundation(this._mdcAdapter);
            /**
             * Combined stream of all of the child options' change events.
             */
            this.optionSelectionChanges = rxjs.defer(function () {
                if (_this._listItems) {
                    return rxjs.merge.apply(void 0, _this._listItems.map(function (option) { return option.selectionChange; }));
                }
                return _this._ngZone.onStable
                    .asObservable()
                    .pipe(operators.take(1), operators.switchMap(function () { return _this.optionSelectionChanges; }));
            });
        }
        Object.defineProperty(MdcList.prototype, "avatar", {
            get: /**
             * @return {?}
             */
            function () { return this._avatar; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._avatar = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcList.prototype, "interactive", {
            get: /**
             * @return {?}
             */
            function () { return this._interactive; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._interactive) {
                    this.setInteractive(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcList.prototype, "multiple", {
            get: /**
             * @return {?}
             */
            function () { return this._multiple; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setMultiple(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcList.prototype, "classDense", {
            get: /**
             * @return {?}
             */
            function () {
                return this.dense ? 'mdc-list--dense' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcList.prototype, "classLines", {
            get: /**
             * @return {?}
             */
            function () {
                return this.lines === 2 ? 'mdc-list--two-line' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcList.prototype, "classAvatar", {
            get: /**
             * @return {?}
             */
            function () {
                return this.avatar ? 'mdc-list--avatar-list' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcList.prototype, "classBorder", {
            get: /**
             * @return {?}
             */
            function () {
                return this.border ? 'ng-mdc-list--border' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcList.prototype, "classInteractive", {
            get: /**
             * @return {?}
             */
            function () {
                return !this.interactive ? 'mdc-list--non-interactive' : '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcList.prototype.onkeydown = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            this._foundation.handleKeydown(evt);
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcList.prototype.onfocusin = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            this._foundation.handleFocusIn(evt);
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcList.prototype.onfocusout = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            this._foundation.handleFocusOut(evt);
        };
        /**
         * @return {?}
         */
        MdcList.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this._foundation.init();
            this._foundation.setVerticalOrientation(true);
            this.optionSelectionChanges.pipe(operators.takeUntil(rxjs.merge(this._destroy, this._listItems.changes))).subscribe(function (event) {
                _this.selectionChange.emit(new MdcListItemChange(_this, event.source));
            });
            this._listItems.changes.pipe(operators.startWith(null), operators.takeUntil(this._destroy)).subscribe(function () {
                Promise.resolve().then(function () {
                    _this.setInteractive(_this.interactive);
                    if (!_this.multiple) {
                        _this._resetOptions();
                    }
                });
            });
        };
        /**
         * @return {?}
         */
        MdcList.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroy.next();
            this._destroy.complete();
        };
        /**
         * Drops current option subscriptions and IDs and resets from scratch.
         * @return {?}
         */
        MdcList.prototype._resetOptions = /**
         * Drops current option subscriptions and IDs and resets from scratch.
         * @return {?}
         */
        function () {
            var _this = this;
            var /** @type {?} */ changedOrDestroyed = rxjs.merge(this._listItems.changes, this._destroy);
            this.optionSelectionChanges
                .pipe(operators.takeUntil(changedOrDestroyed)).subscribe(function (event) {
                if (!_this.multiple) {
                    _this.clearSelected(event.source);
                }
            });
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MdcList.prototype.setInteractive = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._interactive = toBoolean(value);
            if (!this._listItems) {
                return;
            }
            this._listItems.forEach(function (option) {
                option.setInteractive(value);
            });
        };
        /**
         * @param {?} multiple
         * @return {?}
         */
        MdcList.prototype.setMultiple = /**
         * @param {?} multiple
         * @return {?}
         */
        function (multiple) {
            this._multiple = multiple;
            this.clearSelected();
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?=} skip
         * @return {?}
         */
        MdcList.prototype.clearSelected = /**
         * @param {?=} skip
         * @return {?}
         */
        function (skip) {
            if (!this._listItems) {
                return;
            }
            this._listItems.forEach(function (option) {
                if (option !== skip) {
                    option.setSelected(false);
                }
            });
        };
        MdcList.decorators = [
            { type: core.Component, args: [{selector: 'mdc-list',
                        exportAs: 'mdcList',
                        template: '<ng-content></ng-content>',
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcList.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.NgZone },
            { type: core.ElementRef }
        ]; };
        MdcList.propDecorators = {
            dense: [{ type: core.Input }],
            lines: [{ type: core.Input }],
            border: [{ type: core.Input }],
            avatar: [{ type: core.Input }],
            interactive: [{ type: core.Input }],
            multiple: [{ type: core.Input }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-list',] }],
            role: [{ type: core.HostBinding, args: ['attr.role',] }],
            ariaOrientation: [{ type: core.HostBinding, args: ['attr.aria-orientation',] }],
            classDense: [{ type: core.HostBinding, args: ['class.mdc-list--dense',] }],
            classLines: [{ type: core.HostBinding, args: ['class.mdc-list--two-line',] }],
            classAvatar: [{ type: core.HostBinding, args: ['class.mdc-list--avatar-list',] }],
            classBorder: [{ type: core.HostBinding, args: ['class.ng-mdc-list--border',] }],
            classInteractive: [{ type: core.HostBinding, args: ['class.mdc-list--non-interactive',] }],
            onkeydown: [{ type: core.HostListener, args: ['keydown', ['$event'],] }],
            onfocusin: [{ type: core.HostListener, args: ['focusin', ['$event'],] }],
            onfocusout: [{ type: core.HostListener, args: ['focusout', ['$event'],] }],
            _listItems: [{ type: core.ContentChildren, args: [MdcListItem, { descendants: true },] }],
            selectionChange: [{ type: core.Output }]
        };
        return MdcList;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ LIST_DECLARATIONS = [
        MdcList,
        MdcListDivider,
        MdcListGroup,
        MdcListGroupSubheader,
        MdcListItem,
        MdcListItemGraphic,
        MdcListItemMeta,
        MdcListItemSecondary,
        MdcListItemText,
    ];
    var MdcListModule = /** @class */ (function () {
        function MdcListModule() {
        }
        MdcListModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: LIST_DECLARATIONS,
                        declarations: LIST_DECLARATIONS,
                    },] },
        ];
        return MdcListModule;
    }());

    /**
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @type {string|undefined} */
    var storedTransformPropertyName_$1;
    /**
     * Returns the name of the correct transform property to use on the current browser.
     * @param {!Window} globalObj
     * @param {boolean=} forceRefresh
     * @return {string}
     */

    function getTransformPropertyName$1(globalObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (storedTransformPropertyName_$1 === undefined || forceRefresh) {
        var el = globalObj.document.createElement('div');
        var transformPropertyName = 'transform' in el.style ? 'transform' : 'webkitTransform';
        storedTransformPropertyName_$1 = transformPropertyName;
      }

      return storedTransformPropertyName_$1;
    }

    function _classCallCheck$f(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$f(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$f(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$f(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$f(Constructor, staticProps);
      return Constructor;
    }

    function _defineProperty$1(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    function _inherits$f(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$f(subClass, superClass);
    }

    function _getPrototypeOf$f(o) {
      _getPrototypeOf$f = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$f(o);
    }

    function _setPrototypeOf$f(o, p) {
      _setPrototypeOf$f = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$f(o, p);
    }

    function _assertThisInitialized$f(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$f(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$f(self);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @template A
     */
    var MDCFoundation$e =
    /*#__PURE__*/
    function () {
      _createClass$f(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$f(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$f(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$d =
    /*#__PURE__*/
    function () {
      _createClass$f(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$e());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$f(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$f(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Menu. Provides an interface for managing
     * - classes
     * - dom
     * - focus
     * - position
     * - dimensions
     * - event handlers
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCMenuAdapter =
    /*#__PURE__*/
    function () {
      function MDCMenuAdapter() {
        _classCallCheck$f(this, MDCMenuAdapter);
      }

      _createClass$f(MDCMenuAdapter, [{
        key: "addClass",

        /** @param {string} className */
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * @param {string} className
         * @return {boolean}
         */

      }, {
        key: "hasClass",
        value: function hasClass(className) {}
        /** @return {boolean} */

      }, {
        key: "hasNecessaryDom",
        value: function hasNecessaryDom() {}
        /**
         * @param {EventTarget} target
         * @param {string} attributeName
         * @return {string}
         */

      }, {
        key: "getAttributeForEventTarget",
        value: function getAttributeForEventTarget(target, attributeName) {}
        /** @return {{ width: number, height: number }} */

      }, {
        key: "getInnerDimensions",
        value: function getInnerDimensions() {}
        /** @return {boolean} */

      }, {
        key: "hasAnchor",
        value: function hasAnchor() {}
        /** @return {{width: number, height: number, top: number, right: number, bottom: number, left: number}} */

      }, {
        key: "getAnchorDimensions",
        value: function getAnchorDimensions() {}
        /** @return {{ width: number, height: number }} */

      }, {
        key: "getWindowDimensions",
        value: function getWindowDimensions() {}
        /** @return {number} */

      }, {
        key: "getNumberOfItems",
        value: function getNumberOfItems() {}
        /**
         * @param {string} type
         * @param {function(!Event)} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(type, handler) {}
        /**
         * @param {string} type
         * @param {function(!Event)} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(type, handler) {}
        /** @param {function(!Event)} handler */

      }, {
        key: "registerBodyClickHandler",
        value: function registerBodyClickHandler(handler) {}
        /** @param {function(!Event)} handler */

      }, {
        key: "deregisterBodyClickHandler",
        value: function deregisterBodyClickHandler(handler) {}
        /**
         * @param {EventTarget} target
         * @return {number}
         */

      }, {
        key: "getIndexForEventTarget",
        value: function getIndexForEventTarget(target) {}
        /** @param {{index: number}} evtData */

      }, {
        key: "notifySelected",
        value: function notifySelected(evtData) {}
      }, {
        key: "notifyCancel",
        value: function notifyCancel() {}
      }, {
        key: "saveFocus",
        value: function saveFocus() {}
      }, {
        key: "restoreFocus",
        value: function restoreFocus() {}
        /** @return {boolean} */

      }, {
        key: "isFocused",
        value: function isFocused() {}
      }, {
        key: "focus",
        value: function focus() {}
        /** @return {number} */

      }, {
        key: "getFocusedItemIndex",
        value: function getFocusedItemIndex()
        /* number */
        {}
        /** @param {number} index */

      }, {
        key: "focusItemAtIndex",
        value: function focusItemAtIndex(index) {}
        /** @return {boolean} */

      }, {
        key: "isRtl",
        value: function isRtl() {}
        /** @param {string} origin */

      }, {
        key: "setTransformOrigin",
        value: function setTransformOrigin(origin) {}
        /** @param {{
        *   top: (string|undefined),
        *   right: (string|undefined),
        *   bottom: (string|undefined),
        *   left: (string|undefined)
        * }} position */

      }, {
        key: "setPosition",
        value: function setPosition(position) {}
        /** @param {string} height */

      }, {
        key: "setMaxHeight",
        value: function setMaxHeight(height) {}
        /**
         * @param {number} index
         * @param {string} attr
         * @param {string} value
         */

      }, {
        key: "setAttrForOptionAtIndex",
        value: function setAttrForOptionAtIndex(index, attr, value) {}
        /**
         * @param {number} index
         * @param {string} attr
         */

      }, {
        key: "rmAttrForOptionAtIndex",
        value: function rmAttrForOptionAtIndex(index, attr) {}
        /**
         * @param {number} index
         * @param {string} className
         */

      }, {
        key: "addClassForOptionAtIndex",
        value: function addClassForOptionAtIndex(index, className) {}
        /**
         * @param {number} index
         * @param {string} className
         */

      }, {
        key: "rmClassForOptionAtIndex",
        value: function rmClassForOptionAtIndex(index, className) {}
      }]);

      return MDCMenuAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var cssClasses$d = {
      ROOT: 'mdc-menu',
      OPEN: 'mdc-menu--open',
      ANIMATING_OPEN: 'mdc-menu--animating-open',
      ANIMATING_CLOSED: 'mdc-menu--animating-closed',
      SELECTED_LIST_ITEM: 'mdc-list-item--selected'
    };
    /** @enum {string} */

    var strings$c = {
      ITEMS_SELECTOR: '.mdc-menu__items',
      SELECTED_EVENT: 'MDCMenu:selected',
      CANCEL_EVENT: 'MDCMenu:cancel',
      ARIA_DISABLED_ATTR: 'aria-disabled'
    };
    /** @enum {number} */

    var numbers$8 = {
      // Amount of time to wait before triggering a selected event on the menu. Note that this time
      // will most likely be bumped up once interactive lists are supported to allow for the ripple to
      // animate before closing the menu
      SELECTED_TRIGGER_DELAY: 50,
      // Total duration of menu open animation.
      TRANSITION_OPEN_DURATION: 120,
      // Total duration of menu close animation.
      TRANSITION_CLOSE_DURATION: 75,
      // Margin left to the edge of the viewport when menu is at maximum possible height.
      MARGIN_TO_EDGE: 32,
      // Ratio of anchor width to menu width for switching from corner positioning to center positioning.
      ANCHOR_TO_MENU_WIDTH_RATIO: 0.67,
      // Ratio of vertical offset to menu height for switching from corner to mid-way origin positioning.
      OFFSET_TO_MENU_HEIGHT_RATIO: 0.1
    };
    /**
     * Enum for bits in the {@see Corner) bitmap.
     * @enum {number}
     */

    var CornerBit = {
      BOTTOM: 1,
      CENTER: 2,
      RIGHT: 4,
      FLIP_RTL: 8
    };
    /**
     * Enum for representing an element corner for positioning the menu.
     *
     * The START constants map to LEFT if element directionality is left
     * to right and RIGHT if the directionality is right to left.
     * Likewise END maps to RIGHT or LEFT depending on the directionality.
     *
     * @enum {number}
     */

    var Corner = {
      TOP_LEFT: 0,
      TOP_RIGHT: CornerBit.RIGHT,
      BOTTOM_LEFT: CornerBit.BOTTOM,
      BOTTOM_RIGHT: CornerBit.BOTTOM | CornerBit.RIGHT,
      TOP_START: CornerBit.FLIP_RTL,
      TOP_END: CornerBit.FLIP_RTL | CornerBit.RIGHT,
      BOTTOM_START: CornerBit.BOTTOM | CornerBit.FLIP_RTL,
      BOTTOM_END: CornerBit.BOTTOM | CornerBit.RIGHT | CornerBit.FLIP_RTL
    };

    /**
     * @extends {MDCFoundation<!MDCMenuAdapter>}
     */

    var MDCMenuFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$f(MDCMenuFoundation, _MDCFoundation);

      _createClass$f(MDCMenuFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          return cssClasses$d;
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          return strings$c;
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          return numbers$8;
        }
        /** @return enum{number} */

      }, {
        key: "Corner",
        get: function get() {
          return Corner;
        }
        /**
         * {@see MDCMenuAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCMenuAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCMenuAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              hasClass: function hasClass() {
                return false;
              },
              hasNecessaryDom: function hasNecessaryDom() {
                return false;
              },
              getAttributeForEventTarget: function getAttributeForEventTarget() {},
              getInnerDimensions: function getInnerDimensions() {
                return {};
              },
              hasAnchor: function hasAnchor() {
                return false;
              },
              getAnchorDimensions: function getAnchorDimensions() {
                return {};
              },
              getWindowDimensions: function getWindowDimensions() {
                return {};
              },
              getNumberOfItems: function getNumberOfItems() {
                return 0;
              },
              registerInteractionHandler: function registerInteractionHandler() {},
              deregisterInteractionHandler: function deregisterInteractionHandler() {},
              registerBodyClickHandler: function registerBodyClickHandler() {},
              deregisterBodyClickHandler: function deregisterBodyClickHandler() {},
              getIndexForEventTarget: function getIndexForEventTarget() {
                return 0;
              },
              notifySelected: function notifySelected() {},
              notifyCancel: function notifyCancel() {},
              saveFocus: function saveFocus() {},
              restoreFocus: function restoreFocus() {},
              isFocused: function isFocused() {
                return false;
              },
              focus: function focus() {},
              getFocusedItemIndex: function getFocusedItemIndex() {
                return -1;
              },
              focusItemAtIndex: function focusItemAtIndex() {},
              isRtl: function isRtl() {
                return false;
              },
              setTransformOrigin: function setTransformOrigin() {},
              setPosition: function setPosition() {},
              setMaxHeight: function setMaxHeight() {},
              setAttrForOptionAtIndex: function setAttrForOptionAtIndex() {},
              rmAttrForOptionAtIndex: function rmAttrForOptionAtIndex() {},
              addClassForOptionAtIndex: function addClassForOptionAtIndex() {},
              rmClassForOptionAtIndex: function rmClassForOptionAtIndex() {}
            }
          );
        }
        /** @param {!MDCMenuAdapter} adapter */

      }]);

      function MDCMenuFoundation(adapter) {
        var _this;

        _classCallCheck$f(this, MDCMenuFoundation);

        _this = _possibleConstructorReturn$f(this, _getPrototypeOf$f(MDCMenuFoundation).call(this, Object.assign(MDCMenuFoundation.defaultAdapter, adapter)));
        /** @private {function(!Event)} */

        _this.clickHandler_ = function (evt) {
          return _this.handlePossibleSelected_(evt);
        };
        /** @private {function(!Event)} */


        _this.keydownHandler_ = function (evt) {
          return _this.handleKeyboardDown_(evt);
        };
        /** @private {function(!Event)} */


        _this.keyupHandler_ = function (evt) {
          return _this.handleKeyboardUp_(evt);
        };
        /** @private {function(!Event)} */


        _this.documentClickHandler_ = function (evt) {
          return _this.handleDocumentClick_(evt);
        };
        /** @private {boolean} */


        _this.isOpen_ = false;
        /** @private {number} */

        _this.openAnimationEndTimerId_ = 0;
        /** @private {number} */

        _this.closeAnimationEndTimerId_ = 0;
        /** @private {number} */

        _this.selectedTriggerTimerId_ = 0;
        /** @private {number} */

        _this.animationRequestId_ = 0;
        /** @private {!{ width: number, height: number }} */

        _this.dimensions_;
        /** @private {number} */

        _this.itemHeight_;
        /** @private {Corner} */

        _this.anchorCorner_ = Corner.TOP_START;
        /** @private {AnchorMargin} */

        _this.anchorMargin_ = {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        };
        /** @private {?AutoLayoutMeasurements} */

        _this.measures_ = null;
        /** @private {number} */

        _this.selectedIndex_ = -1;
        /** @private {boolean} */

        _this.rememberSelection_ = false;
        /** @private {boolean} */

        _this.quickOpen_ = false; // A keyup event on the menu needs to have a corresponding keydown
        // event on the menu. If the user opens the menu with a keydown event on a
        // button, the menu will only get the key up event causing buggy behavior with selected elements.

        /** @private {boolean} */

        _this.keyDownWithinMenu_ = false;
        return _this;
      }

      _createClass$f(MDCMenuFoundation, [{
        key: "init",
        value: function init() {
          var _MDCMenuFoundation$cs = MDCMenuFoundation.cssClasses,
              ROOT = _MDCMenuFoundation$cs.ROOT,
              OPEN = _MDCMenuFoundation$cs.OPEN;

          if (!this.adapter_.hasClass(ROOT)) {
            throw new Error("".concat(ROOT, " class required in root element."));
          }

          if (!this.adapter_.hasNecessaryDom()) {
            throw new Error("Required DOM nodes missing in ".concat(ROOT, " component."));
          }

          if (this.adapter_.hasClass(OPEN)) {
            this.isOpen_ = true;
          }

          this.adapter_.registerInteractionHandler('click', this.clickHandler_);
          this.adapter_.registerInteractionHandler('keyup', this.keyupHandler_);
          this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          clearTimeout(this.selectedTriggerTimerId_);
          clearTimeout(this.openAnimationEndTimerId_);
          clearTimeout(this.closeAnimationEndTimerId_); // Cancel any currently running animations.

          cancelAnimationFrame(this.animationRequestId_);
          this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
          this.adapter_.deregisterInteractionHandler('keyup', this.keyupHandler_);
          this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
          this.adapter_.deregisterBodyClickHandler(this.documentClickHandler_);
        }
        /**
         * @param {!Corner} corner Default anchor corner alignment of top-left menu corner.
         */

      }, {
        key: "setAnchorCorner",
        value: function setAnchorCorner(corner) {
          this.anchorCorner_ = corner;
        }
        /**
         * @param {!AnchorMargin} margin 4-plet of margins from anchor.
         */

      }, {
        key: "setAnchorMargin",
        value: function setAnchorMargin(margin) {
          this.anchorMargin_.top = typeof margin.top === 'number' ? margin.top : 0;
          this.anchorMargin_.right = typeof margin.right === 'number' ? margin.right : 0;
          this.anchorMargin_.bottom = typeof margin.bottom === 'number' ? margin.bottom : 0;
          this.anchorMargin_.left = typeof margin.left === 'number' ? margin.left : 0;
        }
        /** @param {boolean} rememberSelection */

      }, {
        key: "setRememberSelection",
        value: function setRememberSelection(rememberSelection) {
          this.rememberSelection_ = rememberSelection;
          this.setSelectedIndex(-1);
        }
        /** @param {boolean} quickOpen */

      }, {
        key: "setQuickOpen",
        value: function setQuickOpen(quickOpen) {
          this.quickOpen_ = quickOpen;
        }
        /**
         * @param {?number} focusIndex
         * @private
         */

      }, {
        key: "focusOnOpen_",
        value: function focusOnOpen_(focusIndex) {
          if (focusIndex === null) {
            // If this instance of MDCMenu remembers selections, and the user has
            // made a selection, then focus the last selected item
            if (this.rememberSelection_ && this.selectedIndex_ >= 0) {
              this.adapter_.focusItemAtIndex(this.selectedIndex_);
              return;
            }

            this.adapter_.focus(); // If that doesn't work, focus first item instead.

            if (!this.adapter_.isFocused()) {
              this.adapter_.focusItemAtIndex(0);
            }
          } else {
            this.adapter_.focusItemAtIndex(focusIndex);
          }
        }
        /**
         * Handle clicks and cancel the menu if not a child list-item
         * @param {!Event} evt
         * @private
         */

      }, {
        key: "handleDocumentClick_",
        value: function handleDocumentClick_(evt) {
          var el = evt.target;

          while (el && el !== document.documentElement) {
            if (this.adapter_.getIndexForEventTarget(el) !== -1) {
              return;
            }

            el = el.parentNode;
          }

          this.adapter_.notifyCancel();
          this.close(evt);
        }
      }, {
        key: "handleKeyboardDown_",

        /**
         * Handle keys that we want to repeat on hold (tab and arrows).
         * @param {!Event} evt
         * @return {boolean}
         * @private
         */
        value: function handleKeyboardDown_(evt) {
          // Do nothing if Alt, Ctrl or Meta are pressed.
          if (evt.altKey || evt.ctrlKey || evt.metaKey) {
            return true;
          }

          var keyCode = evt.keyCode,
              key = evt.key,
              shiftKey = evt.shiftKey;
          var isTab = key === 'Tab' || keyCode === 9;
          var isArrowUp = key === 'ArrowUp' || keyCode === 38;
          var isArrowDown = key === 'ArrowDown' || keyCode === 40;
          var isSpace = key === 'Space' || keyCode === 32;
          var isEnter = key === 'Enter' || keyCode === 13; // The menu needs to know if the keydown event was triggered on the menu

          this.keyDownWithinMenu_ = isEnter || isSpace;
          var focusedItemIndex = this.adapter_.getFocusedItemIndex();
          var lastItemIndex = this.adapter_.getNumberOfItems() - 1;

          if (shiftKey && isTab && focusedItemIndex === 0) {
            this.adapter_.focusItemAtIndex(lastItemIndex);
            evt.preventDefault();
            return false;
          }

          if (!shiftKey && isTab && focusedItemIndex === lastItemIndex) {
            this.adapter_.focusItemAtIndex(0);
            evt.preventDefault();
            return false;
          } // Ensure Arrow{Up,Down} and space do not cause inadvertent scrolling


          if (isArrowUp || isArrowDown || isSpace) {
            evt.preventDefault();
          }

          if (isArrowUp) {
            if (focusedItemIndex === 0 || this.adapter_.isFocused()) {
              this.adapter_.focusItemAtIndex(lastItemIndex);
            } else {
              this.adapter_.focusItemAtIndex(focusedItemIndex - 1);
            }
          } else if (isArrowDown) {
            if (focusedItemIndex === lastItemIndex || this.adapter_.isFocused()) {
              this.adapter_.focusItemAtIndex(0);
            } else {
              this.adapter_.focusItemAtIndex(focusedItemIndex + 1);
            }
          }

          return true;
        }
        /**
         * Handle keys that we don't want to repeat on hold (Enter, Space, Escape).
         * @param {!Event} evt
         * @return {boolean}
         * @private
         */

      }, {
        key: "handleKeyboardUp_",
        value: function handleKeyboardUp_(evt) {
          // Do nothing if Alt, Ctrl or Meta are pressed.
          if (evt.altKey || evt.ctrlKey || evt.metaKey) {
            return true;
          }

          var keyCode = evt.keyCode,
              key = evt.key;
          var isEnter = key === 'Enter' || keyCode === 13;
          var isSpace = key === 'Space' || keyCode === 32;
          var isEscape = key === 'Escape' || keyCode === 27;

          if (isEnter || isSpace) {
            // If the keydown event didn't occur on the menu, then it should
            // disregard the possible selected event.
            if (this.keyDownWithinMenu_) {
              this.handlePossibleSelected_(evt);
            }

            this.keyDownWithinMenu_ = false;
          }

          if (isEscape) {
            this.adapter_.notifyCancel();
            this.close();
          }

          return true;
        }
        /**
         * @param {!Event} evt
         * @private
         */

      }, {
        key: "handlePossibleSelected_",
        value: function handlePossibleSelected_(evt) {
          var _this2 = this;

          if (this.adapter_.getAttributeForEventTarget(evt.target, strings$c.ARIA_DISABLED_ATTR) === 'true') {
            return;
          }

          var targetIndex = this.adapter_.getIndexForEventTarget(evt.target);

          if (targetIndex < 0) {
            return;
          } // Debounce multiple selections


          if (this.selectedTriggerTimerId_) {
            return;
          }

          this.selectedTriggerTimerId_ = setTimeout(function () {
            _this2.selectedTriggerTimerId_ = 0;

            _this2.close();

            if (_this2.rememberSelection_) {
              _this2.setSelectedIndex(targetIndex);
            }

            _this2.adapter_.notifySelected({
              index: targetIndex
            });
          }, numbers$8.SELECTED_TRIGGER_DELAY);
        }
        /**
         * @return {AutoLayoutMeasurements} Measurements used to position menu popup.
         */

      }, {
        key: "getAutoLayoutMeasurements_",
        value: function getAutoLayoutMeasurements_() {
          var anchorRect = this.adapter_.getAnchorDimensions();
          var viewport = this.adapter_.getWindowDimensions();
          return {
            viewport: viewport,
            viewportDistance: {
              top: anchorRect.top,
              right: viewport.width - anchorRect.right,
              left: anchorRect.left,
              bottom: viewport.height - anchorRect.bottom
            },
            anchorHeight: anchorRect.height,
            anchorWidth: anchorRect.width,
            menuHeight: this.dimensions_.height,
            menuWidth: this.dimensions_.width
          };
        }
        /**
         * Computes the corner of the anchor from which to animate and position the menu.
         * @return {Corner}
         * @private
         */

      }, {
        key: "getOriginCorner_",
        value: function getOriginCorner_() {
          // Defaults: open from the top left.
          var corner = Corner.TOP_LEFT;
          var _this$measures_ = this.measures_,
              viewportDistance = _this$measures_.viewportDistance,
              anchorHeight = _this$measures_.anchorHeight,
              anchorWidth = _this$measures_.anchorWidth,
              menuHeight = _this$measures_.menuHeight,
              menuWidth = _this$measures_.menuWidth;
          var isBottomAligned = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);
          var availableTop = isBottomAligned ? viewportDistance.top + anchorHeight + this.anchorMargin_.bottom : viewportDistance.top + this.anchorMargin_.top;
          var availableBottom = isBottomAligned ? viewportDistance.bottom - this.anchorMargin_.bottom : viewportDistance.bottom + anchorHeight - this.anchorMargin_.top;
          var topOverflow = menuHeight - availableTop;
          var bottomOverflow = menuHeight - availableBottom;

          if (bottomOverflow > 0 && topOverflow < bottomOverflow) {
            corner |= CornerBit.BOTTOM;
          }

          var isRtl = this.adapter_.isRtl();
          var isFlipRtl = Boolean(this.anchorCorner_ & CornerBit.FLIP_RTL);
          var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);
          var isAlignedRight = avoidHorizontalOverlap && !isRtl || !avoidHorizontalOverlap && isFlipRtl && isRtl;
          var availableLeft = isAlignedRight ? viewportDistance.left + anchorWidth + this.anchorMargin_.right : viewportDistance.left + this.anchorMargin_.left;
          var availableRight = isAlignedRight ? viewportDistance.right - this.anchorMargin_.right : viewportDistance.right + anchorWidth - this.anchorMargin_.left;
          var leftOverflow = menuWidth - availableLeft;
          var rightOverflow = menuWidth - availableRight;

          if (leftOverflow < 0 && isAlignedRight && isRtl || avoidHorizontalOverlap && !isAlignedRight && leftOverflow < 0 || rightOverflow > 0 && leftOverflow < rightOverflow) {
            corner |= CornerBit.RIGHT;
          }

          return corner;
        }
        /**
         * @param {Corner} corner Origin corner of the menu.
         * @return {number} Horizontal offset of menu origin corner from corresponding anchor corner.
         * @private
         */

      }, {
        key: "getHorizontalOriginOffset_",
        value: function getHorizontalOriginOffset_(corner) {
          var anchorWidth = this.measures_.anchorWidth;
          var isRightAligned = Boolean(corner & CornerBit.RIGHT);
          var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);
          var x = 0;

          if (isRightAligned) {
            var rightOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.left : this.anchorMargin_.right;
            x = rightOffset;
          } else {
            var leftOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.right : this.anchorMargin_.left;
            x = leftOffset;
          }

          return x;
        }
        /**
         * @param {Corner} corner Origin corner of the menu.
         * @return {number} Vertical offset of menu origin corner from corresponding anchor corner.
         * @private
         */

      }, {
        key: "getVerticalOriginOffset_",
        value: function getVerticalOriginOffset_(corner) {
          var _this$measures_2 = this.measures_,
              viewport = _this$measures_2.viewport,
              viewportDistance = _this$measures_2.viewportDistance,
              anchorHeight = _this$measures_2.anchorHeight,
              menuHeight = _this$measures_2.menuHeight;
          var isBottomAligned = Boolean(corner & CornerBit.BOTTOM);
          var MARGIN_TO_EDGE = MDCMenuFoundation.numbers.MARGIN_TO_EDGE;
          var avoidVerticalOverlap = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);
          var canOverlapVertically = !avoidVerticalOverlap;
          var y = 0;

          if (isBottomAligned) {
            y = avoidVerticalOverlap ? anchorHeight - this.anchorMargin_.top : -this.anchorMargin_.bottom; // adjust for when menu can overlap anchor, but too tall to be aligned to bottom
            // anchor corner. Bottom margin is ignored in such cases.

            if (canOverlapVertically && menuHeight > viewportDistance.top + anchorHeight) {
              y = -(Math.min(menuHeight, viewport.height - MARGIN_TO_EDGE) - (viewportDistance.top + anchorHeight));
            }
          } else {
            y = avoidVerticalOverlap ? anchorHeight + this.anchorMargin_.bottom : this.anchorMargin_.top; // adjust for when menu can overlap anchor, but too tall to be aligned to top
            // anchor corners. Top margin is ignored in that case.

            if (canOverlapVertically && menuHeight > viewportDistance.bottom + anchorHeight) {
              y = -(Math.min(menuHeight, viewport.height - MARGIN_TO_EDGE) - (viewportDistance.bottom + anchorHeight));
            }
          }

          return y;
        }
        /**
         * @param {Corner} corner Origin corner of the menu.
         * @return {number} Maximum height of the menu, based on available space. 0 indicates should not be set.
         * @private
         */

      }, {
        key: "getMenuMaxHeight_",
        value: function getMenuMaxHeight_(corner) {
          var maxHeight = 0;
          var viewportDistance = this.measures_.viewportDistance;
          var isBottomAligned = Boolean(corner & CornerBit.BOTTOM); // When maximum height is not specified, it is handled from css.

          if (this.anchorCorner_ & CornerBit.BOTTOM) {
            if (isBottomAligned) {
              maxHeight = viewportDistance.top + this.anchorMargin_.top;
            } else {
              maxHeight = viewportDistance.bottom - this.anchorMargin_.bottom;
            }
          }

          return maxHeight;
        }
        /** @private */

      }, {
        key: "autoPosition_",
        value: function autoPosition_() {
          var _position;

          if (!this.adapter_.hasAnchor()) {
            return;
          } // Compute measurements for autoposition methods reuse.


          this.measures_ = this.getAutoLayoutMeasurements_();
          var corner = this.getOriginCorner_();
          var maxMenuHeight = this.getMenuMaxHeight_(corner);
          var verticalAlignment = corner & CornerBit.BOTTOM ? 'bottom' : 'top';
          var horizontalAlignment = corner & CornerBit.RIGHT ? 'right' : 'left';
          var horizontalOffset = this.getHorizontalOriginOffset_(corner);
          var verticalOffset = this.getVerticalOriginOffset_(corner);
          var position = (_position = {}, _defineProperty$1(_position, horizontalAlignment, horizontalOffset ? horizontalOffset + 'px' : '0'), _defineProperty$1(_position, verticalAlignment, verticalOffset ? verticalOffset + 'px' : '0'), _position);
          var _this$measures_3 = this.measures_,
              anchorWidth = _this$measures_3.anchorWidth,
              menuHeight = _this$measures_3.menuHeight,
              menuWidth = _this$measures_3.menuWidth; // Center align when anchor width is comparable or greater than menu, otherwise keep corner.

          if (anchorWidth / menuWidth > numbers$8.ANCHOR_TO_MENU_WIDTH_RATIO) {
            horizontalAlignment = 'center';
          } // Adjust vertical origin when menu is positioned with significant offset from anchor. This is done so that
          // scale animation is "anchored" on the anchor.


          if (!(this.anchorCorner_ & CornerBit.BOTTOM) && Math.abs(verticalOffset / menuHeight) > numbers$8.OFFSET_TO_MENU_HEIGHT_RATIO) {
            var verticalOffsetPercent = Math.abs(verticalOffset / menuHeight) * 100;
            var originPercent = corner & CornerBit.BOTTOM ? 100 - verticalOffsetPercent : verticalOffsetPercent;
            verticalAlignment = Math.round(originPercent * 100) / 100 + '%';
          }

          this.adapter_.setTransformOrigin("".concat(horizontalAlignment, " ").concat(verticalAlignment));
          this.adapter_.setPosition(position);
          this.adapter_.setMaxHeight(maxMenuHeight ? maxMenuHeight + 'px' : ''); // Clear measures after positioning is complete.

          this.measures_ = null;
        }
        /**
         * Open the menu.
         * @param {{focusIndex: ?number}=} options
         */

      }, {
        key: "open",
        value: function open() {
          var _this3 = this;

          var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              _ref$focusIndex = _ref.focusIndex,
              focusIndex = _ref$focusIndex === void 0 ? null : _ref$focusIndex;

          this.adapter_.saveFocus();

          if (!this.quickOpen_) {
            this.adapter_.addClass(MDCMenuFoundation.cssClasses.ANIMATING_OPEN);
          }

          this.animationRequestId_ = requestAnimationFrame(function () {
            _this3.dimensions_ = _this3.adapter_.getInnerDimensions();

            _this3.autoPosition_();

            _this3.adapter_.addClass(MDCMenuFoundation.cssClasses.OPEN);

            _this3.focusOnOpen_(focusIndex);

            _this3.adapter_.registerBodyClickHandler(_this3.documentClickHandler_);

            if (!_this3.quickOpen_) {
              _this3.openAnimationEndTimerId_ = setTimeout(function () {
                _this3.openAnimationEndTimerId_ = 0;

                _this3.adapter_.removeClass(MDCMenuFoundation.cssClasses.ANIMATING_OPEN);
              }, numbers$8.TRANSITION_OPEN_DURATION);
            }
          });
          this.isOpen_ = true;
        }
        /**
         * Closes the menu.
         * @param {Event=} evt
         */

      }, {
        key: "close",
        value: function close() {
          var _this4 = this;

          var evt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          var targetIsDisabled = evt ? this.adapter_.getAttributeForEventTarget(evt.target, strings$c.ARIA_DISABLED_ATTR) === 'true' : false;

          if (targetIsDisabled) {
            return;
          }

          this.adapter_.deregisterBodyClickHandler(this.documentClickHandler_);

          if (!this.quickOpen_) {
            this.adapter_.addClass(MDCMenuFoundation.cssClasses.ANIMATING_CLOSED);
          }

          requestAnimationFrame(function () {
            _this4.adapter_.removeClass(MDCMenuFoundation.cssClasses.OPEN);

            if (!_this4.quickOpen_) {
              _this4.closeAnimationEndTimerId_ = setTimeout(function () {
                _this4.closeAnimationEndTimerId_ = 0;

                _this4.adapter_.removeClass(MDCMenuFoundation.cssClasses.ANIMATING_CLOSED);
              }, numbers$8.TRANSITION_CLOSE_DURATION);
            }
          });
          this.isOpen_ = false;
          this.adapter_.restoreFocus();
        }
        /** @return {boolean} */

      }, {
        key: "isOpen",
        value: function isOpen() {
          return this.isOpen_;
        }
        /** @return {number} */

      }, {
        key: "getSelectedIndex",
        value: function getSelectedIndex() {
          return this.selectedIndex_;
        }
        /**
         * @param {number} index Index of the item to set as selected.
         */

      }, {
        key: "setSelectedIndex",
        value: function setSelectedIndex(index) {
          if (index === this.selectedIndex_) {
            return;
          }

          var prevSelectedIndex = this.selectedIndex_;

          if (prevSelectedIndex >= 0) {
            this.adapter_.rmAttrForOptionAtIndex(prevSelectedIndex, 'aria-selected');
            this.adapter_.rmClassForOptionAtIndex(prevSelectedIndex, cssClasses$d.SELECTED_LIST_ITEM);
          }

          this.selectedIndex_ = index >= 0 && index < this.adapter_.getNumberOfItems() ? index : -1;

          if (this.selectedIndex_ >= 0) {
            this.adapter_.setAttrForOptionAtIndex(this.selectedIndex_, 'aria-selected', 'true');
            this.adapter_.addClassForOptionAtIndex(this.selectedIndex_, cssClasses$d.SELECTED_LIST_ITEM);
          }
        }
      }]);

      return MDCMenuFoundation;
    }(MDCFoundation$e);

    /**
     * @extends MDCComponent<!MDCMenuFoundation>
     */

    var MDCMenu =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$f(MDCMenu, _MDCComponent);

      /** @param {...?} args */
      function MDCMenu() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$f(this, MDCMenu);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$f(this, (_getPrototypeOf2 = _getPrototypeOf$f(MDCMenu)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {!Element} */

        _this.previousFocus_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @return {!MDCMenu}
       */


      _createClass$f(MDCMenu, [{
        key: "show",

        /** @param {{focusIndex: ?number}=} options */
        value: function show() {
          var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              _ref$focusIndex = _ref.focusIndex,
              focusIndex = _ref$focusIndex === void 0 ? null : _ref$focusIndex;

          this.foundation_.open({
            focusIndex: focusIndex
          });
        }
      }, {
        key: "hide",
        value: function hide() {
          this.foundation_.close();
        }
        /**
         * @param {Corner} corner Default anchor corner alignment of top-left
         *     menu corner.
         */

      }, {
        key: "setAnchorCorner",
        value: function setAnchorCorner(corner) {
          this.foundation_.setAnchorCorner(corner);
        }
        /**
         * @param {AnchorMargin} margin
         */

      }, {
        key: "setAnchorMargin",
        value: function setAnchorMargin(margin) {
          this.foundation_.setAnchorMargin(margin);
        }
        /**
         * Return the item container element inside the component.
         * @return {?Element}
         */

      }, {
        key: "getOptionByIndex",

        /**
         * Return the item within the menu that is selected.
         * @param {number} index
         * @return {?Element}
         */
        value: function getOptionByIndex(index) {
          var items = this.items;

          if (index < items.length) {
            return this.items[index];
          } else {
            return null;
          }
        }
        /** @param {number} index */

      }, {
        key: "getDefaultFoundation",

        /** @return {!MDCMenuFoundation} */
        value: function getDefaultFoundation() {
          var _this2 = this;

          return new MDCMenuFoundation({
            addClass: function addClass(className) {
              return _this2.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this2.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
              return _this2.root_.classList.contains(className);
            },
            hasNecessaryDom: function hasNecessaryDom() {
              return Boolean(_this2.itemsContainer_);
            },
            getAttributeForEventTarget: function getAttributeForEventTarget(target, attributeName) {
              return target.getAttribute(attributeName);
            },
            getInnerDimensions: function getInnerDimensions() {
              var itemsContainer = _this2.itemsContainer_;
              return {
                width: itemsContainer.offsetWidth,
                height: itemsContainer.offsetHeight
              };
            },
            hasAnchor: function hasAnchor() {
              return _this2.root_.parentElement && _this2.root_.parentElement.classList.contains('mdc-menu-anchor');
            },
            getAnchorDimensions: function getAnchorDimensions() {
              return _this2.root_.parentElement.getBoundingClientRect();
            },
            getWindowDimensions: function getWindowDimensions() {
              return {
                width: window.innerWidth,
                height: window.innerHeight
              };
            },
            getNumberOfItems: function getNumberOfItems() {
              return _this2.items.length;
            },
            registerInteractionHandler: function registerInteractionHandler(type, handler) {
              return _this2.root_.addEventListener(type, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
              return _this2.root_.removeEventListener(type, handler);
            },
            registerBodyClickHandler: function registerBodyClickHandler(handler) {
              return document.body.addEventListener('click', handler);
            },
            deregisterBodyClickHandler: function deregisterBodyClickHandler(handler) {
              return document.body.removeEventListener('click', handler);
            },
            getIndexForEventTarget: function getIndexForEventTarget(target) {
              return _this2.items.indexOf(target);
            },
            notifySelected: function notifySelected(evtData) {
              return _this2.emit(MDCMenuFoundation.strings.SELECTED_EVENT, {
                index: evtData.index,
                item: _this2.items[evtData.index]
              });
            },
            notifyCancel: function notifyCancel() {
              return _this2.emit(MDCMenuFoundation.strings.CANCEL_EVENT, {});
            },
            saveFocus: function saveFocus() {
              _this2.previousFocus_ = document.activeElement;
            },
            restoreFocus: function restoreFocus() {
              if (_this2.previousFocus_ && _this2.previousFocus_.focus) {
                _this2.previousFocus_.focus();
              }
            },
            isFocused: function isFocused() {
              return document.activeElement === _this2.root_;
            },
            focus: function focus() {
              return _this2.root_.focus();
            },
            getFocusedItemIndex: function getFocusedItemIndex() {
              return _this2.items.indexOf(document.activeElement);
            },
            focusItemAtIndex: function focusItemAtIndex(index) {
              return _this2.items[index].focus();
            },
            isRtl: function isRtl() {
              return getComputedStyle(_this2.root_).getPropertyValue('direction') === 'rtl';
            },
            setTransformOrigin: function setTransformOrigin(origin) {
              _this2.root_.style["".concat(getTransformPropertyName$1(window), "-origin")] = origin;
            },
            setPosition: function setPosition(position) {
              _this2.root_.style.left = 'left' in position ? position.left : null;
              _this2.root_.style.right = 'right' in position ? position.right : null;
              _this2.root_.style.top = 'top' in position ? position.top : null;
              _this2.root_.style.bottom = 'bottom' in position ? position.bottom : null;
            },
            setMaxHeight: function setMaxHeight(height) {
              _this2.root_.style.maxHeight = height;
            },
            setAttrForOptionAtIndex: function setAttrForOptionAtIndex(index, attr, value) {
              return _this2.items[index].setAttribute(attr, value);
            },
            rmAttrForOptionAtIndex: function rmAttrForOptionAtIndex(index, attr) {
              return _this2.items[index].removeAttribute(attr);
            },
            addClassForOptionAtIndex: function addClassForOptionAtIndex(index, className) {
              return _this2.items[index].classList.add(className);
            },
            rmClassForOptionAtIndex: function rmClassForOptionAtIndex(index, className) {
              return _this2.items[index].classList.remove(className);
            }
          });
        }
      }, {
        key: "open",

        /** @return {boolean} */
        get: function get() {
          return this.foundation_.isOpen();
        }
        /** @param {boolean} value */
        ,
        set: function set(value) {
          if (value) {
            this.foundation_.open();
          } else {
            this.foundation_.close();
          }
        }
      }, {
        key: "itemsContainer_",
        get: function get() {
          return this.root_.querySelector(MDCMenuFoundation.strings.ITEMS_SELECTOR);
        }
        /**
         * Return the items within the menu. Note that this only contains the set of elements within
         * the items container that are proper list items, and not supplemental / presentational DOM
         * elements.
         * @return {!Array<!Element>}
         */

      }, {
        key: "items",
        get: function get() {
          var itemsContainer = this.itemsContainer_;
          return [].slice.call(itemsContainer.querySelectorAll('.mdc-list-item[role]'));
        }
      }, {
        key: "selectedItemIndex",
        set: function set(index) {
          this.foundation_.setSelectedIndex(index);
        }
        /** @return {number} */
        ,
        get: function get() {
          return this.foundation_.getSelectedIndex();
        }
        /** @param {!boolean} rememberSelection */

      }, {
        key: "rememberSelection",
        set: function set(rememberSelection) {
          this.foundation_.setRememberSelection(rememberSelection);
        }
        /** @param {boolean} quickOpen */

      }, {
        key: "quickOpen",
        set: function set(quickOpen) {
          this.foundation_.setQuickOpen(quickOpen);
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCMenu(root);
        }
      }]);

      return MDCMenu;
    }(MDCComponent$d);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcMenuChange = /** @class */ (function () {
        function MdcMenuChange(index, source) {
            this.index = index;
            this.source = source;
        }
        return MdcMenuChange;
    }());
    var /** @type {?} */ nextUniqueId$3 = 0;
    var /** @type {?} */ uniqueIdCounter$1 = 0;
    var MdcMenuAnchor = /** @class */ (function () {
        function MdcMenuAnchor(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcMenuAnchor.decorators = [
            { type: core.Component, args: [{selector: '[mdc-menu-anchor], [mdcMenuAnchor], mdc-menu-anchor',
                        exportAs: 'mdcMenuAnchor',
                        template: '<ng-content></ng-content>'
                    },] },
        ];
        /** @nocollapse */
        MdcMenuAnchor.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcMenuAnchor.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-menu-anchor',] }]
        };
        return MdcMenuAnchor;
    }());
    var MdcMenuDivider = /** @class */ (function () {
        function MdcMenuDivider(elementRef) {
            this.elementRef = elementRef;
        }
        MdcMenuDivider.decorators = [
            { type: core.Component, args: [{selector: '[mdc-menu-divider], mdc-menu-divider',
                        exportAs: 'mdcMenuDivider',
                        template: '<div class="mdc-list-divider" role="seperator"></div>',
                    },] },
        ];
        /** @nocollapse */
        MdcMenuDivider.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return MdcMenuDivider;
    }());
    var MdcMenuItems = /** @class */ (function () {
        function MdcMenuItems(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
            this.isSelectClass = true;
            this.role = 'menu';
            this.ariaHidden = 'true';
        }
        MdcMenuItems.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-menu-items',
                        exportAs: 'mdcMenuItems'
                    },] },
        ];
        /** @nocollapse */
        MdcMenuItems.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcMenuItems.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-list',] }],
            isSelectClass: [{ type: core.HostBinding, args: ['class.mdc-menu__items',] }],
            role: [{ type: core.HostBinding, args: ['attr.role',] }],
            ariaHidden: [{ type: core.HostBinding, args: ['attr.aria-hidden',] }]
        };
        return MdcMenuItems;
    }());
    var MdcMenuItem = /** @class */ (function () {
        function MdcMenuItem(_renderer, elementRef) {
            this._renderer = _renderer;
            this.elementRef = elementRef;
            this.id = "mdc-menu-item-" + uniqueIdCounter$1++;
            this._disabled = false;
            this.isHostClass = true;
            this.role = 'menuitem';
        }
        Object.defineProperty(MdcMenuItem.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._disabled = toBoolean(value);
                value ? this._renderer.setAttribute(this.elementRef.nativeElement, 'aria-disabled', 'true')
                    : this._renderer.removeAttribute(this.elementRef.nativeElement, 'aria-disabled');
            },
            enumerable: true,
            configurable: true
        });
        /** Used to set the `tabindex`. */
        /**
         * Used to set the `tabindex`.
         * @return {?}
         */
        MdcMenuItem.prototype._getTabIndex = /**
         * Used to set the `tabindex`.
         * @return {?}
         */
        function () {
            return this.disabled ? '-1' : '0';
        };
        MdcMenuItem.decorators = [
            { type: core.Component, args: [{selector: 'mdc-menu-item',
                        exportAs: 'mdcMenuItem',
                        host: {
                            '[id]': 'id',
                            '[attr.tabindex]': '_getTabIndex()',
                        },
                        template: '<ng-content></ng-content>',
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcMenuItem.ctorParameters = function () { return [
            { type: core.Renderer2 },
            { type: core.ElementRef }
        ]; };
        MdcMenuItem.propDecorators = {
            id: [{ type: core.Input }],
            label: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-list-item',] }],
            role: [{ type: core.HostBinding, args: ['attr.role',] }]
        };
        return MdcMenuItem;
    }());
    var MdcMenu = /** @class */ (function () {
        function MdcMenu(_changeDetectorRef, _renderer, elementRef, _registry) {
            var _this = this;
            this._changeDetectorRef = _changeDetectorRef;
            this._renderer = _renderer;
            this.elementRef = elementRef;
            this._registry = _registry;
            this._uniqueId = "mdc-menu-" + ++nextUniqueId$3;
            this.id = this._uniqueId;
            this._anchorCorner = 'top-start';
            this._rememberSelection = false;
            this._quickOpen = false;
            this.cancel = new core.EventEmitter();
            this.select = new core.EventEmitter();
            this.isHostClass = true;
            this.tabindex = -1;
            this._mdcAdapter = {
                addClass: function (className) { return _this._renderer.addClass(_this._getHostElement(), className); },
                removeClass: function (className) { return _this._renderer.removeClass(_this._getHostElement(), className); },
                hasClass: function (className) { return _this._getHostElement().classList.contains(className); },
                hasNecessaryDom: function () { return _this.menuContainer; },
                getAttributeForEventTarget: function (target, attributeName) { return target.getAttribute(attributeName); },
                getInnerDimensions: function () {
                    return {
                        width: _this.menuContainer.elementRef.nativeElement.offsetWidth,
                        height: _this.menuContainer.elementRef.nativeElement.offsetHeight
                    };
                },
                hasAnchor: function () { return _this.anchor; },
                getAnchorDimensions: function () { return _this.anchor.elementRef.nativeElement.getBoundingClientRect(); },
                getWindowDimensions: function () {
                    return {
                        width: isBrowser() ? window.innerWidth : 0,
                        height: isBrowser() ? window.innerHeight : 0
                    };
                },
                getNumberOfItems: function () { return _this.options ? _this.options.length : 0; },
                registerInteractionHandler: function (type, handler) { return _this._registry.listen(type, handler, _this._getHostElement()); },
                deregisterInteractionHandler: function (type, handler) { return _this._registry.unlisten(type, handler); },
                registerBodyClickHandler: function (handler) { return _this._registry.listen('click', handler, document.body); },
                deregisterBodyClickHandler: function (handler) { return _this._registry.unlisten('click', handler); },
                getIndexForEventTarget: function (target) { return _this.options.toArray().findIndex(function (_) { return _.elementRef.nativeElement === target; }); },
                notifySelected: function (evtData) {
                    return _this.select.emit(new MdcMenuChange(evtData.index, _this.options.toArray()[evtData.index]));
                },
                notifyCancel: function () { return _this.cancel.emit(); },
                saveFocus: function () {
                    if (isBrowser()) {
                        _this._previousFocus = document.activeElement;
                    }
                },
                restoreFocus: function () {
                    if (_this._previousFocus) {
                        _this._previousFocus.focus();
                    }
                },
                isFocused: function () { return document.activeElement === _this._getHostElement(); },
                focus: function () { return _this._getHostElement().focus(); },
                getFocusedItemIndex: function () { return _this.options.toArray().map(function (_) { return _.elementRef.nativeElement; }).indexOf(document.activeElement); },
                focusItemAtIndex: function (index) { return _this.options.toArray()[index].elementRef.nativeElement.focus(); },
                isRtl: function () { return getComputedStyle(_this._getHostElement()).getPropertyValue('direction') === 'rtl'; },
                setTransformOrigin: function (origin) {
                    if (isBrowser()) {
                        _this._renderer.setStyle(_this._getHostElement(), getTransformPropertyName$1(window) + "-origin", origin);
                    }
                },
                setPosition: function (position) {
                    position.left ? _this._setStyle('left', position.left) : _this._setStyle('left');
                    position.right ? _this._setStyle('right', position.right) : _this._setStyle('right');
                    position.top ? _this._setStyle('top', position.top) : _this._setStyle('top');
                    position.bottom ? _this._setStyle('bottom', position.bottom) : _this._setStyle('bottom');
                },
                setMaxHeight: function (height) { return _this._renderer.setStyle(_this._getHostElement(), 'maxHeight', height); },
                setAttrForOptionAtIndex: function (index, attr, value) {
                    return _this._renderer.setAttribute(_this.options.toArray()[index].elementRef.nativeElement, attr, value);
                },
                rmAttrForOptionAtIndex: function (index, attr) {
                    return _this._renderer.removeAttribute(_this.options.toArray()[index].elementRef.nativeElement, attr);
                },
                addClassForOptionAtIndex: function (index, className) {
                    return _this._renderer.addClass(_this.options.toArray()[index].elementRef.nativeElement, className);
                },
                rmClassForOptionAtIndex: function (index, className) {
                    return _this._renderer.removeClass(_this.options.toArray()[index].elementRef.nativeElement, className);
                },
            };
            this._foundation = new MDCMenuFoundation(this._mdcAdapter);
        }
        Object.defineProperty(MdcMenu.prototype, "anchorCorner", {
            get: /**
             * @return {?}
             */
            function () { return this._anchorCorner; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setAnchorCorner(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcMenu.prototype, "rememberSelection", {
            get: /**
             * @return {?}
             */
            function () { return this._rememberSelection; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setRememberSelection(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcMenu.prototype, "quickOpen", {
            get: /**
             * @return {?}
             */
            function () { return this._quickOpen; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setQuickOpen(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcMenu.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this._foundation.init();
        };
        /**
         * @return {?}
         */
        MdcMenu.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._foundation.destroy();
        };
        /**
         * @param {?} rememberSelection
         * @return {?}
         */
        MdcMenu.prototype.setRememberSelection = /**
         * @param {?} rememberSelection
         * @return {?}
         */
        function (rememberSelection) {
            this._rememberSelection = rememberSelection;
            this._foundation.setRememberSelection(rememberSelection);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} index
         * @return {?}
         */
        MdcMenu.prototype.setSelectedIndex = /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            this._foundation.setSelectedIndex(index);
        };
        /**
         * @return {?}
         */
        MdcMenu.prototype.getSelectedIndex = /**
         * @return {?}
         */
        function () {
            return this._foundation.getSelectedIndex();
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MdcMenu.prototype.setAnchorCorner = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._anchorCorner = value;
            if (this._foundation) {
                var /** @type {?} */ corner = this._parseAnchorCorner(value);
                this._foundation.setAnchorCorner(corner);
            }
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} quickOpen
         * @return {?}
         */
        MdcMenu.prototype.setQuickOpen = /**
         * @param {?} quickOpen
         * @return {?}
         */
        function (quickOpen) {
            this._quickOpen = quickOpen;
            this._foundation.setQuickOpen(quickOpen);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} height
         * @return {?}
         */
        MdcMenu.prototype.setMaxHeight = /**
         * @param {?} height
         * @return {?}
         */
        function (height) {
            this._mdcAdapter.setMaxHeight(height);
        };
        /**
         * @return {?}
         */
        MdcMenu.prototype.isOpen = /**
         * @return {?}
         */
        function () {
            return this._foundation.isOpen();
        };
        /**
         * @return {?}
         */
        MdcMenu.prototype.open = /**
         * @return {?}
         */
        function () {
            if (!this.isOpen()) {
                this._foundation.open();
            }
        };
        /**
         * @return {?}
         */
        MdcMenu.prototype.toggle = /**
         * @return {?}
         */
        function () {
            this.isOpen() ? this.close() : this.open();
        };
        /**
         * @return {?}
         */
        MdcMenu.prototype.close = /**
         * @return {?}
         */
        function () {
            this._foundation.close();
        };
        /**
         * @return {?}
         */
        MdcMenu.prototype.focus = /**
         * @return {?}
         */
        function () {
            this._getHostElement().focus();
        };
        /**
         * @param {?} anchorPoint
         * @param {?=} position
         * @return {?}
         */
        MdcMenu.prototype._setStyle = /**
         * @param {?} anchorPoint
         * @param {?=} position
         * @return {?}
         */
        function (anchorPoint, position) {
            position ? this._renderer.setStyle(this._getHostElement(), anchorPoint, position)
                : this._renderer.removeStyle(this._getHostElement(), anchorPoint);
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MdcMenu.prototype._parseAnchorCorner = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            switch (value) {
                case 'top-end': {
                    return Corner.TOP_END;
                }
                case 'bottom-start': {
                    return Corner.BOTTOM_START;
                }
                case 'bottom-end': {
                    return Corner.BOTTOM_END;
                }
                default: {
                    return Corner.TOP_START;
                }
            }
        };
        /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        MdcMenu.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcMenu.decorators = [
            { type: core.Component, args: [{selector: 'mdc-menu',
                        host: {
                            '[id]': 'id',
                        },
                        exportAs: 'mdcMenu',
                        template: "\n  <mdc-menu-items>\n    <ng-content></ng-content>\n  </mdc-menu-items>\n  ",
                        providers: [EventRegistry],
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcMenu.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.Renderer2 },
            { type: core.ElementRef },
            { type: EventRegistry }
        ]; };
        MdcMenu.propDecorators = {
            id: [{ type: core.Input }],
            anchor: [{ type: core.Input }],
            anchorCorner: [{ type: core.Input }],
            rememberSelection: [{ type: core.Input }],
            quickOpen: [{ type: core.Input }],
            cancel: [{ type: core.Output }],
            select: [{ type: core.Output }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-menu',] }],
            tabindex: [{ type: core.HostBinding, args: ['tabindex',] }],
            menuContainer: [{ type: core.ViewChild, args: [MdcMenuItems,] }],
            options: [{ type: core.ContentChildren, args: [MdcMenuItem,] }]
        };
        return MdcMenu;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ MENU_DECLARATIONS = [
        MdcMenu,
        MdcMenuAnchor,
        MdcMenuDivider,
        MdcMenuItem,
        MdcMenuItems,
    ];
    var MdcMenuModule = /** @class */ (function () {
        function MdcMenuModule() {
        }
        MdcMenuModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [MENU_DECLARATIONS],
                        declarations: [MENU_DECLARATIONS],
                    },] },
        ];
        return MdcMenuModule;
    }());

    function _classCallCheck$g(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$g(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$g(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$g(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$g(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$g(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$g(subClass, superClass);
    }

    function _getPrototypeOf$g(o) {
      _getPrototypeOf$g = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$g(o);
    }

    function _setPrototypeOf$g(o, p) {
      _setPrototypeOf$g = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$g(o, p);
    }

    function _assertThisInitialized$g(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$g(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$g(self);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @template A
     */
    var MDCFoundation$f =
    /*#__PURE__*/
    function () {
      _createClass$g(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$g(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$g(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$e =
    /*#__PURE__*/
    function () {
      _createClass$g(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$f());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$g(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$g(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2017 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Notched Outline.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Notched Outline into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCNotchedOutlineAdapter =
    /*#__PURE__*/
    function () {
      function MDCNotchedOutlineAdapter() {
        _classCallCheck$g(this, MDCNotchedOutlineAdapter);
      }

      _createClass$g(MDCNotchedOutlineAdapter, [{
        key: "getWidth",

        /**
         * Returns the width of the root element.
         * @return {number}
         */
        value: function getWidth() {}
        /**
         * Returns the height of the root element.
         * @return {number}
         */

      }, {
        key: "getHeight",
        value: function getHeight() {}
        /**
         * Adds a class to the root element.
         * @param {string} className
         */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /**
         * Removes a class from the root element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Sets the "d" attribute of the outline element's SVG path.
         * @param {string} value
         */

      }, {
        key: "setOutlinePathAttr",
        value: function setOutlinePathAttr(value) {}
        /**
         * Returns the idle outline element's computed style value of the given css property `propertyName`.
         * We achieve this via `getComputedStyle(...).getPropertyValue(propertyName)`.
         * @param {string} propertyName
         * @return {string}
         */

      }, {
        key: "getIdleOutlineStyleValue",
        value: function getIdleOutlineStyleValue(propertyName) {}
      }]);

      return MDCNotchedOutlineAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var strings$d = {
      PATH_SELECTOR: '.mdc-notched-outline__path',
      IDLE_OUTLINE_SELECTOR: '.mdc-notched-outline__idle'
    };
    /** @enum {string} */

    var cssClasses$e = {
      OUTLINE_NOTCHED: 'mdc-notched-outline--notched'
    };

    /**
     * @extends {MDCFoundation<!MDCNotchedOutlineAdapter>}
     * @final
     */

    var MDCNotchedOutlineFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$g(MDCNotchedOutlineFoundation, _MDCFoundation);

      _createClass$g(MDCNotchedOutlineFoundation, null, [{
        key: "strings",

        /** @return enum {string} */
        get: function get() {
          return strings$d;
        }
        /** @return enum {string} */

      }, {
        key: "cssClasses",
        get: function get() {
          return cssClasses$e;
        }
        /**
         * {@see MDCNotchedOutlineAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCNotchedOutlineAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCNotchedOutlineAdapter} */
            {
              getWidth: function getWidth() {},
              getHeight: function getHeight() {},
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              setOutlinePathAttr: function setOutlinePathAttr() {},
              getIdleOutlineStyleValue: function getIdleOutlineStyleValue() {}
            }
          );
        }
        /**
         * @param {!MDCNotchedOutlineAdapter} adapter
         */

      }]);

      function MDCNotchedOutlineFoundation(adapter) {
        _classCallCheck$g(this, MDCNotchedOutlineFoundation);

        return _possibleConstructorReturn$g(this, _getPrototypeOf$g(MDCNotchedOutlineFoundation).call(this, Object.assign(MDCNotchedOutlineFoundation.defaultAdapter, adapter)));
      }
      /**
       * Adds the outline notched selector and updates the notch width
       * calculated based off of notchWidth and isRtl.
       * @param {number} notchWidth
       * @param {boolean=} isRtl
       */


      _createClass$g(MDCNotchedOutlineFoundation, [{
        key: "notch",
        value: function notch(notchWidth) {
          var isRtl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;
          this.adapter_.addClass(OUTLINE_NOTCHED);
          this.updateSvgPath_(notchWidth, isRtl);
        }
        /**
         * Removes notched outline selector to close the notch in the outline.
         */

      }, {
        key: "closeNotch",
        value: function closeNotch() {
          var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;
          this.adapter_.removeClass(OUTLINE_NOTCHED);
        }
        /**
         * Updates the SVG path of the focus outline element based on the notchWidth
         * and the RTL context.
         * @param {number} notchWidth
         * @param {boolean=} isRtl
         * @private
         */

      }, {
        key: "updateSvgPath_",
        value: function updateSvgPath_(notchWidth, isRtl) {
          // Fall back to reading a specific corner's style because Firefox doesn't report the style on border-radius.
          var radiusStyleValue = this.adapter_.getIdleOutlineStyleValue('border-radius') || this.adapter_.getIdleOutlineStyleValue('border-top-left-radius');
          var radius = parseFloat(radiusStyleValue);
          var width = this.adapter_.getWidth();
          var height = this.adapter_.getHeight();
          var cornerWidth = radius + 1.2;
          var leadingStrokeLength = Math.abs(11 - cornerWidth);
          var paddedNotchWidth = notchWidth + 8; // The right, bottom, and left sides of the outline follow the same SVG path.

          var pathMiddle = 'a' + radius + ',' + radius + ' 0 0 1 ' + radius + ',' + radius + 'v' + (height - 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + -radius + ',' + radius + 'h' + (-width + 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + -radius + ',' + -radius + 'v' + (-height + 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + radius + ',' + -radius;
          var path;

          if (!isRtl) {
            path = 'M' + (cornerWidth + leadingStrokeLength + paddedNotchWidth) + ',' + 1 + 'h' + (width - 2 * cornerWidth - paddedNotchWidth - leadingStrokeLength) + pathMiddle + 'h' + leadingStrokeLength;
          } else {
            path = 'M' + (width - cornerWidth - leadingStrokeLength) + ',' + 1 + 'h' + leadingStrokeLength + pathMiddle + 'h' + (width - 2 * cornerWidth - paddedNotchWidth - leadingStrokeLength);
          }

          this.adapter_.setOutlinePathAttr(path);
        }
      }]);

      return MDCNotchedOutlineFoundation;
    }(MDCFoundation$f);

    /**
     * @extends {MDCComponent<!MDCNotchedOutlineFoundation>}
     * @final
     */

    var MDCNotchedOutline =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$g(MDCNotchedOutline, _MDCComponent);

      function MDCNotchedOutline() {
        _classCallCheck$g(this, MDCNotchedOutline);

        return _possibleConstructorReturn$g(this, _getPrototypeOf$g(MDCNotchedOutline).apply(this, arguments));
      }

      _createClass$g(MDCNotchedOutline, [{
        key: "notch",

        /**
          * Updates outline selectors and SVG path to open notch.
          * @param {number} notchWidth The notch width in the outline.
          * @param {boolean=} isRtl Determines if outline is rtl. If rtl is true, notch
          * will be right justified in outline path, otherwise left justified.
          */
        value: function notch(notchWidth, isRtl) {
          this.foundation_.notch(notchWidth, isRtl);
        }
        /**
         * Updates the outline selectors to close notch and return it to idle state.
         */

      }, {
        key: "closeNotch",
        value: function closeNotch() {
          this.foundation_.closeNotch();
        }
        /**
         * @return {!MDCNotchedOutlineFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCNotchedOutlineFoundation({
            getWidth: function getWidth() {
              return _this.root_.offsetWidth;
            },
            getHeight: function getHeight() {
              return _this.root_.offsetHeight;
            },
            addClass: function addClass(className) {
              return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this.root_.classList.remove(className);
            },
            setOutlinePathAttr: function setOutlinePathAttr(value) {
              var path = _this.root_.querySelector(strings$d.PATH_SELECTOR);

              path.setAttribute('d', value);
            },
            getIdleOutlineStyleValue: function getIdleOutlineStyleValue(propertyName) {
              var idleOutlineElement = _this.root_.parentNode.querySelector(strings$d.IDLE_OUTLINE_SELECTOR);

              return window.getComputedStyle(idleOutlineElement).getPropertyValue(propertyName);
            }
          });
        }
      }], [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCNotchedOutline}
         */
        value: function attachTo(root) {
          return new MDCNotchedOutline(root);
        }
      }]);

      return MDCNotchedOutline;
    }(MDCComponent$e);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcNotchedOutline = /** @class */ (function () {
        function MdcNotchedOutline(elementRef) {
            var _this = this;
            this.elementRef = elementRef;
            this._mdcAdapter = {
                getWidth: function () { return _this._notchOutline.nativeElement.offsetWidth; },
                getHeight: function () { return _this._notchOutline.nativeElement.offsetHeight; },
                addClass: function (className) { return _this._notchOutline.nativeElement.classList.add(className); },
                removeClass: function (className) { return _this._notchOutline.nativeElement.classList.remove(className); },
                setOutlinePathAttr: function (value) { return _this._svgpath.nativeElement.setAttribute('d', value); },
                getIdleOutlineStyleValue: function (propertyName) {
                    return window.getComputedStyle(_this._notchIdle.nativeElement).getPropertyValue(propertyName);
                }
            };
            this._foundation = new MDCNotchedOutlineFoundation(this._mdcAdapter);
        }
        /**
         * @return {?}
         */
        MdcNotchedOutline.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this._foundation.init();
        };
        /**
         * @return {?}
         */
        MdcNotchedOutline.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._foundation.destroy();
        };
        /**
         * Updates outline selectors and SVG path to open notch.
         */
        /**
         * Updates outline selectors and SVG path to open notch.
         * @param {?} notchWidth
         * @param {?} isRtl
         * @return {?}
         */
        MdcNotchedOutline.prototype.notch = /**
         * Updates outline selectors and SVG path to open notch.
         * @param {?} notchWidth
         * @param {?} isRtl
         * @return {?}
         */
        function (notchWidth, isRtl) {
            this._foundation.notch(notchWidth, isRtl);
        };
        /**
         * Updates the outline selectors to close notch and return it to idle state.
         */
        /**
         * Updates the outline selectors to close notch and return it to idle state.
         * @return {?}
         */
        MdcNotchedOutline.prototype.closeNotch = /**
         * Updates the outline selectors to close notch and return it to idle state.
         * @return {?}
         */
        function () {
            this._foundation.closeNotch();
        };
        MdcNotchedOutline.decorators = [
            { type: core.Component, args: [{selector: '[mdcNotchedOutline], mdc-notched-outline',
                        exportAs: 'mdcNotchedOutline',
                        template: "\n  <div #notchOutline class=\"mdc-notched-outline\">\n    <svg>\n      <path #svgpath class=\"mdc-notched-outline__path\"/>\n    </svg>\n  </div>\n  <div #notchIdle class=\"mdc-notched-outline__idle\"></div>\n  ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcNotchedOutline.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcNotchedOutline.propDecorators = {
            _notchOutline: [{ type: core.ViewChild, args: ['notchOutline',] }],
            _svgpath: [{ type: core.ViewChild, args: ['svgpath',] }],
            _notchIdle: [{ type: core.ViewChild, args: ['notchIdle',] }]
        };
        return MdcNotchedOutline;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcNotchedOutlineModule = /** @class */ (function () {
        function MdcNotchedOutlineModule() {
        }
        MdcNotchedOutlineModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [MdcNotchedOutline],
                        declarations: [MdcNotchedOutline],
                    },] },
        ];
        return MdcNotchedOutlineModule;
    }());

    function _classCallCheck$h(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$h(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$h(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$h(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$h(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$h(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$h(subClass, superClass);
    }

    function _getPrototypeOf$h(o) {
      _getPrototypeOf$h = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$h(o);
    }

    function _setPrototypeOf$h(o, p) {
      _setPrototypeOf$h = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$h(o, p);
    }

    function _assertThisInitialized$h(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$h(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$h(self);
    }

    function _superPropBase$8(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$h(object);
        if (object === null) break;
      }

      return object;
    }

    function _get$8(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$8 = Reflect.get;
      } else {
        _get$8 = function _get(target, property, receiver) {
          var base = _superPropBase$8(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get$8(target, property, receiver || target);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @template A
     */
    var MDCFoundation$g =
    /*#__PURE__*/
    function () {
      _createClass$h(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$h(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$h(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$f =
    /*#__PURE__*/
    function () {
      _createClass$h(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$g());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$h(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$h(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Ripple. Provides an interface for managing
     * - classes
     * - dom
     * - CSS variables
     * - position
     * - dimensions
     * - scroll position
     * - event handlers
     * - unbounded, active and disabled states
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCRippleAdapter$8 =
    /*#__PURE__*/
    function () {
      function MDCRippleAdapter() {
        _classCallCheck$h(this, MDCRippleAdapter);
      }

      _createClass$h(MDCRippleAdapter, [{
        key: "browserSupportsCssVars",

        /** @return {boolean} */
        value: function browserSupportsCssVars() {}
        /** @return {boolean} */

      }, {
        key: "isUnbounded",
        value: function isUnbounded() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceActive",
        value: function isSurfaceActive() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceDisabled",
        value: function isSurfaceDisabled() {}
        /** @param {string} className */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @param {!EventTarget} target */

      }, {
        key: "containsEventTarget",
        value: function containsEventTarget(target) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerDocumentInteractionHandler",
        value: function registerDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterDocumentInteractionHandler",
        value: function deregisterDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /**
         * @param {string} varName
         * @param {?number|string} value
         */

      }, {
        key: "updateCssVariable",
        value: function updateCssVariable(varName, value) {}
        /** @return {!ClientRect} */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}
        /** @return {{x: number, y: number}} */

      }, {
        key: "getWindowPageOffset",
        value: function getWindowPageOffset() {}
      }]);

      return MDCRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var cssClasses$f = {
      // Ripple is a special case where the "root" component is really a "mixin" of sorts,
      // given that it's an 'upgrade' to an existing component. That being said it is the root
      // CSS class that all other CSS classes derive from.
      ROOT: 'mdc-ripple-upgraded',
      UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
      BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
      FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
      FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
    };
    var strings$e = {
      VAR_LEFT: '--mdc-ripple-left',
      VAR_TOP: '--mdc-ripple-top',
      VAR_FG_SIZE: '--mdc-ripple-fg-size',
      VAR_FG_SCALE: '--mdc-ripple-fg-scale',
      VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
      VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
    };
    var numbers$9 = {
      PADDING: 10,
      INITIAL_ORIGIN_SCALE: 0.6,
      DEACTIVATION_TIMEOUT_MS: 225,
      // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
      FG_DEACTIVATION_MS: 150,
      // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
      TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

    };

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
     * @private {boolean|undefined}
     */
    var supportsCssVariables_$8;
    /**
     * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
     * @private {boolean|undefined}
     */

    var supportsPassive_$9;
    /**
     * @param {!Window} windowObj
     * @return {boolean}
     */

    function detectEdgePseudoVarBug$8(windowObj) {
      // Detect versions of Edge with buggy var() support
      // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
      var document = windowObj.document;
      var node = document.createElement('div');
      node.className = 'mdc-ripple-surface--test-edge-var-bug';
      document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
      // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
      // but Firefox is known to support CSS custom properties correctly.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

      var computedStyle = windowObj.getComputedStyle(node);
      var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
      node.remove();
      return hasPseudoVarBug;
    }
    /**
     * @param {!Window} windowObj
     * @param {boolean=} forceRefresh
     * @return {boolean|undefined}
     */


    function supportsCssVariables$8(windowObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var supportsCssVariables = supportsCssVariables_$8;

      if (typeof supportsCssVariables_$8 === 'boolean' && !forceRefresh) {
        return supportsCssVariables;
      }

      var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

      if (!supportsFunctionPresent) {
        return;
      }

      var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
      // See: README section on Safari

      var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

      if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVariables = !detectEdgePseudoVarBug$8(windowObj);
      } else {
        supportsCssVariables = false;
      }

      if (!forceRefresh) {
        supportsCssVariables_$8 = supportsCssVariables;
      }

      return supportsCssVariables;
    } //

    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|{passive: boolean}}
     */


    function applyPassive$9() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_$9 === undefined || forceRefresh) {
        var isSupported = false;

        try {
          globalObj.document.addEventListener('test', null, {
            get passive() {
              isSupported = true;
            }

          });
        } catch (e) {}

        supportsPassive_$9 = isSupported;
      }

      return supportsPassive_$9 ? {
        passive: true
      } : false;
    }
    /**
     * @param {!Object} HTMLElementPrototype
     * @return {!Array<string>}
     */


    function getMatchesProperty$8(HTMLElementPrototype) {
      return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(function (p) {
        return p in HTMLElementPrototype;
      }).pop();
    }
    /**
     * @param {!Event} ev
     * @param {{x: number, y: number}} pageOffset
     * @param {!ClientRect} clientRect
     * @return {{x: number, y: number}}
     */


    function getNormalizedEventCoords$8(ev, pageOffset, clientRect) {
      var x = pageOffset.x,
          y = pageOffset.y;
      var documentX = x + clientRect.left;
      var documentY = y + clientRect.top;
      var normalizedX;
      var normalizedY; // Determine touch point relative to the ripple container.

      if (ev.type === 'touchstart') {
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
      } else {
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
      }

      return {
        x: normalizedX,
        y: normalizedY
      };
    }

    var ACTIVATION_EVENT_TYPES$8 = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

    var POINTER_DEACTIVATION_EVENT_TYPES$8 = ['touchend', 'pointerup', 'mouseup']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

    /** @type {!Array<!EventTarget>} */

    var activatedTargets$8 = [];
    /**
     * @extends {MDCFoundation<!MDCRippleAdapter>}
     */

    var MDCRippleFoundation$8 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$h(MDCRippleFoundation, _MDCFoundation);

      _createClass$h(MDCRippleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$f;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$e;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers$9;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            browserSupportsCssVars: function browserSupportsCssVars()
            /* boolean - cached */
            {},
            isUnbounded: function isUnbounded()
            /* boolean */
            {},
            isSurfaceActive: function isSurfaceActive()
            /* boolean */
            {},
            isSurfaceDisabled: function isSurfaceDisabled()
            /* boolean */
            {},
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            containsEventTarget: function containsEventTarget()
            /* target: !EventTarget */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            updateCssVariable: function updateCssVariable()
            /* varName: string, value: string */
            {},
            computeBoundingRect: function computeBoundingRect()
            /* ClientRect */
            {},
            getWindowPageOffset: function getWindowPageOffset()
            /* {x: number, y: number} */
            {}
          };
        }
      }]);

      function MDCRippleFoundation(adapter) {
        var _this;

        _classCallCheck$h(this, MDCRippleFoundation);

        _this = _possibleConstructorReturn$h(this, _getPrototypeOf$h(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
        /** @private {number} */

        _this.layoutFrame_ = 0;
        /** @private {!ClientRect} */

        _this.frame_ =
        /** @type {!ClientRect} */
        {
          width: 0,
          height: 0
        };
        /** @private {!ActivationStateType} */

        _this.activationState_ = _this.defaultActivationState_();
        /** @private {number} */

        _this.initialSize_ = 0;
        /** @private {number} */

        _this.maxRadius_ = 0;
        /** @private {function(!Event)} */

        _this.activateHandler_ = function (e) {
          return _this.activate_(e);
        };
        /** @private {function(!Event)} */


        _this.deactivateHandler_ = function (e) {
          return _this.deactivate_(e);
        };
        /** @private {function(?Event=)} */


        _this.focusHandler_ = function () {
          return _this.handleFocus();
        };
        /** @private {function(?Event=)} */


        _this.blurHandler_ = function () {
          return _this.handleBlur();
        };
        /** @private {!Function} */


        _this.resizeHandler_ = function () {
          return _this.layout();
        };
        /** @private {{left: number, top:number}} */


        _this.unboundedCoords_ = {
          left: 0,
          top: 0
        };
        /** @private {number} */

        _this.fgScale_ = 0;
        /** @private {number} */

        _this.activationTimer_ = 0;
        /** @private {number} */

        _this.fgDeactivationRemovalTimer_ = 0;
        /** @private {boolean} */

        _this.activationAnimationHasEnded_ = false;
        /** @private {!Function} */

        _this.activationTimerCallback_ = function () {
          _this.activationAnimationHasEnded_ = true;

          _this.runDeactivationUXLogicIfReady_();
        };
        /** @private {?Event} */


        _this.previousActivationEvent_ = null;
        return _this;
      }
      /**
       * We compute this property so that we are not querying information about the client
       * until the point in time where the foundation requests it. This prevents scenarios where
       * client-side feature-detection may happen too early, such as when components are rendered on the server
       * and then initialized at mount time on the client.
       * @return {boolean}
       * @private
       */


      _createClass$h(MDCRippleFoundation, [{
        key: "isSupported_",
        value: function isSupported_() {
          return this.adapter_.browserSupportsCssVars();
        }
        /**
         * @return {!ActivationStateType}
         */

      }, {
        key: "defaultActivationState_",
        value: function defaultActivationState_() {
          return {
            isActivated: false,
            hasDeactivationUXRun: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
            activationEvent: null,
            isProgrammatic: false
          };
        }
        /** @override */

      }, {
        key: "init",
        value: function init() {
          var _this2 = this;

          if (!this.isSupported_()) {
            return;
          }

          this.registerRootHandlers_();
          var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$.ROOT,
              UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
          requestAnimationFrame(function () {
            _this2.adapter_.addClass(ROOT);

            if (_this2.adapter_.isUnbounded()) {
              _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


              _this2.layoutInternal_();
            }
          });
        }
        /** @override */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          if (!this.isSupported_()) {
            return;
          }

          if (this.activationTimer_) {
            clearTimeout(this.activationTimer_);
            this.activationTimer_ = 0;
            var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
            this.adapter_.removeClass(FG_ACTIVATION);
          }

          this.deregisterRootHandlers_();
          this.deregisterDeactivationHandlers_();
          var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$2.ROOT,
              UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
          requestAnimationFrame(function () {
            _this3.adapter_.removeClass(ROOT);

            _this3.adapter_.removeClass(UNBOUNDED);

            _this3.removeCssVars_();
          });
        }
        /** @private */

      }, {
        key: "registerRootHandlers_",
        value: function registerRootHandlers_() {
          var _this4 = this;

          ACTIVATION_EVENT_TYPES$8.forEach(function (type) {
            _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
          });
          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.registerResizeHandler(this.resizeHandler_);
          }
        }
        /**
         * @param {!Event} e
         * @private
         */

      }, {
        key: "registerDeactivationHandlers_",
        value: function registerDeactivationHandlers_(e) {
          var _this5 = this;

          if (e.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
          } else {
            POINTER_DEACTIVATION_EVENT_TYPES$8.forEach(function (type) {
              _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
            });
          }
        }
        /** @private */

      }, {
        key: "deregisterRootHandlers_",
        value: function deregisterRootHandlers_() {
          var _this6 = this;

          ACTIVATION_EVENT_TYPES$8.forEach(function (type) {
            _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
          });
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          }
        }
        /** @private */

      }, {
        key: "deregisterDeactivationHandlers_",
        value: function deregisterDeactivationHandlers_() {
          var _this7 = this;

          this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
          POINTER_DEACTIVATION_EVENT_TYPES$8.forEach(function (type) {
            _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
          });
        }
        /** @private */

      }, {
        key: "removeCssVars_",
        value: function removeCssVars_() {
          var _this8 = this;

          var strings$$1 = MDCRippleFoundation.strings;
          Object.keys(strings$$1).forEach(function (k) {
            if (k.indexOf('VAR_') === 0) {
              _this8.adapter_.updateCssVariable(strings$$1[k], null);
            }
          });
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "activate_",
        value: function activate_(e) {
          var _this9 = this;

          if (this.adapter_.isSurfaceDisabled()) {
            return;
          }

          var activationState = this.activationState_;

          if (activationState.isActivated) {
            return;
          } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


          var previousActivationEvent = this.previousActivationEvent_;
          var isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;

          if (isSameInteraction) {
            return;
          }

          activationState.isActivated = true;
          activationState.isProgrammatic = e === null;
          activationState.activationEvent = e;
          activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';
          var hasActivatedChild = e && activatedTargets$8.length > 0 && activatedTargets$8.some(function (target) {
            return _this9.adapter_.containsEventTarget(target);
          });

          if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
          }

          if (e) {
            activatedTargets$8.push(
            /** @type {!EventTarget} */
            e.target);
            this.registerDeactivationHandlers_(e);
          }

          activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

          if (activationState.wasElementMadeActive) {
            this.animateActivation_();
          }

          requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets$8 = [];

            if (!activationState.wasElementMadeActive && (e.key === ' ' || e.keyCode === 32)) {
              // If space was pressed, try again within an rAF call to detect :active, because different UAs report
              // active states inconsistently when they're called within event handling code:
              // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
              // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
              // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
              // variable is set within a rAF callback for a submit button interaction (#2241).
              activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

              if (activationState.wasElementMadeActive) {
                _this9.animateActivation_();
              }
            }

            if (!activationState.wasElementMadeActive) {
              // Reset activation state immediately if element was not made active.
              _this9.activationState_ = _this9.defaultActivationState_();
            }
          });
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "checkElementMadeActive_",
        value: function checkElementMadeActive_(e) {
          return e && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
        }
        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: "activate",
        value: function activate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          this.activate_(event);
        }
        /** @private */

      }, {
        key: "animateActivation_",
        value: function animateActivation_() {
          var _this10 = this;

          var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
              VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
              VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
          var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
              FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
              FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
          var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
          this.layoutInternal_();
          var translateStart = '';
          var translateEnd = '';

          if (!this.adapter_.isUnbounded()) {
            var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
                startPoint = _this$getFgTranslatio.startPoint,
                endPoint = _this$getFgTranslatio.endPoint;

            translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
            translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
          }

          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

          clearTimeout(this.activationTimer_);
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.rmBoundedActivationClasses_();
          this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

          this.adapter_.computeBoundingRect();
          this.adapter_.addClass(FG_ACTIVATION);
          this.activationTimer_ = setTimeout(function () {
            return _this10.activationTimerCallback_();
          }, DEACTIVATION_TIMEOUT_MS);
        }
        /**
         * @private
         * @return {{startPoint: PointType, endPoint: PointType}}
         */

      }, {
        key: "getFgTranslationCoordinates_",
        value: function getFgTranslationCoordinates_() {
          var _this$activationState = this.activationState_,
              activationEvent = _this$activationState.activationEvent,
              wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
          var startPoint;

          if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords$8(
            /** @type {!Event} */
            activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
          } else {
            startPoint = {
              x: this.frame_.width / 2,
              y: this.frame_.height / 2
            };
          } // Center the element around the start point.


          startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
          };
          var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
          };
          return {
            startPoint: startPoint,
            endPoint: endPoint
          };
        }
        /** @private */

      }, {
        key: "runDeactivationUXLogicIfReady_",
        value: function runDeactivationUXLogicIfReady_() {
          var _this11 = this;

          // This method is called both when a pointing device is released, and when the activation animation ends.
          // The deactivation animation should only run after both of those occur.
          var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
          var _this$activationState2 = this.activationState_,
              hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
              isActivated = _this$activationState2.isActivated;
          var activationHasEnded = hasDeactivationUXRun || !isActivated;

          if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
              _this11.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers$9.FG_DEACTIVATION_MS);
          }
        }
        /** @private */

      }, {
        key: "rmBoundedActivationClasses_",
        value: function rmBoundedActivationClasses_() {
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
          this.adapter_.removeClass(FG_ACTIVATION);
          this.activationAnimationHasEnded_ = false;
          this.adapter_.computeBoundingRect();
        }
      }, {
        key: "resetActivationState_",
        value: function resetActivationState_() {
          var _this12 = this;

          this.previousActivationEvent_ = this.activationState_.activationEvent;
          this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
          // Store the previous event until it's safe to assume that subsequent events are for new interactions.

          setTimeout(function () {
            return _this12.previousActivationEvent_ = null;
          }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "deactivate_",
        value: function deactivate_(e) {
          var _this13 = this;

          var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

          if (!activationState.isActivated) {
            return;
          }

          var state =
          /** @type {!ActivationStateType} */
          Object.assign({}, activationState);

          if (activationState.isProgrammatic) {
            var evtObject = null;
            requestAnimationFrame(function () {
              return _this13.animateDeactivation_(evtObject, state);
            });
            this.resetActivationState_();
          } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
              _this13.activationState_.hasDeactivationUXRun = true;

              _this13.animateDeactivation_(e, state);

              _this13.resetActivationState_();
            });
          }
        }
        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          this.deactivate_(event);
        }
        /**
         * @param {Event} e
         * @param {!ActivationStateType} options
         * @private
         */

      }, {
        key: "animateDeactivation_",
        value: function animateDeactivation_(e, _ref) {
          var wasActivatedByPointer = _ref.wasActivatedByPointer,
              wasElementMadeActive = _ref.wasElementMadeActive;

          if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this14 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }

          this.layoutFrame_ = requestAnimationFrame(function () {
            _this14.layoutInternal_();

            _this14.layoutFrame_ = 0;
          });
        }
        /** @private */

      }, {
        key: "layoutInternal_",
        value: function layoutInternal_() {
          var _this15 = this;

          this.frame_ = this.adapter_.computeBoundingRect();
          var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
          // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
          // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
          // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
          // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
          // `overflow: hidden`.

          var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
          };

          this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

          this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;
          this.fgScale_ = this.maxRadius_ / this.initialSize_;
          this.updateLayoutCssVars_();
        }
        /** @private */

      }, {
        key: "updateLayoutCssVars_",
        value: function updateLayoutCssVars_() {
          var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
              VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
              VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
              VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
              VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
          this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
          this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

          if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
              left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
              top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };
            this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
            this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
          }
        }
        /** @param {boolean} unbounded */

      }, {
        key: "setUnbounded",
        value: function setUnbounded(unbounded) {
          var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

          if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
          } else {
            this.adapter_.removeClass(UNBOUNDED);
          }
        }
      }, {
        key: "handleFocus",
        value: function handleFocus() {
          var _this16 = this;

          requestAnimationFrame(function () {
            return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }, {
        key: "handleBlur",
        value: function handleBlur() {
          var _this17 = this;

          requestAnimationFrame(function () {
            return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }]);

      return MDCRippleFoundation;
    }(MDCFoundation$g);

    /**
     * @extends MDCComponent<!MDCRippleFoundation>
     */

    var MDCRipple$8 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$h(MDCRipple, _MDCComponent);

      /** @param {...?} args */
      function MDCRipple() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$h(this, MDCRipple);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$h(this, (_getPrototypeOf2 = _getPrototypeOf$h(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {boolean} */

        _this.disabled = false;
        /** @private {boolean} */

        _this.unbounded_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @param {{isUnbounded: (boolean|undefined)}=} options
       * @return {!MDCRipple}
       */


      _createClass$h(MDCRipple, [{
        key: "setUnbounded_",

        /**
         * Closure Compiler throws an access control error when directly accessing a
         * protected or private property inside a getter/setter, like unbounded above.
         * By accessing the protected property inside a method, we solve that problem.
         * That's why this function exists.
         * @private
         */
        value: function setUnbounded_() {
          this.foundation_.setUnbounded(this.unbounded_);
        }
      }, {
        key: "activate",
        value: function activate() {
          this.foundation_.activate();
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
        /**
         * @return {!MDCRippleFoundation}
         * @override
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          return new MDCRippleFoundation$8(MDCRipple.createAdapter(this));
        }
        /** @override */

      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
        }
      }, {
        key: "unbounded",

        /** @return {boolean} */
        get: function get() {
          return this.unbounded_;
        }
        /** @param {boolean} unbounded */
        ,
        set: function set(unbounded) {
          this.unbounded_ = Boolean(unbounded);
          this.setUnbounded_();
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref$isUnbounded = _ref.isUnbounded,
              isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

          var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

          if (isUnbounded !== undefined) {
            ripple.unbounded =
            /** @type {boolean} */
            isUnbounded;
          }

          return ripple;
        }
        /**
         * @param {!RippleCapableSurface} instance
         * @return {!MDCRippleAdapter}
         */

      }, {
        key: "createAdapter",
        value: function createAdapter(instance) {
          var MATCHES = getMatchesProperty$8(HTMLElement.prototype);
          return {
            browserSupportsCssVars: function browserSupportsCssVars() {
              return supportsCssVariables$8(window);
            },
            isUnbounded: function isUnbounded() {
              return instance.unbounded;
            },
            isSurfaceActive: function isSurfaceActive() {
              return instance.root_[MATCHES](':active');
            },
            isSurfaceDisabled: function isSurfaceDisabled() {
              return instance.disabled;
            },
            addClass: function addClass(className) {
              return instance.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return instance.root_.classList.remove(className);
            },
            containsEventTarget: function containsEventTarget(target) {
              return instance.root_.contains(target);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return instance.root_.addEventListener(evtType, handler, applyPassive$9());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return instance.root_.removeEventListener(evtType, handler, applyPassive$9());
            },
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.addEventListener(evtType, handler, applyPassive$9());
            },
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.removeEventListener(evtType, handler, applyPassive$9());
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return instance.root_.style.setProperty(varName, value);
            },
            computeBoundingRect: function computeBoundingRect() {
              return instance.root_.getBoundingClientRect();
            },
            getWindowPageOffset: function getWindowPageOffset() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            }
          };
        }
      }]);

      return MDCRipple;
    }(MDCComponent$f);

    /**
     * @record
     */

    var MDCSelectionControl$2 =
    /*#__PURE__*/
    function () {
      function MDCSelectionControl() {
        _classCallCheck$h(this, MDCSelectionControl);
      }

      _createClass$h(MDCSelectionControl, [{
        key: "ripple",

        /** @return {?MDCRipple} */
        get: function get() {}
      }]);

      return MDCSelectionControl;
    }();

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Radio. Provides an interface for managing
     * - classes
     * - dom
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */

    var MDCRadioAdapter =
    /*#__PURE__*/
    function () {
      function MDCRadioAdapter() {
        _classCallCheck$h(this, MDCRadioAdapter);
      }

      _createClass$h(MDCRadioAdapter, [{
        key: "addClass",

        /** @param {string} className */
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @return {!MDCSelectionControlState} */

      }, {
        key: "getNativeControl",
        value: function getNativeControl() {}
      }]);

      return MDCRadioAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var strings$1$9 = {
      NATIVE_CONTROL_SELECTOR: '.mdc-radio__native-control'
    };
    /** @enum {string} */

    var cssClasses$1$9 = {
      ROOT: 'mdc-radio',
      DISABLED: 'mdc-radio--disabled'
    };

    /**
     * @extends {MDCFoundation<!MDCRadioAdapter>}
     */

    var MDCRadioFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$h(MDCRadioFoundation, _MDCFoundation);

      function MDCRadioFoundation() {
        _classCallCheck$h(this, MDCRadioFoundation);

        return _possibleConstructorReturn$h(this, _getPrototypeOf$h(MDCRadioFoundation).apply(this, arguments));
      }

      _createClass$h(MDCRadioFoundation, [{
        key: "isChecked",

        /** @return {boolean} */
        value: function isChecked() {
          return this.getNativeControl_().checked;
        }
        /** @param {boolean} checked */

      }, {
        key: "setChecked",
        value: function setChecked(checked) {
          this.getNativeControl_().checked = checked;
        }
        /** @return {boolean} */

      }, {
        key: "isDisabled",
        value: function isDisabled() {
          return this.getNativeControl_().disabled;
        }
        /** @param {boolean} disabled */

      }, {
        key: "setDisabled",
        value: function setDisabled(disabled) {
          var DISABLED = MDCRadioFoundation.cssClasses.DISABLED;
          this.getNativeControl_().disabled = disabled;

          if (disabled) {
            this.adapter_.addClass(DISABLED);
          } else {
            this.adapter_.removeClass(DISABLED);
          }
        }
        /** @return {?string} */

      }, {
        key: "getValue",
        value: function getValue() {
          return this.getNativeControl_().value;
        }
        /** @param {?string} value */

      }, {
        key: "setValue",
        value: function setValue(value) {
          this.getNativeControl_().value = value;
        }
        /**
         * @return {!MDCSelectionControlState}
         * @private
         */

      }, {
        key: "getNativeControl_",
        value: function getNativeControl_() {
          return this.adapter_.getNativeControl() || {
            checked: false,
            disabled: false,
            value: null
          };
        }
      }], [{
        key: "cssClasses",

        /** @return enum {cssClasses} */
        get: function get() {
          return cssClasses$1$9;
        }
        /** @return enum {strings} */

      }, {
        key: "strings",
        get: function get() {
          return strings$1$9;
        }
        /** @return {!MDCRadioAdapter} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCRadioAdapter} */
            {
              addClass: function addClass()
              /* className: string */
              {},
              removeClass: function removeClass()
              /* className: string */
              {},
              getNativeControl: function getNativeControl()
              /* !MDCSelectionControlState */
              {}
            }
          );
        }
      }]);

      return MDCRadioFoundation;
    }(MDCFoundation$g);

    /**
     * @extends MDCComponent<!MDCRadioFoundation>
     * @implements {MDCSelectionControl}
     */

    var MDCRadio =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$h(MDCRadio, _MDCComponent);

      _createClass$h(MDCRadio, [{
        key: "checked",

        /** @return {boolean} */
        get: function get$$1() {
          return this.foundation_.isChecked();
        }
        /** @param {boolean} checked */
        ,
        set: function set(checked) {
          this.foundation_.setChecked(checked);
        }
        /** @return {boolean} */

      }, {
        key: "disabled",
        get: function get$$1() {
          return this.foundation_.isDisabled();
        }
        /** @param {boolean} disabled */
        ,
        set: function set(disabled) {
          this.foundation_.setDisabled(disabled);
        }
        /** @return {?string} */

      }, {
        key: "value",
        get: function get$$1() {
          return this.foundation_.getValue();
        }
        /** @param {?string} value */
        ,
        set: function set(value) {
          this.foundation_.setValue(value);
        }
        /** @return {!MDCRipple} */

      }, {
        key: "ripple",
        get: function get$$1() {
          return this.ripple_;
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCRadio(root);
        }
      }]);

      function MDCRadio() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$h(this, MDCRadio);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$h(this, (_getPrototypeOf2 = _getPrototypeOf$h(MDCRadio)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {!MDCRipple} */

        _this.ripple_ = _this.initRipple_();
        return _this;
      }
      /**
       * @return {!MDCRipple}
       * @private
       */


      _createClass$h(MDCRadio, [{
        key: "initRipple_",
        value: function initRipple_() {
          var _this2 = this;

          var adapter = Object.assign(MDCRipple$8.createAdapter(this), {
            isUnbounded: function isUnbounded() {
              return true;
            },
            // Radio buttons technically go "active" whenever there is *any* keyboard interaction. This is not the
            // UI we desire.
            isSurfaceActive: function isSurfaceActive() {
              return false;
            },
            registerInteractionHandler: function registerInteractionHandler(type, handler) {
              return _this2.nativeControl_.addEventListener(type, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
              return _this2.nativeControl_.removeEventListener(type, handler);
            }
          });
          var foundation = new MDCRippleFoundation$8(adapter);
          return new MDCRipple$8(this.root_, foundation);
        }
        /**
         * Returns the state of the native control element, or null if the native control element is not present.
         * @return {?MDCSelectionControlState}
         * @private
         */

      }, {
        key: "destroy",
        value: function destroy() {
          this.ripple_.destroy();

          _get$8(_getPrototypeOf$h(MDCRadio.prototype), "destroy", this).call(this);
        }
        /** @return {!MDCRadioFoundation} */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this3 = this;

          return new MDCRadioFoundation({
            addClass: function addClass(className) {
              return _this3.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this3.root_.classList.remove(className);
            },
            getNativeControl: function getNativeControl() {
              return _this3.root_.querySelector(MDCRadioFoundation.strings.NATIVE_CONTROL_SELECTOR);
            }
          });
        }
      }, {
        key: "nativeControl_",
        get: function get$$1() {
          var NATIVE_CONTROL_SELECTOR = MDCRadioFoundation.strings.NATIVE_CONTROL_SELECTOR;
          var el =
          /** @type {?MDCSelectionControlState} */
          this.root_.querySelector(NATIVE_CONTROL_SELECTOR);
          return el;
        }
      }]);

      return MDCRadio;
    }(MDCComponent$f);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ nextUniqueId$4 = 0;
    var /** @type {?} */ MDC_RADIO_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return MdcRadio; }),
        multi: true
    };
    /**
     * Change event object emitted by MdcRadio.
     */
    var   /**
     * Change event object emitted by MdcRadio.
     */
    MdcRadioChange = /** @class */ (function () {
        function MdcRadioChange(source, value, checked) {
            this.source = source;
            this.value = value;
            this.checked = checked;
        }
        return MdcRadioChange;
    }());
    var MdcRadio = /** @class */ (function () {
        function MdcRadio(_changeDetectorRef, _renderer, elementRef, ripple) {
            var _this = this;
            this._changeDetectorRef = _changeDetectorRef;
            this._renderer = _renderer;
            this.elementRef = elementRef;
            this.ripple = ripple;
            this.componentInstance = MdcRadio;
            this._uniqueId = "mdc-radio-" + ++nextUniqueId$4;
            this.id = this._uniqueId;
            this.name = null;
            this.tabIndex = 0;
            this.ariaLabel = '';
            this.ariaLabelledby = null;
            this._disabled = false;
            this.change = new core.EventEmitter();
            this.isHostClass = true;
            this._mdcAdapter = {
                addClass: function (className) { return _this._renderer.addClass(_this._getHostElement(), className); },
                removeClass: function (className) { return _this._renderer.removeClass(_this._getHostElement(), className); },
                getNativeControl: function () { return _this.inputEl.nativeElement; }
            };
            this._foundation = new MDCRadioFoundation(this._mdcAdapter);
            /**
             * View -> model callback called when value changes
             */
            this._onChange = function () { };
            /**
             * View -> model callback called when radio has been touched
             */
            this._onTouched = function () { };
        }
        Object.defineProperty(MdcRadio.prototype, "inputId", {
            get: /**
             * @return {?}
             */
            function () { return (this.id || this._uniqueId) + "-input"; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcRadio.prototype, "value", {
            get: /**
             * @return {?}
             */
            function () { return this._value; },
            set: /**
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                this.setValue(newValue);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcRadio.prototype, "checked", {
            get: /**
             * @return {?}
             */
            function () { return this._checked; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setChecked(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcRadio.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setDisabledState(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcRadio.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this._foundation.init();
            this.ripple.attachTo(this._getHostElement(), true, this.inputEl.nativeElement);
        };
        /**
         * @return {?}
         */
        MdcRadio.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.ripple.destroy();
            this._foundation.destroy();
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcRadio.prototype.onInputClick = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            evt.stopPropagation();
            this._onTouched();
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcRadio.prototype.onChange = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            evt.stopPropagation();
            this.setChecked(this.inputEl.nativeElement.checked);
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MdcRadio.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.setChecked(value);
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcRadio.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcRadio.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onTouched = fn;
        };
        /**
         * @param {?} disabled
         * @return {?}
         */
        MdcRadio.prototype.setDisabled = /**
         * @param {?} disabled
         * @return {?}
         */
        function (disabled) {
            this.setDisabledState(disabled);
        };
        /**
         * @param {?} disabled
         * @return {?}
         */
        MdcRadio.prototype.setDisabledState = /**
         * @param {?} disabled
         * @return {?}
         */
        function (disabled) {
            this._disabled = disabled;
            this._foundation.setDisabled(disabled);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} checked
         * @return {?}
         */
        MdcRadio.prototype.setChecked = /**
         * @param {?} checked
         * @return {?}
         */
        function (checked) {
            this._checked = checked;
            if (checked) {
                this._onChange(this.checked);
            }
            if (checked || checked == null) {
                this.change.emit(new MdcRadioChange(this, this.getValue(), this.checked));
            }
            this._foundation.setChecked(checked);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @return {?}
         */
        MdcRadio.prototype.getValue = /**
         * @return {?}
         */
        function () {
            return this._foundation.getValue();
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MdcRadio.prototype.setValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._value = value;
            this._foundation.setValue(value);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @return {?}
         */
        MdcRadio.prototype.isChecked = /**
         * @return {?}
         */
        function () {
            return this._foundation.isChecked();
        };
        /**
         * @return {?}
         */
        MdcRadio.prototype.focus = /**
         * @return {?}
         */
        function () {
            this.inputEl.nativeElement.focus();
        };
        /**
         * @return {?}
         */
        MdcRadio.prototype.isDisabled = /**
         * @return {?}
         */
        function () {
            return this._foundation.isDisabled();
        };
        /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        MdcRadio.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcRadio.decorators = [
            { type: core.Component, args: [{selector: 'mdc-radio',
                        host: {
                            '[id]': 'id',
                        },
                        template: "\n  <input type=\"radio\"\n    #inputEl\n    class=\"mdc-radio__native-control\"\n    [id]=\"inputId\"\n    [name]=\"name\"\n    [tabIndex]=\"tabIndex\"\n    [attr.aria-label]=\"ariaLabel\"\n    [attr.aria-labelledby]=\"ariaLabelledby\"\n    [disabled]=\"disabled\"\n    [checked]=\"checked\"\n    [attr.value]=\"value\"\n    (click)=\"onInputClick($event)\"\n    (change)=\"onChange($event)\" />\n    <div class=\"mdc-radio__background\">\n      <div class=\"mdc-radio__outer-circle\"></div>\n      <div class=\"mdc-radio__inner-circle\"></div>\n    </div>\n  ",
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [
                            MDC_RADIO_CONTROL_VALUE_ACCESSOR,
                            MdcRipple,
                            EventRegistry,
                            [{ provide: MdcFormFieldControl, useExisting: MdcRadio }]
                        ]
                    },] },
        ];
        /** @nocollapse */
        MdcRadio.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.Renderer2 },
            { type: core.ElementRef },
            { type: MdcRipple }
        ]; };
        MdcRadio.propDecorators = {
            id: [{ type: core.Input }],
            name: [{ type: core.Input }],
            tabIndex: [{ type: core.Input }],
            ariaLabel: [{ type: core.Input, args: ['aria-label',] }],
            ariaLabelledby: [{ type: core.Input, args: ['aria-labelledby',] }],
            value: [{ type: core.Input }],
            checked: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            change: [{ type: core.Output }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-radio',] }],
            inputEl: [{ type: core.ViewChild, args: ['inputEl',] }]
        };
        return MdcRadio;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcRadioModule = /** @class */ (function () {
        function MdcRadioModule() {
        }
        MdcRadioModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [MdcRadio],
                        declarations: [MdcRadio]
                    },] },
        ];
        return MdcRadioModule;
    }());

    function _classCallCheck$i(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$i(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$i(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$i(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$i(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$i(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$i(subClass, superClass);
    }

    function _getPrototypeOf$i(o) {
      _getPrototypeOf$i = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$i(o);
    }

    function _setPrototypeOf$i(o, p) {
      _setPrototypeOf$i = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$i(o, p);
    }

    function _assertThisInitialized$i(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$i(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$i(self);
    }

    function _superPropBase$9(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$i(object);
        if (object === null) break;
      }

      return object;
    }

    function _get$9(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$9 = Reflect.get;
      } else {
        _get$9 = function _get(target, property, receiver) {
          var base = _superPropBase$9(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get$9(target, property, receiver || target);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @template A
     */
    var MDCFoundation$h =
    /*#__PURE__*/
    function () {
      _createClass$i(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$i(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$i(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$g =
    /*#__PURE__*/
    function () {
      _createClass$i(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$h());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$i(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$i(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @license
     * Copyright 2017 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Floating Label.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the floating label into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCFloatingLabelAdapter$1 =
    /*#__PURE__*/
    function () {
      function MDCFloatingLabelAdapter() {
        _classCallCheck$i(this, MDCFloatingLabelAdapter);
      }

      _createClass$i(MDCFloatingLabelAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the label element.
         * @param {string} className
         */
        value: function addClass(className) {}
        /**
         * Removes a class from the label element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Returns the width of the label element.
         * @return {number}
         */

      }, {
        key: "getWidth",
        value: function getWidth() {}
        /**
         * Registers an event listener on the root element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * Deregisters an event listener on the root element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
      }]);

      return MDCFloatingLabelAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var cssClasses$g = {
      LABEL_FLOAT_ABOVE: 'mdc-floating-label--float-above',
      LABEL_SHAKE: 'mdc-floating-label--shake'
    };

    /**
     * @extends {MDCFoundation<!MDCFloatingLabelAdapter>}
     * @final
     */

    var MDCFloatingLabelFoundation$1 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$i(MDCFloatingLabelFoundation, _MDCFoundation);

      _createClass$i(MDCFloatingLabelFoundation, null, [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$g;
        }
        /**
         * {@see MDCFloatingLabelAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCFloatingLabelAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCFloatingLabelAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              getWidth: function getWidth() {},
              registerInteractionHandler: function registerInteractionHandler() {},
              deregisterInteractionHandler: function deregisterInteractionHandler() {}
            }
          );
        }
        /**
         * @param {!MDCFloatingLabelAdapter} adapter
         */

      }]);

      function MDCFloatingLabelFoundation(adapter) {
        var _this;

        _classCallCheck$i(this, MDCFloatingLabelFoundation);

        _this = _possibleConstructorReturn$i(this, _getPrototypeOf$i(MDCFloatingLabelFoundation).call(this, Object.assign(MDCFloatingLabelFoundation.defaultAdapter, adapter)));
        /** @private {function(!Event): undefined} */

        _this.shakeAnimationEndHandler_ = function () {
          return _this.handleShakeAnimationEnd_();
        };

        return _this;
      }

      _createClass$i(MDCFloatingLabelFoundation, [{
        key: "init",
        value: function init() {
          this.adapter_.registerInteractionHandler('animationend', this.shakeAnimationEndHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.adapter_.deregisterInteractionHandler('animationend', this.shakeAnimationEndHandler_);
        }
        /**
         * Returns the width of the label element.
         * @return {number}
         */

      }, {
        key: "getWidth",
        value: function getWidth() {
          return this.adapter_.getWidth();
        }
        /**
         * Styles the label to produce the label shake for errors.
         * @param {boolean} shouldShake adds shake class if true,
         * otherwise removes shake class.
         */

      }, {
        key: "shake",
        value: function shake(shouldShake) {
          var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;

          if (shouldShake) {
            this.adapter_.addClass(LABEL_SHAKE);
          } else {
            this.adapter_.removeClass(LABEL_SHAKE);
          }
        }
        /**
         * Styles the label to float or dock.
         * @param {boolean} shouldFloat adds float class if true, otherwise remove
         * float and shake class to dock label.
         */

      }, {
        key: "float",
        value: function float(shouldFloat) {
          var _MDCFloatingLabelFoun = MDCFloatingLabelFoundation.cssClasses,
              LABEL_FLOAT_ABOVE = _MDCFloatingLabelFoun.LABEL_FLOAT_ABOVE,
              LABEL_SHAKE = _MDCFloatingLabelFoun.LABEL_SHAKE;

          if (shouldFloat) {
            this.adapter_.addClass(LABEL_FLOAT_ABOVE);
          } else {
            this.adapter_.removeClass(LABEL_FLOAT_ABOVE);
            this.adapter_.removeClass(LABEL_SHAKE);
          }
        }
        /**
         * Handles an interaction event on the root element.
         */

      }, {
        key: "handleShakeAnimationEnd_",
        value: function handleShakeAnimationEnd_() {
          var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;
          this.adapter_.removeClass(LABEL_SHAKE);
        }
      }]);

      return MDCFloatingLabelFoundation;
    }(MDCFoundation$h);

    /**
     * @extends {MDCComponent<!MDCFloatingLabelFoundation>}
     * @final
     */

    var MDCFloatingLabel$1 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$i(MDCFloatingLabel, _MDCComponent);

      function MDCFloatingLabel() {
        _classCallCheck$i(this, MDCFloatingLabel);

        return _possibleConstructorReturn$i(this, _getPrototypeOf$i(MDCFloatingLabel).apply(this, arguments));
      }

      _createClass$i(MDCFloatingLabel, [{
        key: "shake",

        /**
         * Styles the label to produce the label shake for errors.
         * @param {boolean} shouldShake styles the label to shake by adding shake class
         * if true, otherwise will stop shaking by removing shake class.
         */
        value: function shake(shouldShake) {
          this.foundation_.shake(shouldShake);
        }
        /**
         * Styles label to float/dock.
         * @param {boolean} shouldFloat styles the label to float by adding float class
         * if true, otherwise docks the label by removing the float class.
         */

      }, {
        key: "float",
        value: function float(shouldFloat) {
          this.foundation_.float(shouldFloat);
        }
        /**
         * @return {number}
         */

      }, {
        key: "getWidth",
        value: function getWidth() {
          return this.foundation_.getWidth();
        }
        /**
         * @return {!MDCFloatingLabelFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCFloatingLabelFoundation$1({
            addClass: function addClass(className) {
              return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this.root_.classList.remove(className);
            },
            getWidth: function getWidth() {
              return _this.root_.offsetWidth;
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return _this.root_.addEventListener(evtType, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return _this.root_.removeEventListener(evtType, handler);
            }
          });
        }
      }], [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCFloatingLabel}
         */
        value: function attachTo(root) {
          return new MDCFloatingLabel(root);
        }
      }]);

      return MDCFloatingLabel;
    }(MDCComponent$g);

    /**
     * @license
     * Copyright 2018 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC TextField Line Ripple.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the line ripple into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCLineRippleAdapter$1 =
    /*#__PURE__*/
    function () {
      function MDCLineRippleAdapter() {
        _classCallCheck$i(this, MDCLineRippleAdapter);
      }

      _createClass$i(MDCLineRippleAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the line ripple element.
         * @param {string} className
         */
        value: function addClass(className) {}
        /**
         * Removes a class from the line ripple element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * @param {string} className
         * @return {boolean}
         */

      }, {
        key: "hasClass",
        value: function hasClass(className) {}
        /**
         * Sets the style property with propertyName to value on the root element.
         * @param {string} propertyName
         * @param {string} value
         */

      }, {
        key: "setStyle",
        value: function setStyle(propertyName, value) {}
        /**
         * Registers an event listener on the line ripple element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerEventHandler",
        value: function registerEventHandler(evtType, handler) {}
        /**
         * Deregisters an event listener on the line ripple element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterEventHandler",
        value: function deregisterEventHandler(evtType, handler) {}
      }]);

      return MDCLineRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var cssClasses$1$a = {
      LINE_RIPPLE_ACTIVE: 'mdc-line-ripple--active',
      LINE_RIPPLE_DEACTIVATING: 'mdc-line-ripple--deactivating'
    };

    /**
     * @extends {MDCFoundation<!MDCLineRippleAdapter>}
     * @final
     */

    var MDCLineRippleFoundation$1 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$i(MDCLineRippleFoundation, _MDCFoundation);

      _createClass$i(MDCLineRippleFoundation, null, [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$1$a;
        }
        /**
         * {@see MDCLineRippleAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCLineRippleAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCLineRippleAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              hasClass: function hasClass() {},
              setStyle: function setStyle() {},
              registerEventHandler: function registerEventHandler() {},
              deregisterEventHandler: function deregisterEventHandler() {}
            }
          );
        }
        /**
         * @param {!MDCLineRippleAdapter=} adapter
         */

      }]);

      function MDCLineRippleFoundation() {
        var _this;

        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] :
        /** @type {!MDCLineRippleAdapter} */
        {};

        _classCallCheck$i(this, MDCLineRippleFoundation);

        _this = _possibleConstructorReturn$i(this, _getPrototypeOf$i(MDCLineRippleFoundation).call(this, Object.assign(MDCLineRippleFoundation.defaultAdapter, adapter)));
        /** @private {function(!Event): undefined} */

        _this.transitionEndHandler_ = function (evt) {
          return _this.handleTransitionEnd(evt);
        };

        return _this;
      }

      _createClass$i(MDCLineRippleFoundation, [{
        key: "init",
        value: function init() {
          this.adapter_.registerEventHandler('transitionend', this.transitionEndHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.adapter_.deregisterEventHandler('transitionend', this.transitionEndHandler_);
        }
        /**
         * Activates the line ripple
         */

      }, {
        key: "activate",
        value: function activate() {
          this.adapter_.removeClass(cssClasses$1$a.LINE_RIPPLE_DEACTIVATING);
          this.adapter_.addClass(cssClasses$1$a.LINE_RIPPLE_ACTIVE);
        }
        /**
         * Sets the center of the ripple animation to the given X coordinate.
         * @param {number} xCoordinate
         */

      }, {
        key: "setRippleCenter",
        value: function setRippleCenter(xCoordinate) {
          this.adapter_.setStyle('transform-origin', "".concat(xCoordinate, "px center"));
        }
        /**
         * Deactivates the line ripple
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          this.adapter_.addClass(cssClasses$1$a.LINE_RIPPLE_DEACTIVATING);
        }
        /**
         * Handles a transition end event
         * @param {!Event} evt
         */

      }, {
        key: "handleTransitionEnd",
        value: function handleTransitionEnd(evt) {
          // Wait for the line ripple to be either transparent or opaque
          // before emitting the animation end event
          var isDeactivating = this.adapter_.hasClass(cssClasses$1$a.LINE_RIPPLE_DEACTIVATING);

          if (evt.propertyName === 'opacity') {
            if (isDeactivating) {
              this.adapter_.removeClass(cssClasses$1$a.LINE_RIPPLE_ACTIVE);
              this.adapter_.removeClass(cssClasses$1$a.LINE_RIPPLE_DEACTIVATING);
            }
          }
        }
      }]);

      return MDCLineRippleFoundation;
    }(MDCFoundation$h);

    /**
     * @extends {MDCComponent<!MDCLineRippleFoundation>}
     * @final
     */

    var MDCLineRipple$1 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$i(MDCLineRipple, _MDCComponent);

      function MDCLineRipple() {
        _classCallCheck$i(this, MDCLineRipple);

        return _possibleConstructorReturn$i(this, _getPrototypeOf$i(MDCLineRipple).apply(this, arguments));
      }

      _createClass$i(MDCLineRipple, [{
        key: "activate",

        /**
         * Activates the line ripple
         */
        value: function activate() {
          this.foundation_.activate();
        }
        /**
         * Deactivates the line ripple
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
        /**
         * Sets the transform origin given a user's click location. The `rippleCenter` is the
         * x-coordinate of the middle of the ripple.
         * @param {number} xCoordinate
         */

      }, {
        key: "setRippleCenter",
        value: function setRippleCenter(xCoordinate) {
          this.foundation_.setRippleCenter(xCoordinate);
        }
        /**
         * @return {!MDCLineRippleFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCLineRippleFoundation$1(
          /** @type {!MDCLineRippleAdapter} */
          Object.assign({
            addClass: function addClass(className) {
              return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
              return _this.root_.classList.contains(className);
            },
            setStyle: function setStyle(propertyName, value) {
              return _this.root_.style[propertyName] = value;
            },
            registerEventHandler: function registerEventHandler(evtType, handler) {
              return _this.root_.addEventListener(evtType, handler);
            },
            deregisterEventHandler: function deregisterEventHandler(evtType, handler) {
              return _this.root_.removeEventListener(evtType, handler);
            }
          }));
        }
      }], [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCLineRipple}
         */
        value: function attachTo(root) {
          return new MDCLineRipple(root);
        }
      }]);

      return MDCLineRipple;
    }(MDCComponent$g);

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Ripple. Provides an interface for managing
     * - classes
     * - dom
     * - CSS variables
     * - position
     * - dimensions
     * - scroll position
     * - event handlers
     * - unbounded, active and disabled states
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCRippleAdapter$9 =
    /*#__PURE__*/
    function () {
      function MDCRippleAdapter() {
        _classCallCheck$i(this, MDCRippleAdapter);
      }

      _createClass$i(MDCRippleAdapter, [{
        key: "browserSupportsCssVars",

        /** @return {boolean} */
        value: function browserSupportsCssVars() {}
        /** @return {boolean} */

      }, {
        key: "isUnbounded",
        value: function isUnbounded() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceActive",
        value: function isSurfaceActive() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceDisabled",
        value: function isSurfaceDisabled() {}
        /** @param {string} className */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @param {!EventTarget} target */

      }, {
        key: "containsEventTarget",
        value: function containsEventTarget(target) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerDocumentInteractionHandler",
        value: function registerDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterDocumentInteractionHandler",
        value: function deregisterDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /**
         * @param {string} varName
         * @param {?number|string} value
         */

      }, {
        key: "updateCssVariable",
        value: function updateCssVariable(varName, value) {}
        /** @return {!ClientRect} */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}
        /** @return {{x: number, y: number}} */

      }, {
        key: "getWindowPageOffset",
        value: function getWindowPageOffset() {}
      }]);

      return MDCRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var cssClasses$2$2 = {
      // Ripple is a special case where the "root" component is really a "mixin" of sorts,
      // given that it's an 'upgrade' to an existing component. That being said it is the root
      // CSS class that all other CSS classes derive from.
      ROOT: 'mdc-ripple-upgraded',
      UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
      BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
      FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
      FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
    };
    var strings$f = {
      VAR_LEFT: '--mdc-ripple-left',
      VAR_TOP: '--mdc-ripple-top',
      VAR_FG_SIZE: '--mdc-ripple-fg-size',
      VAR_FG_SCALE: '--mdc-ripple-fg-scale',
      VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
      VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
    };
    var numbers$a = {
      PADDING: 10,
      INITIAL_ORIGIN_SCALE: 0.6,
      DEACTIVATION_TIMEOUT_MS: 225,
      // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
      FG_DEACTIVATION_MS: 150,
      // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
      TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

    };

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
     * @private {boolean|undefined}
     */
    var supportsCssVariables_$9;
    /**
     * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
     * @private {boolean|undefined}
     */

    var supportsPassive_$a;
    /**
     * @param {!Window} windowObj
     * @return {boolean}
     */

    function detectEdgePseudoVarBug$9(windowObj) {
      // Detect versions of Edge with buggy var() support
      // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
      var document = windowObj.document;
      var node = document.createElement('div');
      node.className = 'mdc-ripple-surface--test-edge-var-bug';
      document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
      // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
      // but Firefox is known to support CSS custom properties correctly.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

      var computedStyle = windowObj.getComputedStyle(node);
      var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
      node.remove();
      return hasPseudoVarBug;
    }
    /**
     * @param {!Window} windowObj
     * @param {boolean=} forceRefresh
     * @return {boolean|undefined}
     */


    function supportsCssVariables$9(windowObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var supportsCssVariables = supportsCssVariables_$9;

      if (typeof supportsCssVariables_$9 === 'boolean' && !forceRefresh) {
        return supportsCssVariables;
      }

      var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

      if (!supportsFunctionPresent) {
        return;
      }

      var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
      // See: README section on Safari

      var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

      if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVariables = !detectEdgePseudoVarBug$9(windowObj);
      } else {
        supportsCssVariables = false;
      }

      if (!forceRefresh) {
        supportsCssVariables_$9 = supportsCssVariables;
      }

      return supportsCssVariables;
    } //

    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|{passive: boolean}}
     */


    function applyPassive$a() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_$a === undefined || forceRefresh) {
        var isSupported = false;

        try {
          globalObj.document.addEventListener('test', null, {
            get passive() {
              isSupported = true;
            }

          });
        } catch (e) {}

        supportsPassive_$a = isSupported;
      }

      return supportsPassive_$a ? {
        passive: true
      } : false;
    }
    /**
     * @param {!Object} HTMLElementPrototype
     * @return {!Array<string>}
     */


    function getMatchesProperty$9(HTMLElementPrototype) {
      return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(function (p) {
        return p in HTMLElementPrototype;
      }).pop();
    }
    /**
     * @param {!Event} ev
     * @param {{x: number, y: number}} pageOffset
     * @param {!ClientRect} clientRect
     * @return {{x: number, y: number}}
     */


    function getNormalizedEventCoords$9(ev, pageOffset, clientRect) {
      var x = pageOffset.x,
          y = pageOffset.y;
      var documentX = x + clientRect.left;
      var documentY = y + clientRect.top;
      var normalizedX;
      var normalizedY; // Determine touch point relative to the ripple container.

      if (ev.type === 'touchstart') {
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
      } else {
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
      }

      return {
        x: normalizedX,
        y: normalizedY
      };
    }

    var ACTIVATION_EVENT_TYPES$9 = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

    var POINTER_DEACTIVATION_EVENT_TYPES$9 = ['touchend', 'pointerup', 'mouseup']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

    /** @type {!Array<!EventTarget>} */

    var activatedTargets$9 = [];
    /**
     * @extends {MDCFoundation<!MDCRippleAdapter>}
     */

    var MDCRippleFoundation$9 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$i(MDCRippleFoundation, _MDCFoundation);

      _createClass$i(MDCRippleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$2$2;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$f;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers$a;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            browserSupportsCssVars: function browserSupportsCssVars()
            /* boolean - cached */
            {},
            isUnbounded: function isUnbounded()
            /* boolean */
            {},
            isSurfaceActive: function isSurfaceActive()
            /* boolean */
            {},
            isSurfaceDisabled: function isSurfaceDisabled()
            /* boolean */
            {},
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            containsEventTarget: function containsEventTarget()
            /* target: !EventTarget */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            updateCssVariable: function updateCssVariable()
            /* varName: string, value: string */
            {},
            computeBoundingRect: function computeBoundingRect()
            /* ClientRect */
            {},
            getWindowPageOffset: function getWindowPageOffset()
            /* {x: number, y: number} */
            {}
          };
        }
      }]);

      function MDCRippleFoundation(adapter) {
        var _this;

        _classCallCheck$i(this, MDCRippleFoundation);

        _this = _possibleConstructorReturn$i(this, _getPrototypeOf$i(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
        /** @private {number} */

        _this.layoutFrame_ = 0;
        /** @private {!ClientRect} */

        _this.frame_ =
        /** @type {!ClientRect} */
        {
          width: 0,
          height: 0
        };
        /** @private {!ActivationStateType} */

        _this.activationState_ = _this.defaultActivationState_();
        /** @private {number} */

        _this.initialSize_ = 0;
        /** @private {number} */

        _this.maxRadius_ = 0;
        /** @private {function(!Event)} */

        _this.activateHandler_ = function (e) {
          return _this.activate_(e);
        };
        /** @private {function(!Event)} */


        _this.deactivateHandler_ = function (e) {
          return _this.deactivate_(e);
        };
        /** @private {function(?Event=)} */


        _this.focusHandler_ = function () {
          return _this.handleFocus();
        };
        /** @private {function(?Event=)} */


        _this.blurHandler_ = function () {
          return _this.handleBlur();
        };
        /** @private {!Function} */


        _this.resizeHandler_ = function () {
          return _this.layout();
        };
        /** @private {{left: number, top:number}} */


        _this.unboundedCoords_ = {
          left: 0,
          top: 0
        };
        /** @private {number} */

        _this.fgScale_ = 0;
        /** @private {number} */

        _this.activationTimer_ = 0;
        /** @private {number} */

        _this.fgDeactivationRemovalTimer_ = 0;
        /** @private {boolean} */

        _this.activationAnimationHasEnded_ = false;
        /** @private {!Function} */

        _this.activationTimerCallback_ = function () {
          _this.activationAnimationHasEnded_ = true;

          _this.runDeactivationUXLogicIfReady_();
        };
        /** @private {?Event} */


        _this.previousActivationEvent_ = null;
        return _this;
      }
      /**
       * We compute this property so that we are not querying information about the client
       * until the point in time where the foundation requests it. This prevents scenarios where
       * client-side feature-detection may happen too early, such as when components are rendered on the server
       * and then initialized at mount time on the client.
       * @return {boolean}
       * @private
       */


      _createClass$i(MDCRippleFoundation, [{
        key: "isSupported_",
        value: function isSupported_() {
          return this.adapter_.browserSupportsCssVars();
        }
        /**
         * @return {!ActivationStateType}
         */

      }, {
        key: "defaultActivationState_",
        value: function defaultActivationState_() {
          return {
            isActivated: false,
            hasDeactivationUXRun: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
            activationEvent: null,
            isProgrammatic: false
          };
        }
        /** @override */

      }, {
        key: "init",
        value: function init() {
          var _this2 = this;

          if (!this.isSupported_()) {
            return;
          }

          this.registerRootHandlers_();
          var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$.ROOT,
              UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
          requestAnimationFrame(function () {
            _this2.adapter_.addClass(ROOT);

            if (_this2.adapter_.isUnbounded()) {
              _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


              _this2.layoutInternal_();
            }
          });
        }
        /** @override */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          if (!this.isSupported_()) {
            return;
          }

          if (this.activationTimer_) {
            clearTimeout(this.activationTimer_);
            this.activationTimer_ = 0;
            var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
            this.adapter_.removeClass(FG_ACTIVATION);
          }

          this.deregisterRootHandlers_();
          this.deregisterDeactivationHandlers_();
          var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$2.ROOT,
              UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
          requestAnimationFrame(function () {
            _this3.adapter_.removeClass(ROOT);

            _this3.adapter_.removeClass(UNBOUNDED);

            _this3.removeCssVars_();
          });
        }
        /** @private */

      }, {
        key: "registerRootHandlers_",
        value: function registerRootHandlers_() {
          var _this4 = this;

          ACTIVATION_EVENT_TYPES$9.forEach(function (type) {
            _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
          });
          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.registerResizeHandler(this.resizeHandler_);
          }
        }
        /**
         * @param {!Event} e
         * @private
         */

      }, {
        key: "registerDeactivationHandlers_",
        value: function registerDeactivationHandlers_(e) {
          var _this5 = this;

          if (e.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
          } else {
            POINTER_DEACTIVATION_EVENT_TYPES$9.forEach(function (type) {
              _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
            });
          }
        }
        /** @private */

      }, {
        key: "deregisterRootHandlers_",
        value: function deregisterRootHandlers_() {
          var _this6 = this;

          ACTIVATION_EVENT_TYPES$9.forEach(function (type) {
            _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
          });
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          }
        }
        /** @private */

      }, {
        key: "deregisterDeactivationHandlers_",
        value: function deregisterDeactivationHandlers_() {
          var _this7 = this;

          this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
          POINTER_DEACTIVATION_EVENT_TYPES$9.forEach(function (type) {
            _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
          });
        }
        /** @private */

      }, {
        key: "removeCssVars_",
        value: function removeCssVars_() {
          var _this8 = this;

          var strings$$1 = MDCRippleFoundation.strings;
          Object.keys(strings$$1).forEach(function (k) {
            if (k.indexOf('VAR_') === 0) {
              _this8.adapter_.updateCssVariable(strings$$1[k], null);
            }
          });
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "activate_",
        value: function activate_(e) {
          var _this9 = this;

          if (this.adapter_.isSurfaceDisabled()) {
            return;
          }

          var activationState = this.activationState_;

          if (activationState.isActivated) {
            return;
          } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


          var previousActivationEvent = this.previousActivationEvent_;
          var isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;

          if (isSameInteraction) {
            return;
          }

          activationState.isActivated = true;
          activationState.isProgrammatic = e === null;
          activationState.activationEvent = e;
          activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';
          var hasActivatedChild = e && activatedTargets$9.length > 0 && activatedTargets$9.some(function (target) {
            return _this9.adapter_.containsEventTarget(target);
          });

          if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
          }

          if (e) {
            activatedTargets$9.push(
            /** @type {!EventTarget} */
            e.target);
            this.registerDeactivationHandlers_(e);
          }

          activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

          if (activationState.wasElementMadeActive) {
            this.animateActivation_();
          }

          requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets$9 = [];

            if (!activationState.wasElementMadeActive && (e.key === ' ' || e.keyCode === 32)) {
              // If space was pressed, try again within an rAF call to detect :active, because different UAs report
              // active states inconsistently when they're called within event handling code:
              // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
              // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
              // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
              // variable is set within a rAF callback for a submit button interaction (#2241).
              activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

              if (activationState.wasElementMadeActive) {
                _this9.animateActivation_();
              }
            }

            if (!activationState.wasElementMadeActive) {
              // Reset activation state immediately if element was not made active.
              _this9.activationState_ = _this9.defaultActivationState_();
            }
          });
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "checkElementMadeActive_",
        value: function checkElementMadeActive_(e) {
          return e && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
        }
        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: "activate",
        value: function activate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          this.activate_(event);
        }
        /** @private */

      }, {
        key: "animateActivation_",
        value: function animateActivation_() {
          var _this10 = this;

          var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
              VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
              VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
          var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
              FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
              FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
          var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
          this.layoutInternal_();
          var translateStart = '';
          var translateEnd = '';

          if (!this.adapter_.isUnbounded()) {
            var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
                startPoint = _this$getFgTranslatio.startPoint,
                endPoint = _this$getFgTranslatio.endPoint;

            translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
            translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
          }

          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

          clearTimeout(this.activationTimer_);
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.rmBoundedActivationClasses_();
          this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

          this.adapter_.computeBoundingRect();
          this.adapter_.addClass(FG_ACTIVATION);
          this.activationTimer_ = setTimeout(function () {
            return _this10.activationTimerCallback_();
          }, DEACTIVATION_TIMEOUT_MS);
        }
        /**
         * @private
         * @return {{startPoint: PointType, endPoint: PointType}}
         */

      }, {
        key: "getFgTranslationCoordinates_",
        value: function getFgTranslationCoordinates_() {
          var _this$activationState = this.activationState_,
              activationEvent = _this$activationState.activationEvent,
              wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
          var startPoint;

          if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords$9(
            /** @type {!Event} */
            activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
          } else {
            startPoint = {
              x: this.frame_.width / 2,
              y: this.frame_.height / 2
            };
          } // Center the element around the start point.


          startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
          };
          var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
          };
          return {
            startPoint: startPoint,
            endPoint: endPoint
          };
        }
        /** @private */

      }, {
        key: "runDeactivationUXLogicIfReady_",
        value: function runDeactivationUXLogicIfReady_() {
          var _this11 = this;

          // This method is called both when a pointing device is released, and when the activation animation ends.
          // The deactivation animation should only run after both of those occur.
          var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
          var _this$activationState2 = this.activationState_,
              hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
              isActivated = _this$activationState2.isActivated;
          var activationHasEnded = hasDeactivationUXRun || !isActivated;

          if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
              _this11.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers$a.FG_DEACTIVATION_MS);
          }
        }
        /** @private */

      }, {
        key: "rmBoundedActivationClasses_",
        value: function rmBoundedActivationClasses_() {
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
          this.adapter_.removeClass(FG_ACTIVATION);
          this.activationAnimationHasEnded_ = false;
          this.adapter_.computeBoundingRect();
        }
      }, {
        key: "resetActivationState_",
        value: function resetActivationState_() {
          var _this12 = this;

          this.previousActivationEvent_ = this.activationState_.activationEvent;
          this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
          // Store the previous event until it's safe to assume that subsequent events are for new interactions.

          setTimeout(function () {
            return _this12.previousActivationEvent_ = null;
          }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "deactivate_",
        value: function deactivate_(e) {
          var _this13 = this;

          var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

          if (!activationState.isActivated) {
            return;
          }

          var state =
          /** @type {!ActivationStateType} */
          Object.assign({}, activationState);

          if (activationState.isProgrammatic) {
            var evtObject = null;
            requestAnimationFrame(function () {
              return _this13.animateDeactivation_(evtObject, state);
            });
            this.resetActivationState_();
          } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
              _this13.activationState_.hasDeactivationUXRun = true;

              _this13.animateDeactivation_(e, state);

              _this13.resetActivationState_();
            });
          }
        }
        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          this.deactivate_(event);
        }
        /**
         * @param {Event} e
         * @param {!ActivationStateType} options
         * @private
         */

      }, {
        key: "animateDeactivation_",
        value: function animateDeactivation_(e, _ref) {
          var wasActivatedByPointer = _ref.wasActivatedByPointer,
              wasElementMadeActive = _ref.wasElementMadeActive;

          if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this14 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }

          this.layoutFrame_ = requestAnimationFrame(function () {
            _this14.layoutInternal_();

            _this14.layoutFrame_ = 0;
          });
        }
        /** @private */

      }, {
        key: "layoutInternal_",
        value: function layoutInternal_() {
          var _this15 = this;

          this.frame_ = this.adapter_.computeBoundingRect();
          var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
          // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
          // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
          // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
          // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
          // `overflow: hidden`.

          var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
          };

          this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

          this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;
          this.fgScale_ = this.maxRadius_ / this.initialSize_;
          this.updateLayoutCssVars_();
        }
        /** @private */

      }, {
        key: "updateLayoutCssVars_",
        value: function updateLayoutCssVars_() {
          var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
              VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
              VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
              VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
              VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
          this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
          this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

          if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
              left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
              top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };
            this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
            this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
          }
        }
        /** @param {boolean} unbounded */

      }, {
        key: "setUnbounded",
        value: function setUnbounded(unbounded) {
          var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

          if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
          } else {
            this.adapter_.removeClass(UNBOUNDED);
          }
        }
      }, {
        key: "handleFocus",
        value: function handleFocus() {
          var _this16 = this;

          requestAnimationFrame(function () {
            return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }, {
        key: "handleBlur",
        value: function handleBlur() {
          var _this17 = this;

          requestAnimationFrame(function () {
            return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }]);

      return MDCRippleFoundation;
    }(MDCFoundation$h);

    /**
     * @extends MDCComponent<!MDCRippleFoundation>
     */

    var MDCRipple$9 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$i(MDCRipple, _MDCComponent);

      /** @param {...?} args */
      function MDCRipple() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$i(this, MDCRipple);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$i(this, (_getPrototypeOf2 = _getPrototypeOf$i(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {boolean} */

        _this.disabled = false;
        /** @private {boolean} */

        _this.unbounded_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @param {{isUnbounded: (boolean|undefined)}=} options
       * @return {!MDCRipple}
       */


      _createClass$i(MDCRipple, [{
        key: "setUnbounded_",

        /**
         * Closure Compiler throws an access control error when directly accessing a
         * protected or private property inside a getter/setter, like unbounded above.
         * By accessing the protected property inside a method, we solve that problem.
         * That's why this function exists.
         * @private
         */
        value: function setUnbounded_() {
          this.foundation_.setUnbounded(this.unbounded_);
        }
      }, {
        key: "activate",
        value: function activate() {
          this.foundation_.activate();
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
        /**
         * @return {!MDCRippleFoundation}
         * @override
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          return new MDCRippleFoundation$9(MDCRipple.createAdapter(this));
        }
        /** @override */

      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
        }
      }, {
        key: "unbounded",

        /** @return {boolean} */
        get: function get() {
          return this.unbounded_;
        }
        /** @param {boolean} unbounded */
        ,
        set: function set(unbounded) {
          this.unbounded_ = Boolean(unbounded);
          this.setUnbounded_();
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref$isUnbounded = _ref.isUnbounded,
              isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

          var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

          if (isUnbounded !== undefined) {
            ripple.unbounded =
            /** @type {boolean} */
            isUnbounded;
          }

          return ripple;
        }
        /**
         * @param {!RippleCapableSurface} instance
         * @return {!MDCRippleAdapter}
         */

      }, {
        key: "createAdapter",
        value: function createAdapter(instance) {
          var MATCHES = getMatchesProperty$9(HTMLElement.prototype);
          return {
            browserSupportsCssVars: function browserSupportsCssVars() {
              return supportsCssVariables$9(window);
            },
            isUnbounded: function isUnbounded() {
              return instance.unbounded;
            },
            isSurfaceActive: function isSurfaceActive() {
              return instance.root_[MATCHES](':active');
            },
            isSurfaceDisabled: function isSurfaceDisabled() {
              return instance.disabled;
            },
            addClass: function addClass(className) {
              return instance.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return instance.root_.classList.remove(className);
            },
            containsEventTarget: function containsEventTarget(target) {
              return instance.root_.contains(target);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return instance.root_.addEventListener(evtType, handler, applyPassive$a());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return instance.root_.removeEventListener(evtType, handler, applyPassive$a());
            },
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.addEventListener(evtType, handler, applyPassive$a());
            },
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.removeEventListener(evtType, handler, applyPassive$a());
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return instance.root_.style.setProperty(varName, value);
            },
            computeBoundingRect: function computeBoundingRect() {
              return instance.root_.getBoundingClientRect();
            },
            getWindowPageOffset: function getWindowPageOffset() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            }
          };
        }
      }]);

      return MDCRipple;
    }(MDCComponent$g);

    /**
     * @license
     * Copyright 2017 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Notched Outline.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Notched Outline into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCNotchedOutlineAdapter$1 =
    /*#__PURE__*/
    function () {
      function MDCNotchedOutlineAdapter() {
        _classCallCheck$i(this, MDCNotchedOutlineAdapter);
      }

      _createClass$i(MDCNotchedOutlineAdapter, [{
        key: "getWidth",

        /**
         * Returns the width of the root element.
         * @return {number}
         */
        value: function getWidth() {}
        /**
         * Returns the height of the root element.
         * @return {number}
         */

      }, {
        key: "getHeight",
        value: function getHeight() {}
        /**
         * Adds a class to the root element.
         * @param {string} className
         */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /**
         * Removes a class from the root element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Sets the "d" attribute of the outline element's SVG path.
         * @param {string} value
         */

      }, {
        key: "setOutlinePathAttr",
        value: function setOutlinePathAttr(value) {}
        /**
         * Returns the idle outline element's computed style value of the given css property `propertyName`.
         * We achieve this via `getComputedStyle(...).getPropertyValue(propertyName)`.
         * @param {string} propertyName
         * @return {string}
         */

      }, {
        key: "getIdleOutlineStyleValue",
        value: function getIdleOutlineStyleValue(propertyName) {}
      }]);

      return MDCNotchedOutlineAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var strings$1$a = {
      PATH_SELECTOR: '.mdc-notched-outline__path',
      IDLE_OUTLINE_SELECTOR: '.mdc-notched-outline__idle'
    };
    /** @enum {string} */

    var cssClasses$3$1 = {
      OUTLINE_NOTCHED: 'mdc-notched-outline--notched'
    };

    /**
     * @extends {MDCFoundation<!MDCNotchedOutlineAdapter>}
     * @final
     */

    var MDCNotchedOutlineFoundation$1 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$i(MDCNotchedOutlineFoundation, _MDCFoundation);

      _createClass$i(MDCNotchedOutlineFoundation, null, [{
        key: "strings",

        /** @return enum {string} */
        get: function get() {
          return strings$1$a;
        }
        /** @return enum {string} */

      }, {
        key: "cssClasses",
        get: function get() {
          return cssClasses$3$1;
        }
        /**
         * {@see MDCNotchedOutlineAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCNotchedOutlineAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCNotchedOutlineAdapter} */
            {
              getWidth: function getWidth() {},
              getHeight: function getHeight() {},
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              setOutlinePathAttr: function setOutlinePathAttr() {},
              getIdleOutlineStyleValue: function getIdleOutlineStyleValue() {}
            }
          );
        }
        /**
         * @param {!MDCNotchedOutlineAdapter} adapter
         */

      }]);

      function MDCNotchedOutlineFoundation(adapter) {
        _classCallCheck$i(this, MDCNotchedOutlineFoundation);

        return _possibleConstructorReturn$i(this, _getPrototypeOf$i(MDCNotchedOutlineFoundation).call(this, Object.assign(MDCNotchedOutlineFoundation.defaultAdapter, adapter)));
      }
      /**
       * Adds the outline notched selector and updates the notch width
       * calculated based off of notchWidth and isRtl.
       * @param {number} notchWidth
       * @param {boolean=} isRtl
       */


      _createClass$i(MDCNotchedOutlineFoundation, [{
        key: "notch",
        value: function notch(notchWidth) {
          var isRtl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;
          this.adapter_.addClass(OUTLINE_NOTCHED);
          this.updateSvgPath_(notchWidth, isRtl);
        }
        /**
         * Removes notched outline selector to close the notch in the outline.
         */

      }, {
        key: "closeNotch",
        value: function closeNotch() {
          var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;
          this.adapter_.removeClass(OUTLINE_NOTCHED);
        }
        /**
         * Updates the SVG path of the focus outline element based on the notchWidth
         * and the RTL context.
         * @param {number} notchWidth
         * @param {boolean=} isRtl
         * @private
         */

      }, {
        key: "updateSvgPath_",
        value: function updateSvgPath_(notchWidth, isRtl) {
          // Fall back to reading a specific corner's style because Firefox doesn't report the style on border-radius.
          var radiusStyleValue = this.adapter_.getIdleOutlineStyleValue('border-radius') || this.adapter_.getIdleOutlineStyleValue('border-top-left-radius');
          var radius = parseFloat(radiusStyleValue);
          var width = this.adapter_.getWidth();
          var height = this.adapter_.getHeight();
          var cornerWidth = radius + 1.2;
          var leadingStrokeLength = Math.abs(11 - cornerWidth);
          var paddedNotchWidth = notchWidth + 8; // The right, bottom, and left sides of the outline follow the same SVG path.

          var pathMiddle = 'a' + radius + ',' + radius + ' 0 0 1 ' + radius + ',' + radius + 'v' + (height - 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + -radius + ',' + radius + 'h' + (-width + 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + -radius + ',' + -radius + 'v' + (-height + 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + radius + ',' + -radius;
          var path;

          if (!isRtl) {
            path = 'M' + (cornerWidth + leadingStrokeLength + paddedNotchWidth) + ',' + 1 + 'h' + (width - 2 * cornerWidth - paddedNotchWidth - leadingStrokeLength) + pathMiddle + 'h' + leadingStrokeLength;
          } else {
            path = 'M' + (width - cornerWidth - leadingStrokeLength) + ',' + 1 + 'h' + leadingStrokeLength + pathMiddle + 'h' + (width - 2 * cornerWidth - paddedNotchWidth - leadingStrokeLength);
          }

          this.adapter_.setOutlinePathAttr(path);
        }
      }]);

      return MDCNotchedOutlineFoundation;
    }(MDCFoundation$h);

    /**
     * @extends {MDCComponent<!MDCNotchedOutlineFoundation>}
     * @final
     */

    var MDCNotchedOutline$1 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$i(MDCNotchedOutline, _MDCComponent);

      function MDCNotchedOutline() {
        _classCallCheck$i(this, MDCNotchedOutline);

        return _possibleConstructorReturn$i(this, _getPrototypeOf$i(MDCNotchedOutline).apply(this, arguments));
      }

      _createClass$i(MDCNotchedOutline, [{
        key: "notch",

        /**
          * Updates outline selectors and SVG path to open notch.
          * @param {number} notchWidth The notch width in the outline.
          * @param {boolean=} isRtl Determines if outline is rtl. If rtl is true, notch
          * will be right justified in outline path, otherwise left justified.
          */
        value: function notch(notchWidth, isRtl) {
          this.foundation_.notch(notchWidth, isRtl);
        }
        /**
         * Updates the outline selectors to close notch and return it to idle state.
         */

      }, {
        key: "closeNotch",
        value: function closeNotch() {
          this.foundation_.closeNotch();
        }
        /**
         * @return {!MDCNotchedOutlineFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCNotchedOutlineFoundation$1({
            getWidth: function getWidth() {
              return _this.root_.offsetWidth;
            },
            getHeight: function getHeight() {
              return _this.root_.offsetHeight;
            },
            addClass: function addClass(className) {
              return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this.root_.classList.remove(className);
            },
            setOutlinePathAttr: function setOutlinePathAttr(value) {
              var path = _this.root_.querySelector(strings$1$a.PATH_SELECTOR);

              path.setAttribute('d', value);
            },
            getIdleOutlineStyleValue: function getIdleOutlineStyleValue(propertyName) {
              var idleOutlineElement = _this.root_.parentNode.querySelector(strings$1$a.IDLE_OUTLINE_SELECTOR);

              return window.getComputedStyle(idleOutlineElement).getPropertyValue(propertyName);
            }
          });
        }
      }], [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCNotchedOutline}
         */
        value: function attachTo(root) {
          return new MDCNotchedOutline(root);
        }
      }]);

      return MDCNotchedOutline;
    }(MDCComponent$g);

    /**
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var cssClasses$4$1 = {
      BOX: 'mdc-select--box',
      DISABLED: 'mdc-select--disabled',
      ROOT: 'mdc-select',
      OUTLINED: 'mdc-select--outlined'
    };
    var strings$2$2 = {
      CHANGE_EVENT: 'MDCSelect:change',
      LINE_RIPPLE_SELECTOR: '.mdc-line-ripple',
      LABEL_SELECTOR: '.mdc-floating-label',
      NATIVE_CONTROL_SELECTOR: '.mdc-select__native-control',
      OUTLINE_SELECTOR: '.mdc-notched-outline'
    };
    /** @enum {number} */

    var numbers$1$3 = {
      LABEL_SCALE: 0.75
    };

    var MDCSelectFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$i(MDCSelectFoundation, _MDCFoundation);

      _createClass$i(MDCSelectFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$4$1;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers$1$3;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$2$2;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            hasClass: function hasClass() {
              return (
                /* className: string */
                false
              );
            },
            floatLabel: function floatLabel()
            /* value: boolean */
            {},
            activateBottomLine: function activateBottomLine() {},
            deactivateBottomLine: function deactivateBottomLine() {},
            registerInteractionHandler: function registerInteractionHandler()
            /* type: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* type: string, handler: EventListener */
            {},
            getSelectedIndex: function getSelectedIndex() {
              return (
                /* number */
                -1
              );
            },
            setSelectedIndex: function setSelectedIndex()
            /* index: number */
            {},
            setDisabled: function setDisabled()
            /* disabled: boolean */
            {},
            getValue: function getValue() {
              return (
                /* string */
                ''
              );
            },
            setValue: function setValue()
            /* value: string */
            {},
            isRtl: function isRtl() {
              return false;
            },
            hasLabel: function hasLabel() {},
            getLabelWidth: function getLabelWidth() {},
            hasOutline: function hasOutline() {},
            notchOutline: function notchOutline() {},
            closeOutline: function closeOutline() {}
          };
        }
      }]);

      function MDCSelectFoundation(adapter) {
        var _this;

        _classCallCheck$i(this, MDCSelectFoundation);

        _this = _possibleConstructorReturn$i(this, _getPrototypeOf$i(MDCSelectFoundation).call(this, Object.assign(MDCSelectFoundation.defaultAdapter, adapter)));

        _this.focusHandler_ = function (evt) {
          return _this.handleFocus_(evt);
        };

        _this.blurHandler_ = function (evt) {
          return _this.handleBlur_(evt);
        };

        _this.selectionHandler_ = function (evt) {
          return _this.handleSelect_(evt);
        };

        return _this;
      }

      _createClass$i(MDCSelectFoundation, [{
        key: "init",
        value: function init() {
          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
          this.adapter_.registerInteractionHandler('change', this.selectionHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);
          this.adapter_.deregisterInteractionHandler('change', this.selectionHandler_);
        }
      }, {
        key: "setSelectedIndex",
        value: function setSelectedIndex(index) {
          this.adapter_.setSelectedIndex(index);
          this.floatLabelWithValue_();
        }
      }, {
        key: "setValue",
        value: function setValue(value) {
          this.adapter_.setValue(value);
          this.setSelectedIndex(this.adapter_.getSelectedIndex());
        }
      }, {
        key: "setDisabled",
        value: function setDisabled(disabled) {
          var DISABLED = MDCSelectFoundation.cssClasses.DISABLED;
          this.adapter_.setDisabled(disabled);

          if (disabled) {
            this.adapter_.addClass(DISABLED);
          } else {
            this.adapter_.removeClass(DISABLED);
          }
        }
      }, {
        key: "floatLabelWithValue_",
        value: function floatLabelWithValue_() {
          var optionHasValue = this.adapter_.getValue().length > 0;
          this.adapter_.floatLabel(optionHasValue);
          this.notchOutline(optionHasValue);
        }
      }, {
        key: "handleFocus_",
        value: function handleFocus_() {
          this.adapter_.floatLabel(true);
          this.notchOutline(true);
          this.adapter_.activateBottomLine();
        }
      }, {
        key: "handleBlur_",
        value: function handleBlur_() {
          this.floatLabelWithValue_();
          this.adapter_.deactivateBottomLine();
        }
      }, {
        key: "handleSelect_",
        value: function handleSelect_() {
          this.setSelectedIndex(this.adapter_.getSelectedIndex());
        }
        /**
         * Opens/closes the notched outline.
         * @param {boolean} openNotch
         */

      }, {
        key: "notchOutline",
        value: function notchOutline(openNotch) {
          if (!this.adapter_.hasOutline() || !this.adapter_.hasLabel()) {
            return;
          }

          if (openNotch) {
            var labelScale = numbers$1$3.LABEL_SCALE;
            var labelWidth = this.adapter_.getLabelWidth() * labelScale;
            var isRtl = this.adapter_.isRtl();
            this.adapter_.notchOutline(labelWidth, isRtl);
          } else {
            this.adapter_.closeOutline();
          }
        }
      }]);

      return MDCSelectFoundation;
    }(MDCFoundation$h);

    var MDCSelect =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$i(MDCSelect, _MDCComponent);

      function MDCSelect() {
        _classCallCheck$i(this, MDCSelect);

        return _possibleConstructorReturn$i(this, _getPrototypeOf$i(MDCSelect).apply(this, arguments));
      }

      _createClass$i(MDCSelect, [{
        key: "layout",

        /**
         * Recomputes the outline SVG path for the outline element.
         */
        value: function layout() {
          var openNotch = this.nativeControl_.value.length > 0;
          this.foundation_.notchOutline(openNotch);
        }
      }, {
        key: "initialize",
        value: function initialize() {
          var labelFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (el) {
            return new MDCFloatingLabel$1(el);
          };
          var lineRippleFactory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (el) {
            return new MDCLineRipple$1(el);
          };
          var outlineFactory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (el) {
            return new MDCNotchedOutline$1(el);
          };
          this.nativeControl_ = this.root_.querySelector(strings$2$2.NATIVE_CONTROL_SELECTOR);
          var labelElement = this.root_.querySelector(strings$2$2.LABEL_SELECTOR);

          if (labelElement) {
            this.label_ = labelFactory(labelElement);
          }

          var lineRippleElement = this.root_.querySelector(strings$2$2.LINE_RIPPLE_SELECTOR);

          if (lineRippleElement) {
            this.lineRipple_ = lineRippleFactory(lineRippleElement);
          }

          var outlineElement = this.root_.querySelector(strings$2$2.OUTLINE_SELECTOR);

          if (outlineElement) {
            this.outline_ = outlineFactory(outlineElement);
          }

          if (this.root_.classList.contains(cssClasses$4$1.BOX)) {
            this.ripple = this.initRipple_();
          }
        }
      }, {
        key: "initRipple_",
        value: function initRipple_() {
          var _this = this;

          var adapter = Object.assign(MDCRipple$9.createAdapter(this), {
            registerInteractionHandler: function registerInteractionHandler(type, handler) {
              return _this.nativeControl_.addEventListener(type, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
              return _this.nativeControl_.removeEventListener(type, handler);
            }
          });
          var foundation = new MDCRippleFoundation$9(adapter);
          return new MDCRipple$9(this.root_, foundation);
        }
      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this2 = this;

          return new MDCSelectFoundation(Object.assign({
            addClass: function addClass(className) {
              return _this2.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this2.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
              return _this2.root_.classList.contains(className);
            },
            activateBottomLine: function activateBottomLine() {
              if (_this2.lineRipple_) {
                _this2.lineRipple_.activate();
              }
            },
            deactivateBottomLine: function deactivateBottomLine() {
              if (_this2.lineRipple_) {
                _this2.lineRipple_.deactivate();
              }
            },
            setDisabled: function setDisabled(disabled) {
              return _this2.nativeControl_.disabled = disabled;
            },
            registerInteractionHandler: function registerInteractionHandler(type, handler) {
              return _this2.nativeControl_.addEventListener(type, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
              return _this2.nativeControl_.removeEventListener(type, handler);
            },
            getSelectedIndex: function getSelectedIndex() {
              return _this2.nativeControl_.selectedIndex;
            },
            setSelectedIndex: function setSelectedIndex(index) {
              return _this2.nativeControl_.selectedIndex = index;
            },
            getValue: function getValue() {
              return _this2.nativeControl_.value;
            },
            setValue: function setValue(value) {
              return _this2.nativeControl_.value = value;
            },
            isRtl: function isRtl() {
              return window.getComputedStyle(_this2.root_).getPropertyValue('direction') === 'rtl';
            }
          }, this.getOutlineAdapterMethods_(), this.getLabelAdapterMethods_()));
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          // needed to sync floating label
          this.selectedIndex = this.nativeControl_.selectedIndex;

          if (this.nativeControl_.disabled) {
            this.disabled = true;
          }
        }
      }, {
        key: "destroy",
        value: function destroy() {
          if (this.ripple) {
            this.ripple.destroy();
          }

          if (this.outline_) {
            this.outline_.destroy();
          }

          _get$9(_getPrototypeOf$i(MDCSelect.prototype), "destroy", this).call(this);
        }
        /**
         * @return {!{
         *   notchOutline: function(number, boolean): undefined,
         *   hasOutline: function(): boolean,
         * }}
         */

      }, {
        key: "getOutlineAdapterMethods_",
        value: function getOutlineAdapterMethods_() {
          var _this3 = this;

          return {
            notchOutline: function notchOutline(labelWidth, isRtl) {
              if (_this3.outline_) {
                _this3.outline_.notch(labelWidth, isRtl);
              }
            },
            closeOutline: function closeOutline() {
              if (_this3.outline_) {
                _this3.outline_.closeNotch();
              }
            },
            hasOutline: function hasOutline() {
              return !!_this3.outline_;
            }
          };
        }
        /**
         * @return {!{
         *   floatLabel: function(boolean): undefined,
         *   hasLabel: function(): boolean,
         *   getLabelWidth: function(): number,
         * }}
         */

      }, {
        key: "getLabelAdapterMethods_",
        value: function getLabelAdapterMethods_() {
          var _this4 = this;

          return {
            floatLabel: function floatLabel(shouldFloat) {
              if (_this4.label_) {
                _this4.label_.float(shouldFloat);
              }
            },
            hasLabel: function hasLabel() {
              return !!_this4.label_;
            },
            getLabelWidth: function getLabelWidth() {
              if (_this4.label_) {
                return _this4.label_.getWidth();
              }
            }
          };
        }
      }, {
        key: "value",
        get: function get$$1() {
          return this.nativeControl_.value;
        },
        set: function set(value) {
          this.foundation_.setValue(value);
        }
      }, {
        key: "selectedIndex",
        get: function get$$1() {
          return this.nativeControl_.selectedIndex;
        },
        set: function set(selectedIndex) {
          this.foundation_.setSelectedIndex(selectedIndex);
        }
      }, {
        key: "disabled",
        get: function get$$1() {
          return this.nativeControl_.disabled;
        },
        set: function set(disabled) {
          this.foundation_.setDisabled(disabled);
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCSelect(root);
        }
      }]);

      return MDCSelect;
    }(MDCComponent$g);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ MDC_SELECT_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return MdcSelect; }),
        multi: true
    };
    var MdcSelectChange = /** @class */ (function () {
        function MdcSelectChange(index, value) {
            this.index = index;
            this.value = value;
        }
        return MdcSelectChange;
    }());
    var /** @type {?} */ nextUniqueId$5 = 0;
    var MdcSelect = /** @class */ (function () {
        function MdcSelect(_changeDetectorRef, _renderer, elementRef, _ripple, _registry) {
            var _this = this;
            this._changeDetectorRef = _changeDetectorRef;
            this._renderer = _renderer;
            this.elementRef = elementRef;
            this._ripple = _ripple;
            this._registry = _registry;
            /**
             * Emits whenever the component is destroyed.
             */
            this._destroy = new rxjs.Subject();
            this._uniqueId = "mdc-select-" + ++nextUniqueId$5;
            this.id = this._uniqueId;
            this.name = null;
            this._floatingLabel = true;
            this._box = true;
            this._outlined = false;
            this._autosize = true;
            this.change = new core.EventEmitter();
            /**
             * Event emitted when the selected value has been changed by the user.
             */
            this.selectionChange = new core.EventEmitter();
            this.isHostClass = true;
            this.tabIndex = 0;
            /**
             * View -> model callback called when value changes
             */
            this._onChange = function () { };
            /**
             * View -> model callback called when select has been touched
             */
            this._onTouched = function () { };
            this._mdcAdapter = {
                addClass: function (className) { return _this._renderer.addClass(_this._getHostElement(), className); },
                removeClass: function (className) { return _this._renderer.removeClass(_this._getHostElement(), className); },
                hasClass: function (className) { return _this._getHostElement().classList.contains(className); },
                floatLabel: function (shouldFloat) { return _this._selectLabel.float(shouldFloat); },
                activateBottomLine: function () {
                    if (_this._lineRipple) {
                        _this._lineRipple.activate();
                    }
                },
                deactivateBottomLine: function () {
                    if (_this._lineRipple) {
                        _this._lineRipple.deactivate();
                    }
                },
                setDisabled: function (disabled) { return _this._getInputElement().disabled = disabled; },
                registerInteractionHandler: function (type, handler) { return _this._registry.listen(type, handler, _this._getInputElement()); },
                deregisterInteractionHandler: function (type, handler) { return _this._registry.unlisten(type, handler); },
                getSelectedIndex: function () { return _this._getInputElement().selectedIndex; },
                setSelectedIndex: function (index) { return _this._getInputElement().selectedIndex = index; },
                getValue: function () { return _this._getInputElement().value; },
                setValue: function (value) { return _this._getInputElement().value = value; },
                isRtl: function () { return getComputedStyle(_this._getHostElement()).direction === 'rtl'; },
                hasLabel: function () { return !!_this._selectLabel; },
                getLabelWidth: function () { return _this._selectLabel.getWidth(); },
                hasOutline: function () { return !!_this._notchedOutline; },
                notchOutline: function (labelWidth, isRtl) { return _this._notchedOutline.notch(labelWidth, isRtl); },
                closeOutline: function () { return _this._notchedOutline.closeNotch(); }
            };
            this._foundation = new MDCSelectFoundation(this._mdcAdapter);
            // Force setter to be called in case id was not specified.
            this.id = this.id;
        }
        Object.defineProperty(MdcSelect.prototype, "placeholder", {
            /** Placeholder to be shown if no value has been selected. */
            get: /**
             * Placeholder to be shown if no value has been selected.
             * @return {?}
             */
            function () { return this._placeholder; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._placeholder = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSelect.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setDisabled(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSelect.prototype, "floatingLabel", {
            get: /**
             * @return {?}
             */
            function () { return this._floatingLabel; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setFloatingLabel(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSelect.prototype, "box", {
            get: /**
             * @return {?}
             */
            function () { return this._box; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._box) {
                    this.setBox(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSelect.prototype, "outlined", {
            get: /**
             * @return {?}
             */
            function () { return this._outlined; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (value !== this._outlined) {
                    this.setOutlined(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSelect.prototype, "autosize", {
            get: /**
             * @return {?}
             */
            function () { return this._autosize; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._autosize = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSelect.prototype, "classBox", {
            get: /**
             * @return {?}
             */
            function () {
                return this.box ? 'mdc-select--box' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSelect.prototype, "classOutlined", {
            get: /**
             * @return {?}
             */
            function () {
                return this.outlined ? 'mdc-select--outlined' : '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcSelect.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this._foundation.init();
            this.options.changes.pipe(operators.startWith(null), operators.takeUntil(this._destroy)).subscribe(function () {
                Promise.resolve().then(function () {
                    _this._selectLabel.float(_this.getValue());
                    if (_this.autosize) {
                        _this._setWidth();
                    }
                });
            });
        };
        /**
         * @return {?}
         */
        MdcSelect.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroy.next();
            this._destroy.complete();
            this._ripple.destroy();
            this._foundation.destroy();
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MdcSelect.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== this._getInputElement().value) {
                this.setValue(value, false);
            }
            this.change.emit(new MdcSelectChange(this._getInputElement().selectedIndex, value));
            this._initializeSelection(value);
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcSelect.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcSelect.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onTouched = fn;
        };
        /**
         * @param {?} event
         * @return {?}
         */
        MdcSelect.prototype.onChange = /**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            this.setValue((/** @type {?} */ (event.target)).value, true);
            this.selectionChange.emit(new MdcSelectChange(this._getInputElement().selectedIndex, this.getValue()));
            event.stopPropagation();
        };
        /**
         * @return {?}
         */
        MdcSelect.prototype.onBlur = /**
         * @return {?}
         */
        function () {
            if (!this.disabled) {
                this._onTouched();
            }
        };
        /**
         * @return {?}
         */
        MdcSelect.prototype.onFocus = /**
         * @return {?}
         */
        function () {
            this._onTouched();
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MdcSelect.prototype._initializeSelection = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            // Defer setting the value in order to avoid the "Expression
            // has changed after it was checked" errors from Angular.
            Promise.resolve().then(function () {
                _this.setValue(value, false);
            });
        };
        /**
         * @param {?} newValue
         * @param {?=} isUserInput
         * @return {?}
         */
        MdcSelect.prototype.setValue = /**
         * @param {?} newValue
         * @param {?=} isUserInput
         * @return {?}
         */
        function (newValue, isUserInput) {
            if (isUserInput === void 0) { isUserInput = true; }
            if (this.disabled) {
                return;
            }
            this._foundation.setValue(newValue);
            if (isUserInput) {
                this._onChange(newValue);
            }
            this._selectLabel.float(newValue);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @return {?}
         */
        MdcSelect.prototype.getValue = /**
         * @return {?}
         */
        function () {
            return this._getInputElement().value;
        };
        /**
         * @param {?} text
         * @return {?}
         */
        MdcSelect.prototype.setPlaceholder = /**
         * @param {?} text
         * @return {?}
         */
        function (text) {
            this._placeholder = text;
        };
        /**
         * @return {?}
         */
        MdcSelect.prototype.getSelectedIndex = /**
         * @return {?}
         */
        function () {
            return this._getInputElement().selectedIndex;
        };
        /**
         * @return {?}
         */
        MdcSelect.prototype.isDisabled = /**
         * @return {?}
         */
        function () {
            return this.disabled;
        };
        /**
         * @param {?} disabled
         * @return {?}
         */
        MdcSelect.prototype.setDisabled = /**
         * @param {?} disabled
         * @return {?}
         */
        function (disabled) {
            this.setDisabledState(disabled);
        };
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} disabled
         * @return {?}
         */
        MdcSelect.prototype.setDisabledState = /**
         * @param {?} disabled
         * @return {?}
         */
        function (disabled) {
            this._disabled = disabled;
            this._foundation.setDisabled(disabled);
            this._changeDetectorRef.markForCheck();
        };
        /** Styles the select as a box. */
        /**
         * Styles the select as a box.
         * @param {?} box
         * @return {?}
         */
        MdcSelect.prototype.setBox = /**
         * Styles the select as a box.
         * @param {?} box
         * @return {?}
         */
        function (box) {
            if (box && this._outlined) {
                this.setOutlined(false);
            }
            this._box = toBoolean(box);
            this.box ? this._ripple.attachTo(this._getHostElement(), false, this._getInputElement()) :
                this._ripple.destroy();
            this._changeDetectorRef.markForCheck();
        };
        /** Styles the select style to outlined. */
        /**
         * Styles the select style to outlined.
         * @param {?} outlined
         * @return {?}
         */
        MdcSelect.prototype.setOutlined = /**
         * Styles the select style to outlined.
         * @param {?} outlined
         * @return {?}
         */
        function (outlined) {
            var _this = this;
            if (outlined && this._box) {
                this.setBox(false);
            }
            this._outlined = toBoolean(outlined);
            setTimeout(function () {
                if (_this.getValue() && _this._outlined) {
                    _this._foundation.notchOutline(_this.hasFloatingLabel());
                }
            });
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} floatingLabel
         * @return {?}
         */
        MdcSelect.prototype.setFloatingLabel = /**
         * @param {?} floatingLabel
         * @return {?}
         */
        function (floatingLabel) {
            var _this = this;
            this._floatingLabel = toBoolean(floatingLabel);
            setTimeout(function () {
                if (_this.outlined && _this.getValue()) {
                    _this._foundation.notchOutline(floatingLabel);
                }
            });
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @return {?}
         */
        MdcSelect.prototype.focus = /**
         * @return {?}
         */
        function () {
            if (!this.disabled) {
                this._getInputElement().focus();
            }
        };
        /**
         * @return {?}
         */
        MdcSelect.prototype.hasFloatingLabel = /**
         * @return {?}
         */
        function () {
            return this._floatingLabel || !this.getValue();
        };
        /**
         * @return {?}
         */
        MdcSelect.prototype._setWidth = /**
         * @return {?}
         */
        function () {
            if (this.options && this.placeholder) {
                var /** @type {?} */ labelLength = this._selectLabel.elementRef.nativeElement.textContent.length;
                this._renderer.setStyle(this._getHostElement(), 'width', labelLength + "rem");
            }
        };
        /**
         * Retrieves the select input element.
         * @return {?}
         */
        MdcSelect.prototype._getInputElement = /**
         * Retrieves the select input element.
         * @return {?}
         */
        function () {
            return this.inputEl.nativeElement;
        };
        /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        MdcSelect.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcSelect.decorators = [
            { type: core.Component, args: [{selector: 'mdc-select',
                        exportAs: 'mdcSelect',
                        host: {
                            '[id]': 'id',
                        },
                        template: "\n  <select #input\n   class=\"mdc-select__native-control\"\n   (blur)=\"onBlur()\"\n   (change)=\"onChange($event)\"\n   (focus)=\"onFocus()\">\n    <ng-content #options></ng-content>\n  </select>\n  <label mdcFloatingLabel [attr.for]=\"id\">{{hasFloatingLabel() ? placeholder : ''}}</label>\n  <mdc-line-ripple *ngIf=\"!outlined\"></mdc-line-ripple>\n  <mdc-notched-outline *ngIf=\"outlined\"></mdc-notched-outline>\n  ",
                        providers: [
                            MDC_SELECT_CONTROL_VALUE_ACCESSOR,
                            EventRegistry,
                            MdcRipple
                        ],
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcSelect.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.Renderer2 },
            { type: core.ElementRef },
            { type: MdcRipple },
            { type: EventRegistry }
        ]; };
        MdcSelect.propDecorators = {
            id: [{ type: core.Input }],
            name: [{ type: core.Input }],
            placeholder: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            floatingLabel: [{ type: core.Input }],
            box: [{ type: core.Input }],
            outlined: [{ type: core.Input }],
            autosize: [{ type: core.Input }],
            change: [{ type: core.Output }],
            selectionChange: [{ type: core.Output }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-select',] }],
            tabIndex: [{ type: core.HostBinding, args: ['tabindex',] }],
            classBox: [{ type: core.HostBinding, args: ['class.mdc-select--box',] }],
            classOutlined: [{ type: core.HostBinding, args: ['class.mdc-select--outlined',] }],
            _selectLabel: [{ type: core.ViewChild, args: [MdcFloatingLabel,] }],
            _lineRipple: [{ type: core.ViewChild, args: [MdcLineRipple,] }],
            inputEl: [{ type: core.ViewChild, args: ['input',] }],
            _notchedOutline: [{ type: core.ViewChild, args: [MdcNotchedOutline,] }],
            options: [{ type: core.ContentChildren, args: ['options',] }]
        };
        return MdcSelect;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcSelectModule = /** @class */ (function () {
        function MdcSelectModule() {
        }
        MdcSelectModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            MdcFloatingLabelModule,
                            MdcNotchedOutlineModule,
                            MdcLineRippleModule
                        ],
                        exports: [MdcSelect],
                        declarations: [MdcSelect]
                    },] },
        ];
        return MdcSelectModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ MDC_VALID_SHAPE_CORNERS = [
        'top-left',
        'top-right',
        'bottom-right',
        'bottom-left'
    ];
    var MdcShapeContainerCorner = /** @class */ (function () {
        function MdcShapeContainerCorner(_changeDetectorRef, elementRef, _renderer) {
            this._changeDetectorRef = _changeDetectorRef;
            this.elementRef = elementRef;
            this._renderer = _renderer;
            this.isHostClass = true;
        }
        Object.defineProperty(MdcShapeContainerCorner.prototype, "corner", {
            get: /**
             * @return {?}
             */
            function () { return this._corner; },
            set: /**
             * @param {?} corner
             * @return {?}
             */
            function (corner) {
                // If the directive is set without a name (updated programatically), then this setter will
                // trigger with an empty string and should not overwrite the programatically set value.
                if (!corner) {
                    return;
                }
                this.setCorner(corner);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} corner
         * @return {?}
         */
        MdcShapeContainerCorner.prototype.setCorner = /**
         * @param {?} corner
         * @return {?}
         */
        function (corner) {
            if (this._isCornerValid(corner)) {
                var /** @type {?} */ cssClass = 'mdc-shape-container__corner--';
                this._renderer.removeClass(this._getHostElement(), "" + cssClass + this.corner);
                this._renderer.addClass(this._getHostElement(), "" + cssClass + corner);
                this._corner = corner;
                this._changeDetectorRef.markForCheck();
            }
        };
        /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        MdcShapeContainerCorner.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        /** Make sure the corner value is supported. */
        /**
         * Make sure the corner value is supported.
         * @param {?} corner
         * @return {?}
         */
        MdcShapeContainerCorner.prototype._isCornerValid = /**
         * Make sure the corner value is supported.
         * @param {?} corner
         * @return {?}
         */
        function (corner) {
            return MDC_VALID_SHAPE_CORNERS.indexOf(corner) > -1 ? true : false;
        };
        MdcShapeContainerCorner.decorators = [
            { type: core.Component, args: [{selector: '[mdcShapeContainerCorner], mdc-shape-container-corner',
                        exportAs: 'mdcShapeContainerCorner',
                        template: '<ng-content></ng-content>',
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcShapeContainerCorner.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: core.Renderer2 }
        ]; };
        MdcShapeContainerCorner.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-shape-container__corner',] }],
            corner: [{ type: core.Input, args: ['mdcShapeContainerCorner',] }]
        };
        return MdcShapeContainerCorner;
    }());
    var MdcShapeContainer = /** @class */ (function () {
        function MdcShapeContainer(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcShapeContainer.decorators = [
            { type: core.Component, args: [{selector: '[mdcShapeContainer], [mdc-shape-container], mdc-shape-container',
                        exportAs: 'mdcShapeContainer',
                        template: '<ng-content></ng-content>',
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcShapeContainer.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcShapeContainer.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-shape-container',] }]
        };
        return MdcShapeContainer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ SHAPE_DECLARATIONS = [
        MdcShapeContainer,
        MdcShapeContainerCorner
    ];
    var MdcShapeModule = /** @class */ (function () {
        function MdcShapeModule() {
        }
        MdcShapeModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [SHAPE_DECLARATIONS],
                        declarations: [SHAPE_DECLARATIONS]
                    },] },
        ];
        return MdcShapeModule;
    }());

    function _classCallCheck$j(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$j(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$j(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$j(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$j(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$j(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$j(subClass, superClass);
    }

    function _getPrototypeOf$j(o) {
      _getPrototypeOf$j = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$j(o);
    }

    function _setPrototypeOf$j(o, p) {
      _setPrototypeOf$j = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$j(o, p);
    }

    function _assertThisInitialized$j(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$j(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$j(self);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @template A
     */
    var MDCFoundation$i =
    /*#__PURE__*/
    function () {
      _createClass$j(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$j(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$j(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$h =
    /*#__PURE__*/
    function () {
      _createClass$j(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$i());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$j(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$j(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2017 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var cssClasses$h = {
      ACTIVE: 'mdc-slider--active',
      DISABLED: 'mdc-slider--disabled',
      DISCRETE: 'mdc-slider--discrete',
      FOCUS: 'mdc-slider--focus',
      IN_TRANSIT: 'mdc-slider--in-transit',
      IS_DISCRETE: 'mdc-slider--discrete',
      HAS_TRACK_MARKER: 'mdc-slider--display-markers'
    };
    /** @enum {string} */

    var strings$g = {
      TRACK_SELECTOR: '.mdc-slider__track',
      TRACK_MARKER_CONTAINER_SELECTOR: '.mdc-slider__track-marker-container',
      LAST_TRACK_MARKER_SELECTOR: '.mdc-slider__track-marker:last-child',
      THUMB_CONTAINER_SELECTOR: '.mdc-slider__thumb-container',
      PIN_VALUE_MARKER_SELECTOR: '.mdc-slider__pin-value-marker',
      ARIA_VALUEMIN: 'aria-valuemin',
      ARIA_VALUEMAX: 'aria-valuemax',
      ARIA_VALUENOW: 'aria-valuenow',
      ARIA_DISABLED: 'aria-disabled',
      STEP_DATA_ATTR: 'data-step',
      CHANGE_EVENT: 'MDCSlider:change',
      INPUT_EVENT: 'MDCSlider:input'
    };
    /** @enum {number} */

    var numbers$b = {
      PAGE_FACTOR: 4
    };

    /**
     * @license
     * Copyright 2017 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint-disable no-unused-vars */

    /**
     * Adapter for MDC Slider.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Slider into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCSliderAdapter =
    /*#__PURE__*/
    function () {
      function MDCSliderAdapter() {
        _classCallCheck$j(this, MDCSliderAdapter);
      }

      _createClass$j(MDCSliderAdapter, [{
        key: "hasClass",

        /**
         * Returns true if className exists for the slider Element
         * @param {string} className
         * @return {boolean}
         */
        value: function hasClass(className) {}
        /**
         * Adds a class to the slider Element
         * @param {string} className
         */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /**
         * Removes a class from the slider Element
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Returns a string if attribute name exists on the slider Element,
         * otherwise returns null
         * @param {string} name
         * @return {?string}
         */

      }, {
        key: "getAttribute",
        value: function getAttribute(name) {}
        /**
         * Sets attribute name on slider Element to value
         * @param {string} name
         * @param {string} value
         */

      }, {
        key: "setAttribute",
        value: function setAttribute(name, value) {}
        /**
         * Removes attribute name from slider Element
         * @param {string} name
         */

      }, {
        key: "removeAttribute",
        value: function removeAttribute(name) {}
        /**
         * Returns the bounding client rect for the slider Element
         * @return {?ClientRect}
         */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}
        /**
         * Returns the tab index of the slider Element
         * @return {number}
         */

      }, {
        key: "getTabIndex",
        value: function getTabIndex() {}
        /**
         * Registers an event handler on the root element for a given event.
         * @param {string} type
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(type, handler) {}
        /**
         * Deregisters an event handler on the root element for a given event.
         * @param {string} type
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(type, handler) {}
        /**
         * Registers an event handler on the thumb container element for a given event.
         * @param {string} type
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerThumbContainerInteractionHandler",
        value: function registerThumbContainerInteractionHandler(type, handler) {}
        /**
         * Deregisters an event handler on the thumb container element for a given event.
         * @param {string} type
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterThumbContainerInteractionHandler",
        value: function deregisterThumbContainerInteractionHandler(type, handler) {}
        /**
         * Registers an event handler on the body for a given event.
         * @param {string} type
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerBodyInteractionHandler",
        value: function registerBodyInteractionHandler(type, handler) {}
        /**
         * Deregisters an event handler on the body for a given event.
         * @param {string} type
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterBodyInteractionHandler",
        value: function deregisterBodyInteractionHandler(type, handler) {}
        /**
         * Registers an event handler for the window resize event
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /**
         * Deregisters an event handler for the window resize event
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /**
         * Emits a custom event MDCSlider:input from the root
         */

      }, {
        key: "notifyInput",
        value: function notifyInput() {}
        /**
         * Emits a custom event MDCSlider:change from the root
         */

      }, {
        key: "notifyChange",
        value: function notifyChange() {}
        /**
         * Sets a style property of the thumb container element to the passed value
         * @param {string} propertyName
         * @param {string} value
         */

      }, {
        key: "setThumbContainerStyleProperty",
        value: function setThumbContainerStyleProperty(propertyName, value) {}
        /**
         * Sets a style property of the track element to the passed value
         * @param {string} propertyName
         * @param {string} value
         */

      }, {
        key: "setTrackStyleProperty",
        value: function setTrackStyleProperty(propertyName, value) {}
        /**
         * Sets the inner text of the pin marker to the passed value
         * @param {number} value
         */

      }, {
        key: "setMarkerValue",
        value: function setMarkerValue(value) {}
        /**
         * Appends the passed number of track markers to the track mark container element
         * @param {number} numMarkers
         */

      }, {
        key: "appendTrackMarkers",
        value: function appendTrackMarkers(numMarkers) {}
        /**
         * Removes all track markers fromt he track mark container element
         */

      }, {
        key: "removeTrackMarkers",
        value: function removeTrackMarkers() {}
        /**
         * Sets a style property of the last track marker to the passed value
         * @param {string} propertyName
         * @param {string} value
         */

      }, {
        key: "setLastTrackMarkersStyleProperty",
        value: function setLastTrackMarkersStyleProperty(propertyName, value) {}
        /**
         * Returns true if the root element is RTL, otherwise false
         * @return {boolean}
         */

      }, {
        key: "isRTL",
        value: function isRTL() {}
      }]);

      return MDCSliderAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /** @const {Object<string, !VendorPropertyMapType>} */

    var eventTypeMap$1 = {
      'animationstart': {
        noPrefix: 'animationstart',
        webkitPrefix: 'webkitAnimationStart',
        styleProperty: 'animation'
      },
      'animationend': {
        noPrefix: 'animationend',
        webkitPrefix: 'webkitAnimationEnd',
        styleProperty: 'animation'
      },
      'animationiteration': {
        noPrefix: 'animationiteration',
        webkitPrefix: 'webkitAnimationIteration',
        styleProperty: 'animation'
      },
      'transitionend': {
        noPrefix: 'transitionend',
        webkitPrefix: 'webkitTransitionEnd',
        styleProperty: 'transition'
      }
    };
    /** @const {Object<string, !VendorPropertyMapType>} */

    var cssPropertyMap$1 = {
      'animation': {
        noPrefix: 'animation',
        webkitPrefix: '-webkit-animation'
      },
      'transform': {
        noPrefix: 'transform',
        webkitPrefix: '-webkit-transform'
      },
      'transition': {
        noPrefix: 'transition',
        webkitPrefix: '-webkit-transition'
      }
    };
    /**
     * @param {!Object} windowObj
     * @return {boolean}
     */

    function hasProperShape$1(windowObj) {
      return windowObj['document'] !== undefined && typeof windowObj['document']['createElement'] === 'function';
    }
    /**
     * @param {string} eventType
     * @return {boolean}
     */


    function eventFoundInMaps$1(eventType) {
      return eventType in eventTypeMap$1 || eventType in cssPropertyMap$1;
    }
    /**
     * @param {string} eventType
     * @param {!Object<string, !VendorPropertyMapType>} map
     * @param {!Element} el
     * @return {string}
     */


    function getJavaScriptEventName$1(eventType, map, el) {
      return map[eventType].styleProperty in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
    }
    /**
     * Helper function to determine browser prefix for CSS3 animation events
     * and property names.
     * @param {!Object} windowObj
     * @param {string} eventType
     * @return {string}
     */


    function getAnimationName$1(windowObj, eventType) {
      if (!hasProperShape$1(windowObj) || !eventFoundInMaps$1(eventType)) {
        return eventType;
      }

      var map =
      /** @type {!Object<string, !VendorPropertyMapType>} */
      eventType in eventTypeMap$1 ? eventTypeMap$1 : cssPropertyMap$1;
      var el = windowObj['document']['createElement']('div');
      var eventName = '';

      if (map === eventTypeMap$1) {
        eventName = getJavaScriptEventName$1(eventType, map, el);
      } else {
        eventName = map[eventType].noPrefix in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
      }

      return eventName;
    } // Public functions to access getAnimationName() for JavaScript events or CSS
    /**
     * @param {!Object} windowObj
     * @param {string} eventType
     * @return {string}
     */

    function getCorrectEventName$1(windowObj, eventType) {
      return getAnimationName$1(windowObj, eventType);
    }
    /**
     * @param {!Object} windowObj
     * @param {string} eventType
     * @return {string}
     */


    function getCorrectPropertyName(windowObj, eventType) {
      return getAnimationName$1(windowObj, eventType);
    }

    /** @enum {string} */

    var KEY_IDS = {
      ARROW_LEFT: 'ArrowLeft',
      ARROW_RIGHT: 'ArrowRight',
      ARROW_UP: 'ArrowUp',
      ARROW_DOWN: 'ArrowDown',
      HOME: 'Home',
      END: 'End',
      PAGE_UP: 'PageUp',
      PAGE_DOWN: 'PageDown'
    };
    /** @enum {string} */

    var MOVE_EVENT_MAP = {
      'mousedown': 'mousemove',
      'touchstart': 'touchmove',
      'pointerdown': 'pointermove'
    };
    var DOWN_EVENTS = ['mousedown', 'pointerdown', 'touchstart'];
    var UP_EVENTS = ['mouseup', 'pointerup', 'touchend'];
    /**
     * @extends {MDCFoundation<!MDCSliderAdapter>}
     */

    var MDCSliderFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$j(MDCSliderFoundation, _MDCFoundation);

      _createClass$j(MDCSliderFoundation, null, [{
        key: "cssClasses",

        /** @return enum {cssClasses} */
        get: function get() {
          return cssClasses$h;
        }
        /** @return enum {strings} */

      }, {
        key: "strings",
        get: function get() {
          return strings$g;
        }
        /** @return enum {numbers} */

      }, {
        key: "numbers",
        get: function get() {
          return numbers$b;
        }
        /** @return {!MDCSliderAdapter} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCSliderAdapter} */
            {
              hasClass: function hasClass() {
                return (
                  /* className: string */

                  /* boolean */
                  false
                );
              },
              addClass: function addClass()
              /* className: string */
              {},
              removeClass: function removeClass()
              /* className: string */
              {},
              getAttribute: function getAttribute() {
                return (
                  /* name: string */

                  /* string|null */
                  null
                );
              },
              setAttribute: function setAttribute()
              /* name: string, value: string */
              {},
              removeAttribute: function removeAttribute()
              /* name: string */
              {},
              computeBoundingRect: function computeBoundingRect() {
                return (
                  /* ClientRect */
                  {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0,
                    width: 0,
                    height: 0
                  }
                );
              },
              getTabIndex: function getTabIndex() {
                return (
                  /* number */
                  0
                );
              },
              registerInteractionHandler: function registerInteractionHandler()
              /* type: string, handler: EventListener */
              {},
              deregisterInteractionHandler: function deregisterInteractionHandler()
              /* type: string, handler: EventListener */
              {},
              registerThumbContainerInteractionHandler: function registerThumbContainerInteractionHandler()
              /* type: string, handler: EventListener */
              {},
              deregisterThumbContainerInteractionHandler: function deregisterThumbContainerInteractionHandler()
              /* type: string, handler: EventListener */
              {},
              registerBodyInteractionHandler: function registerBodyInteractionHandler()
              /* type: string, handler: EventListener */
              {},
              deregisterBodyInteractionHandler: function deregisterBodyInteractionHandler()
              /* type: string, handler: EventListener */
              {},
              registerResizeHandler: function registerResizeHandler()
              /* handler: EventListener */
              {},
              deregisterResizeHandler: function deregisterResizeHandler()
              /* handler: EventListener */
              {},
              notifyInput: function notifyInput() {},
              notifyChange: function notifyChange() {},
              setThumbContainerStyleProperty: function setThumbContainerStyleProperty()
              /* propertyName: string, value: string */
              {},
              setTrackStyleProperty: function setTrackStyleProperty()
              /* propertyName: string, value: string */
              {},
              setMarkerValue: function setMarkerValue()
              /* value: number */
              {},
              appendTrackMarkers: function appendTrackMarkers()
              /* numMarkers: number */
              {},
              removeTrackMarkers: function removeTrackMarkers() {},
              setLastTrackMarkersStyleProperty: function setLastTrackMarkersStyleProperty()
              /* propertyName: string, value: string */
              {},
              isRTL: function isRTL() {
                return (
                  /* boolean */
                  false
                );
              }
            }
          );
        }
        /**
         * Creates a new instance of MDCSliderFoundation
         * @param {?MDCSliderAdapter} adapter
         */

      }]);

      function MDCSliderFoundation(adapter) {
        var _this;

        _classCallCheck$j(this, MDCSliderFoundation);

        _this = _possibleConstructorReturn$j(this, _getPrototypeOf$j(MDCSliderFoundation).call(this, Object.assign(MDCSliderFoundation.defaultAdapter, adapter)));
        /** @private {?ClientRect} */

        _this.rect_ = null; // We set this to NaN since we want it to be a number, but we can't use '0' or '-1'
        // because those could be valid tabindices set by the client code.

        _this.savedTabIndex_ = NaN;
        _this.active_ = false;
        _this.inTransit_ = false;
        _this.isDiscrete_ = false;
        _this.hasTrackMarker_ = false;
        _this.handlingThumbTargetEvt_ = false;
        _this.min_ = 0;
        _this.max_ = 100;
        _this.step_ = 0;
        _this.value_ = 0;
        _this.disabled_ = false;
        _this.preventFocusState_ = false;
        _this.updateUIFrame_ = 0;

        _this.thumbContainerPointerHandler_ = function () {
          _this.handlingThumbTargetEvt_ = true;
        };

        _this.interactionStartHandler_ = function (evt) {
          return _this.handleDown_(evt);
        };

        _this.keydownHandler_ = function (evt) {
          return _this.handleKeydown_(evt);
        };

        _this.focusHandler_ = function () {
          return _this.handleFocus_();
        };

        _this.blurHandler_ = function () {
          return _this.handleBlur_();
        };

        _this.resizeHandler_ = function () {
          return _this.layout();
        };

        return _this;
      }

      _createClass$j(MDCSliderFoundation, [{
        key: "init",
        value: function init() {
          var _this2 = this;

          this.isDiscrete_ = this.adapter_.hasClass(cssClasses$h.IS_DISCRETE);
          this.hasTrackMarker_ = this.adapter_.hasClass(cssClasses$h.HAS_TRACK_MARKER);
          DOWN_EVENTS.forEach(function (evtName) {
            return _this2.adapter_.registerInteractionHandler(evtName, _this2.interactionStartHandler_);
          });
          this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
          DOWN_EVENTS.forEach(function (evtName) {
            _this2.adapter_.registerThumbContainerInteractionHandler(evtName, _this2.thumbContainerPointerHandler_);
          });
          this.adapter_.registerResizeHandler(this.resizeHandler_);
          this.layout(); // At last step, provide a reasonable default value to discrete slider

          if (this.isDiscrete_ && this.getStep() == 0) {
            this.step_ = 1;
          }
        }
      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          DOWN_EVENTS.forEach(function (evtName) {
            _this3.adapter_.deregisterInteractionHandler(evtName, _this3.interactionStartHandler_);
          });
          this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);
          DOWN_EVENTS.forEach(function (evtName) {
            _this3.adapter_.deregisterThumbContainerInteractionHandler(evtName, _this3.thumbContainerPointerHandler_);
          });
          this.adapter_.deregisterResizeHandler(this.resizeHandler_);
        }
      }, {
        key: "setupTrackMarker",
        value: function setupTrackMarker() {
          if (this.isDiscrete_ && this.hasTrackMarker_ && this.getStep() != 0) {
            var min = this.getMin();
            var max = this.getMax();
            var step = this.getStep();
            var numMarkers = (max - min) / step; // In case distance between max & min is indivisible to step,
            // we place the secondary to last marker proportionally at where thumb
            // could reach and place the last marker at max value

            var indivisible = Math.ceil(numMarkers) !== numMarkers;

            if (indivisible) {
              numMarkers = Math.ceil(numMarkers);
            }

            this.adapter_.removeTrackMarkers();
            this.adapter_.appendTrackMarkers(numMarkers);

            if (indivisible) {
              var lastStepRatio = (max - numMarkers * step) / step + 1;
              var flex = getCorrectPropertyName(window, 'flex');
              this.adapter_.setLastTrackMarkersStyleProperty(flex, String(lastStepRatio));
            }
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          this.rect_ = this.adapter_.computeBoundingRect();
          this.updateUIForCurrentValue_();
        }
        /** @return {number} */

      }, {
        key: "getValue",
        value: function getValue() {
          return this.value_;
        }
        /** @param {number} value */

      }, {
        key: "setValue",
        value: function setValue(value) {
          this.setValue_(value, false);
        }
        /** @return {number} */

      }, {
        key: "getMax",
        value: function getMax() {
          return this.max_;
        }
        /** @param {number} max */

      }, {
        key: "setMax",
        value: function setMax(max) {
          if (max < this.min_) {
            throw new Error('Cannot set max to be less than the slider\'s minimum value');
          }

          this.max_ = max;
          this.setValue_(this.value_, false, true);
          this.adapter_.setAttribute(strings$g.ARIA_VALUEMAX, String(this.max_));
          this.setupTrackMarker();
        }
        /** @return {number} */

      }, {
        key: "getMin",
        value: function getMin() {
          return this.min_;
        }
        /** @param {number} min */

      }, {
        key: "setMin",
        value: function setMin(min) {
          if (min > this.max_) {
            throw new Error('Cannot set min to be greater than the slider\'s maximum value');
          }

          this.min_ = min;
          this.setValue_(this.value_, false, true);
          this.adapter_.setAttribute(strings$g.ARIA_VALUEMIN, String(this.min_));
          this.setupTrackMarker();
        }
        /** @return {number} */

      }, {
        key: "getStep",
        value: function getStep() {
          return this.step_;
        }
        /** @param {number} step */

      }, {
        key: "setStep",
        value: function setStep(step) {
          if (step < 0) {
            throw new Error('Step cannot be set to a negative number');
          }

          if (this.isDiscrete_ && (typeof step !== 'number' || step < 1)) {
            step = 1;
          }

          this.step_ = step;
          this.setValue_(this.value_, false, true);
          this.setupTrackMarker();
        }
        /** @return {boolean} */

      }, {
        key: "isDisabled",
        value: function isDisabled() {
          return this.disabled_;
        }
        /** @param {boolean} disabled */

      }, {
        key: "setDisabled",
        value: function setDisabled(disabled) {
          this.disabled_ = disabled;
          this.toggleClass_(cssClasses$h.DISABLED, this.disabled_);

          if (this.disabled_) {
            this.savedTabIndex_ = this.adapter_.getTabIndex();
            this.adapter_.setAttribute(strings$g.ARIA_DISABLED, 'true');
            this.adapter_.removeAttribute('tabindex');
          } else {
            this.adapter_.removeAttribute(strings$g.ARIA_DISABLED);

            if (!isNaN(this.savedTabIndex_)) {
              this.adapter_.setAttribute('tabindex', String(this.savedTabIndex_));
            }
          }
        }
        /**
         * Called when the user starts interacting with the slider
         * @param {!Event} evt
         * @private
         */

      }, {
        key: "handleDown_",
        value: function handleDown_(evt) {
          var _this4 = this;

          if (this.disabled_) {
            return;
          }

          this.preventFocusState_ = true;
          this.setInTransit_(!this.handlingThumbTargetEvt_);
          this.handlingThumbTargetEvt_ = false;
          this.setActive_(true);

          var moveHandler = function moveHandler(evt) {
            _this4.handleMove_(evt);
          }; // Note: upHandler is [de]registered on ALL potential pointer-related release event types, since some browsers
          // do not always fire these consistently in pairs.
          // (See https://github.com/material-components/material-components-web/issues/1192)


          var upHandler = function upHandler() {
            _this4.handleUp_();

            _this4.adapter_.deregisterBodyInteractionHandler(MOVE_EVENT_MAP[evt.type], moveHandler);

            UP_EVENTS.forEach(function (evtName) {
              return _this4.adapter_.deregisterBodyInteractionHandler(evtName, upHandler);
            });
          };

          this.adapter_.registerBodyInteractionHandler(MOVE_EVENT_MAP[evt.type], moveHandler);
          UP_EVENTS.forEach(function (evtName) {
            return _this4.adapter_.registerBodyInteractionHandler(evtName, upHandler);
          });
          this.setValueFromEvt_(evt);
        }
        /**
         * Called when the user moves the slider
         * @param {!Event} evt
         * @private
         */

      }, {
        key: "handleMove_",
        value: function handleMove_(evt) {
          evt.preventDefault();
          this.setValueFromEvt_(evt);
        }
        /**
         * Called when the user's interaction with the slider ends
         * @private
         */

      }, {
        key: "handleUp_",
        value: function handleUp_() {
          this.setActive_(false);
          this.adapter_.notifyChange();
        }
        /**
         * Returns the pageX of the event
         * @param {!Event} evt
         * @return {number}
         * @private
         */

      }, {
        key: "getPageX_",
        value: function getPageX_(evt) {
          if (evt.targetTouches && evt.targetTouches.length > 0) {
            return evt.targetTouches[0].pageX;
          }

          return evt.pageX;
        }
        /**
         * Sets the slider value from an event
         * @param {!Event} evt
         * @private
         */

      }, {
        key: "setValueFromEvt_",
        value: function setValueFromEvt_(evt) {
          var pageX = this.getPageX_(evt);
          var value = this.computeValueFromPageX_(pageX);
          this.setValue_(value, true);
        }
        /**
         * Computes the new value from the pageX position
         * @param {number} pageX
         * @return {number}
         */

      }, {
        key: "computeValueFromPageX_",
        value: function computeValueFromPageX_(pageX) {
          var max = this.max_,
              min = this.min_;
          var xPos = pageX - this.rect_.left;
          var pctComplete = xPos / this.rect_.width;

          if (this.adapter_.isRTL()) {
            pctComplete = 1 - pctComplete;
          } // Fit the percentage complete between the range [min,max]
          // by remapping from [0, 1] to [min, min+(max-min)].


          return min + pctComplete * (max - min);
        }
        /**
         * Handles keydown events
         * @param {!Event} evt
         */

      }, {
        key: "handleKeydown_",
        value: function handleKeydown_(evt) {
          var keyId = this.getKeyId_(evt);
          var value = this.getValueForKeyId_(keyId);

          if (isNaN(value)) {
            return;
          } // Prevent page from scrolling due to key presses that would normally scroll the page


          evt.preventDefault();
          this.adapter_.addClass(cssClasses$h.FOCUS);
          this.setValue_(value, true);
          this.adapter_.notifyChange();
        }
        /**
         * Returns the computed name of the event
         * @param {!Event} kbdEvt
         * @return {string}
         */

      }, {
        key: "getKeyId_",
        value: function getKeyId_(kbdEvt) {
          if (kbdEvt.key === KEY_IDS.ARROW_LEFT || kbdEvt.keyCode === 37) {
            return KEY_IDS.ARROW_LEFT;
          }

          if (kbdEvt.key === KEY_IDS.ARROW_RIGHT || kbdEvt.keyCode === 39) {
            return KEY_IDS.ARROW_RIGHT;
          }

          if (kbdEvt.key === KEY_IDS.ARROW_UP || kbdEvt.keyCode === 38) {
            return KEY_IDS.ARROW_UP;
          }

          if (kbdEvt.key === KEY_IDS.ARROW_DOWN || kbdEvt.keyCode === 40) {
            return KEY_IDS.ARROW_DOWN;
          }

          if (kbdEvt.key === KEY_IDS.HOME || kbdEvt.keyCode === 36) {
            return KEY_IDS.HOME;
          }

          if (kbdEvt.key === KEY_IDS.END || kbdEvt.keyCode === 35) {
            return KEY_IDS.END;
          }

          if (kbdEvt.key === KEY_IDS.PAGE_UP || kbdEvt.keyCode === 33) {
            return KEY_IDS.PAGE_UP;
          }

          if (kbdEvt.key === KEY_IDS.PAGE_DOWN || kbdEvt.keyCode === 34) {
            return KEY_IDS.PAGE_DOWN;
          }

          return '';
        }
        /**
         * Computes the value given a keyboard key ID
         * @param {string} keyId
         * @return {number}
         */

      }, {
        key: "getValueForKeyId_",
        value: function getValueForKeyId_(keyId) {
          var max = this.max_,
              min = this.min_,
              step = this.step_;
          var delta = step || (max - min) / 100;
          var valueNeedsToBeFlipped = this.adapter_.isRTL() && (keyId === KEY_IDS.ARROW_LEFT || keyId === KEY_IDS.ARROW_RIGHT);

          if (valueNeedsToBeFlipped) {
            delta = -delta;
          }

          switch (keyId) {
            case KEY_IDS.ARROW_LEFT:
            case KEY_IDS.ARROW_DOWN:
              return this.value_ - delta;

            case KEY_IDS.ARROW_RIGHT:
            case KEY_IDS.ARROW_UP:
              return this.value_ + delta;

            case KEY_IDS.HOME:
              return this.min_;

            case KEY_IDS.END:
              return this.max_;

            case KEY_IDS.PAGE_UP:
              return this.value_ + delta * numbers$b.PAGE_FACTOR;

            case KEY_IDS.PAGE_DOWN:
              return this.value_ - delta * numbers$b.PAGE_FACTOR;

            default:
              return NaN;
          }
        }
      }, {
        key: "handleFocus_",
        value: function handleFocus_() {
          if (this.preventFocusState_) {
            return;
          }

          this.adapter_.addClass(cssClasses$h.FOCUS);
        }
      }, {
        key: "handleBlur_",
        value: function handleBlur_() {
          this.preventFocusState_ = false;
          this.adapter_.removeClass(cssClasses$h.FOCUS);
        }
        /**
         * Sets the value of the slider
         * @param {number} value
         * @param {boolean} shouldFireInput
         * @param {boolean=} force
         */

      }, {
        key: "setValue_",
        value: function setValue_(value, shouldFireInput) {
          var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          if (value === this.value_ && !force) {
            return;
          }

          var min = this.min_,
              max = this.max_;
          var valueSetToBoundary = value === min || value === max;

          if (this.step_ && !valueSetToBoundary) {
            value = this.quantize_(value);
          }

          if (value < min) {
            value = min;
          } else if (value > max) {
            value = max;
          }

          this.value_ = value;
          this.adapter_.setAttribute(strings$g.ARIA_VALUENOW, String(this.value_));
          this.updateUIForCurrentValue_();

          if (shouldFireInput) {
            this.adapter_.notifyInput();

            if (this.isDiscrete_) {
              this.adapter_.setMarkerValue(value);
            }
          }
        }
        /**
         * Calculates the quantized value
         * @param {number} value
         * @return {number}
         */

      }, {
        key: "quantize_",
        value: function quantize_(value) {
          var numSteps = Math.round(value / this.step_);
          var quantizedVal = numSteps * this.step_;
          return quantizedVal;
        }
      }, {
        key: "updateUIForCurrentValue_",
        value: function updateUIForCurrentValue_() {
          var _this5 = this;

          var max = this.max_,
              min = this.min_,
              value = this.value_;
          var pctComplete = (value - min) / (max - min);
          var translatePx = pctComplete * this.rect_.width;

          if (this.adapter_.isRTL()) {
            translatePx = this.rect_.width - translatePx;
          }

          var transformProp = getCorrectPropertyName(window, 'transform');
          var transitionendEvtName = getCorrectEventName$1(window, 'transitionend');

          if (this.inTransit_) {
            var onTransitionEnd = function onTransitionEnd() {
              _this5.setInTransit_(false);

              _this5.adapter_.deregisterThumbContainerInteractionHandler(transitionendEvtName, onTransitionEnd);
            };

            this.adapter_.registerThumbContainerInteractionHandler(transitionendEvtName, onTransitionEnd);
          }

          this.updateUIFrame_ = requestAnimationFrame(function () {
            // NOTE(traviskaufman): It would be nice to use calc() here,
            // but IE cannot handle calcs in transforms correctly.
            // See: https://goo.gl/NC2itk
            // Also note that the -50% offset is used to center the slider thumb.
            _this5.adapter_.setThumbContainerStyleProperty(transformProp, "translateX(".concat(translatePx, "px) translateX(-50%)"));

            _this5.adapter_.setTrackStyleProperty(transformProp, "scaleX(".concat(pctComplete, ")"));
          });
        }
        /**
         * Toggles the active state of the slider
         * @param {boolean} active
         */

      }, {
        key: "setActive_",
        value: function setActive_(active) {
          this.active_ = active;
          this.toggleClass_(cssClasses$h.ACTIVE, this.active_);
        }
        /**
         * Toggles the inTransit state of the slider
         * @param {boolean} inTransit
         */

      }, {
        key: "setInTransit_",
        value: function setInTransit_(inTransit) {
          this.inTransit_ = inTransit;
          this.toggleClass_(cssClasses$h.IN_TRANSIT, this.inTransit_);
        }
        /**
         * Conditionally adds or removes a class based on shouldBePresent
         * @param {string} className
         * @param {boolean} shouldBePresent
         */

      }, {
        key: "toggleClass_",
        value: function toggleClass_(className, shouldBePresent) {
          if (shouldBePresent) {
            this.adapter_.addClass(className);
          } else {
            this.adapter_.removeClass(className);
          }
        }
      }]);

      return MDCSliderFoundation;
    }(MDCFoundation$i);

    /**
     * @extends MDCComponent<!MDCSliderFoundation>
     */

    var MDCSlider =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$j(MDCSlider, _MDCComponent);

      _createClass$j(MDCSlider, null, [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCSlider(root);
        }
      }]);

      function MDCSlider() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$j(this, MDCSlider);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$j(this, (_getPrototypeOf2 = _getPrototypeOf$j(MDCSlider)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {?Element} */

        _this.thumbContainer_;
        /** @type {?Element} */

        _this.track_;
        /** @type {?Element} */

        _this.pinValueMarker_;
        /** @type {?Element} */

        _this.trackMarkerContainer_;
        return _this;
      }
      /** @return {number} */


      _createClass$j(MDCSlider, [{
        key: "initialize",
        value: function initialize() {
          this.thumbContainer_ = this.root_.querySelector(strings$g.THUMB_CONTAINER_SELECTOR);
          this.track_ = this.root_.querySelector(strings$g.TRACK_SELECTOR);
          this.pinValueMarker_ = this.root_.querySelector(strings$g.PIN_VALUE_MARKER_SELECTOR);
          this.trackMarkerContainer_ = this.root_.querySelector(strings$g.TRACK_MARKER_CONTAINER_SELECTOR);
        }
        /**
         * @return {!MDCSliderFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this2 = this;

          return new MDCSliderFoundation(
          /** @type {!MDCSliderAdapter} */
          {
            hasClass: function hasClass(className) {
              return _this2.root_.classList.contains(className);
            },
            addClass: function addClass(className) {
              return _this2.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this2.root_.classList.remove(className);
            },
            getAttribute: function getAttribute(name) {
              return _this2.root_.getAttribute(name);
            },
            setAttribute: function setAttribute(name, value) {
              return _this2.root_.setAttribute(name, value);
            },
            removeAttribute: function removeAttribute(name) {
              return _this2.root_.removeAttribute(name);
            },
            computeBoundingRect: function computeBoundingRect() {
              return _this2.root_.getBoundingClientRect();
            },
            getTabIndex: function getTabIndex() {
              return _this2.root_.tabIndex;
            },
            registerInteractionHandler: function registerInteractionHandler(type, handler) {
              _this2.root_.addEventListener(type, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
              _this2.root_.removeEventListener(type, handler);
            },
            registerThumbContainerInteractionHandler: function registerThumbContainerInteractionHandler(type, handler) {
              _this2.thumbContainer_.addEventListener(type, handler);
            },
            deregisterThumbContainerInteractionHandler: function deregisterThumbContainerInteractionHandler(type, handler) {
              _this2.thumbContainer_.removeEventListener(type, handler);
            },
            registerBodyInteractionHandler: function registerBodyInteractionHandler(type, handler) {
              document.body.addEventListener(type, handler);
            },
            deregisterBodyInteractionHandler: function deregisterBodyInteractionHandler(type, handler) {
              document.body.removeEventListener(type, handler);
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              window.removeEventListener('resize', handler);
            },
            notifyInput: function notifyInput() {
              _this2.emit(strings$g.INPUT_EVENT, _this2);
            },
            notifyChange: function notifyChange() {
              _this2.emit(strings$g.CHANGE_EVENT, _this2);
            },
            setThumbContainerStyleProperty: function setThumbContainerStyleProperty(propertyName, value) {
              _this2.thumbContainer_.style.setProperty(propertyName, value);
            },
            setTrackStyleProperty: function setTrackStyleProperty(propertyName, value) {
              _this2.track_.style.setProperty(propertyName, value);
            },
            setMarkerValue: function setMarkerValue(value) {
              _this2.pinValueMarker_.innerText = value;
            },
            appendTrackMarkers: function appendTrackMarkers(numMarkers) {
              var frag = document.createDocumentFragment();

              for (var i = 0; i < numMarkers; i++) {
                var marker = document.createElement('div');
                marker.classList.add('mdc-slider__track-marker');
                frag.appendChild(marker);
              }

              _this2.trackMarkerContainer_.appendChild(frag);
            },
            removeTrackMarkers: function removeTrackMarkers() {
              while (_this2.trackMarkerContainer_.firstChild) {
                _this2.trackMarkerContainer_.removeChild(_this2.trackMarkerContainer_.firstChild);
              }
            },
            setLastTrackMarkersStyleProperty: function setLastTrackMarkersStyleProperty(propertyName, value) {
              // We remove and append new nodes, thus, the last track marker must be dynamically found.
              var lastTrackMarker = _this2.root_.querySelector(strings$g.LAST_TRACK_MARKER_SELECTOR);

              lastTrackMarker.style.setProperty(propertyName, value);
            },
            isRTL: function isRTL() {
              return getComputedStyle(_this2.root_).direction === 'rtl';
            }
          });
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          var origValueNow = parseFloat(this.root_.getAttribute(strings$g.ARIA_VALUENOW));
          this.min = parseFloat(this.root_.getAttribute(strings$g.ARIA_VALUEMIN)) || this.min;
          this.max = parseFloat(this.root_.getAttribute(strings$g.ARIA_VALUEMAX)) || this.max;
          this.step = parseFloat(this.root_.getAttribute(strings$g.STEP_DATA_ATTR)) || this.step;
          this.value = origValueNow || this.value;
          this.disabled = this.root_.hasAttribute(strings$g.ARIA_DISABLED) && this.root_.getAttribute(strings$g.ARIA_DISABLED) !== 'false';
          this.foundation_.setupTrackMarker();
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
        /** @param {number=} amount */

      }, {
        key: "stepUp",
        value: function stepUp() {
          var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.step || 1;
          this.value += amount;
        }
        /** @param {number=} amount */

      }, {
        key: "stepDown",
        value: function stepDown() {
          var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.step || 1;
          this.value -= amount;
        }
      }, {
        key: "value",
        get: function get() {
          return this.foundation_.getValue();
        }
        /** @param {number} value */
        ,
        set: function set(value) {
          this.foundation_.setValue(value);
        }
        /** @return {number} */

      }, {
        key: "min",
        get: function get() {
          return this.foundation_.getMin();
        }
        /** @param {number} min */
        ,
        set: function set(min) {
          this.foundation_.setMin(min);
        }
        /** @return {number} */

      }, {
        key: "max",
        get: function get() {
          return this.foundation_.getMax();
        }
        /** @param {number} max */
        ,
        set: function set(max) {
          this.foundation_.setMax(max);
        }
        /** @return {number} */

      }, {
        key: "step",
        get: function get() {
          return this.foundation_.getStep();
        }
        /** @param {number} step */
        ,
        set: function set(step) {
          this.foundation_.setStep(step);
        }
        /** @return {boolean} */

      }, {
        key: "disabled",
        get: function get() {
          return this.foundation_.isDisabled();
        }
        /** @param {boolean} disabled */
        ,
        set: function set(disabled) {
          this.foundation_.setDisabled(disabled);
        }
      }]);

      return MDCSlider;
    }(MDCComponent$h);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ MDC_SLIDER_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return MdcSlider; }),
        multi: true
    };
    var MdcSliderChange = /** @class */ (function () {
        function MdcSliderChange(source, value) {
            this.source = source;
            this.value = value;
        }
        return MdcSliderChange;
    }());
    var MdcSlider = /** @class */ (function () {
        function MdcSlider(_changeDetectorRef, _renderer, elementRef, _registry) {
            var _this = this;
            this._changeDetectorRef = _changeDetectorRef;
            this._renderer = _renderer;
            this.elementRef = elementRef;
            this._registry = _registry;
            this.tabIndex = 0;
            this.name = null;
            this._discrete = false;
            this._markers = false;
            this._min = 0;
            this._max = 100;
            this._step = 0;
            this._value = 0;
            this._disabled = false;
            this.change = new core.EventEmitter();
            this.input = new core.EventEmitter();
            this.isHostClass = true;
            this.role = 'slider';
            /**
             * View -> model callback called when value changes
             */
            this._onChange = function () { };
            /**
             * View -> model callback called when radio has been touched
             */
            this._onTouched = function () { };
            this._mdcAdapter = {
                hasClass: function (className) { return _this._getHostElement().classList.contains(className); },
                addClass: function (className) { return _this._renderer.addClass(_this._getHostElement(), className); },
                removeClass: function (className) { return _this._renderer.removeClass(_this._getHostElement(), className); },
                getAttribute: function (name) { return _this._getHostElement().getAttribute(name); },
                setAttribute: function (name, value) { return _this._renderer.setAttribute(_this._getHostElement(), name, value); },
                removeAttribute: function (name) { return _this._renderer.removeAttribute(_this._getHostElement(), name); },
                computeBoundingRect: function () { return _this._getHostElement().getBoundingClientRect(); },
                getTabIndex: function () { return _this._getHostElement().tabIndex; },
                registerInteractionHandler: function (type, handler) {
                    return _this._registry.listen(type, handler, _this._getHostElement());
                },
                deregisterInteractionHandler: function (type, handler) { return _this._registry.unlisten(type, handler); },
                registerThumbContainerInteractionHandler: function (type, handler) {
                    if (_this.thumbContainer) {
                        _this._registry.listen(type, handler, _this.thumbContainer.nativeElement);
                    }
                },
                deregisterThumbContainerInteractionHandler: function (type, handler) {
                    return _this._registry.unlisten(type, handler);
                },
                registerBodyInteractionHandler: function (type, handler) {
                    if (isBrowser()) {
                        _this._registry.listen(type, handler, document.body);
                    }
                },
                deregisterBodyInteractionHandler: function (type, handler) { return _this._registry.unlisten(type, handler); },
                registerResizeHandler: function (handler) {
                    if (isBrowser()) {
                        _this._registry.listen('resize', handler, window);
                    }
                },
                deregisterResizeHandler: function (handler) { return _this._registry.unlisten('resize', handler); },
                notifyInput: function () {
                    _this.input.emit(new MdcSliderChange(_this, _this.getValue()));
                    _this._onTouched();
                },
                notifyChange: function () {
                    _this.change.emit(new MdcSliderChange(_this, _this.getValue()));
                    _this.setValue(_this.getValue());
                },
                setThumbContainerStyleProperty: function (propertyName, value) {
                    return _this._renderer.setStyle(_this.thumbContainer.nativeElement, propertyName, value);
                },
                setTrackStyleProperty: function (propertyName, value) {
                    return _this._renderer.setStyle(_this.track.nativeElement, propertyName, value);
                },
                setMarkerValue: function (value) { return _this.pinValueMarker.nativeElement.innerText = value; },
                appendTrackMarkers: function (numMarkers) {
                    for (var /** @type {?} */ i = 0; i < numMarkers; i++) {
                        var /** @type {?} */ marker = _this._renderer.createElement('div');
                        _this._renderer.addClass(marker, 'mdc-slider__track-marker');
                        _this._renderer.appendChild(_this.trackMarkerContainer.nativeElement, marker);
                    }
                },
                removeTrackMarkers: function () {
                    while (_this.trackMarkerContainer.nativeElement.firstChild) {
                        _this._renderer.removeChild(_this.trackMarkerContainer.nativeElement, _this.trackMarkerContainer.nativeElement.firstChild);
                    }
                },
                setLastTrackMarkersStyleProperty: function (propertyName, value) {
                    return _this._renderer.setStyle(_this.trackMarkerContainer.nativeElement.lastChild, propertyName, value);
                },
                isRTL: function () { return getComputedStyle(_this._getHostElement()).direction === 'rtl'; }
            };
        }
        Object.defineProperty(MdcSlider.prototype, "discrete", {
            get: /**
             * @return {?}
             */
            function () { return this._discrete; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setDiscrete(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSlider.prototype, "markers", {
            get: /**
             * @return {?}
             */
            function () { return this._markers; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setMarkers(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSlider.prototype, "min", {
            get: /**
             * @return {?}
             */
            function () { return this._min; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setMin(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSlider.prototype, "max", {
            get: /**
             * @return {?}
             */
            function () { return this._max; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setMax(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSlider.prototype, "step", {
            get: /**
             * @return {?}
             */
            function () { return this._step; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setStep(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSlider.prototype, "value", {
            get: /**
             * @return {?}
             */
            function () { return this._value; },
            set: /**
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                this.setValue(newValue);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSlider.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setDisabled(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSlider.prototype, "classDiscrete", {
            get: /**
             * @return {?}
             */
            function () {
                return this.discrete ? 'mdc-slider--discrete' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSlider.prototype, "classDisplayMarkers", {
            get: /**
             * @return {?}
             */
            function () {
                return this.markers && this.discrete ? 'mdc-slider--display-markers' : '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcSlider.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this._foundation = new MDCSliderFoundation(this._mdcAdapter);
            this._foundation.init();
            this.setMin(this.min);
            this.setMax(this.max);
            this.setStep(this.step);
            this.setValue(this.value);
            this._foundation.setupTrackMarker();
        };
        /**
         * @return {?}
         */
        MdcSlider.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._foundation.destroy();
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MdcSlider.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                if (value !== this.value) {
                    this.setValue(value);
                }
            }
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcSlider.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcSlider.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onTouched = fn;
        };
        /**
         * @param {?} discrete
         * @return {?}
         */
        MdcSlider.prototype.setDiscrete = /**
         * @param {?} discrete
         * @return {?}
         */
        function (discrete) {
            this._discrete = discrete;
        };
        /**
         * @param {?} markers
         * @return {?}
         */
        MdcSlider.prototype.setMarkers = /**
         * @param {?} markers
         * @return {?}
         */
        function (markers) {
            this._markers = markers;
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MdcSlider.prototype.setValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this.disabled) {
                return;
            }
            var /** @type {?} */ previousValue = this.value;
            this._value = value;
            if (!this._foundation) {
                return;
            }
            this._foundation.setValue(value);
            if (value !== previousValue) {
                this._onChange(value);
            }
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @return {?}
         */
        MdcSlider.prototype.getValue = /**
         * @return {?}
         */
        function () {
            return this._foundation.getValue();
        };
        /**
         * @return {?}
         */
        MdcSlider.prototype.layout = /**
         * @return {?}
         */
        function () {
            this._foundation.layout();
        };
        /**
         * @param {?} min
         * @return {?}
         */
        MdcSlider.prototype.setMin = /**
         * @param {?} min
         * @return {?}
         */
        function (min) {
            if (min > this.max) {
                return;
            }
            this._min = min;
            if (!this._foundation) {
                return;
            }
            this._foundation.setMin(toNumber(min, 0));
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @return {?}
         */
        MdcSlider.prototype.getMin = /**
         * @return {?}
         */
        function () {
            return this._foundation.getMin();
        };
        /**
         * @param {?} max
         * @return {?}
         */
        MdcSlider.prototype.setMax = /**
         * @param {?} max
         * @return {?}
         */
        function (max) {
            if (this.min > max) {
                return;
            }
            this._max = max;
            if (!this._foundation) {
                return;
            }
            this._foundation.setMax(toNumber(max, 100));
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @return {?}
         */
        MdcSlider.prototype.getMax = /**
         * @return {?}
         */
        function () {
            return this._foundation.getMax();
        };
        /**
         * @param {?} step
         * @return {?}
         */
        MdcSlider.prototype.setStep = /**
         * @param {?} step
         * @return {?}
         */
        function (step) {
            this._step = step;
            if (!this._foundation) {
                return;
            }
            this._foundation.setStep(step);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @return {?}
         */
        MdcSlider.prototype.getStep = /**
         * @return {?}
         */
        function () {
            return this._foundation.getStep();
        };
        /**
         * @param {?} disabled
         * @return {?}
         */
        MdcSlider.prototype.setDisabled = /**
         * @param {?} disabled
         * @return {?}
         */
        function (disabled) {
            this.setDisabledState(disabled);
        };
        /**
         * @param {?} disabled
         * @return {?}
         */
        MdcSlider.prototype.setDisabledState = /**
         * @param {?} disabled
         * @return {?}
         */
        function (disabled) {
            this._disabled = disabled;
            if (!this._foundation) {
                return;
            }
            this._foundation.setDisabled(disabled);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        MdcSlider.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcSlider.decorators = [
            { type: core.Component, args: [{selector: 'mdc-slider',
                        exportAs: 'mdcSlider',
                        template: "\n    <div class=\"mdc-slider__track-container\">\n      <div #track class=\"mdc-slider__track\"></div>\n      <div #markercontainer *ngIf=\"markers\" class=\"mdc-slider__track-marker-container\"></div>\n    </div>\n    <div #thumbcontainer class=\"mdc-slider__thumb-container\">\n      <div *ngIf=\"discrete\" class=\"mdc-slider__pin\">\n        <span #pin class=\"mdc-slider__pin-value-marker\"></span>\n      </div>\n      <svg class=\"mdc-slider__thumb\" width=\"21\" height=\"21\">\n        <circle cx=\"10.5\" cy=\"10.5\" r=\"7.875\"></circle>\n      </svg>\n      <div class=\"mdc-slider__focus-ring\"></div>\n    </div>\n  ",
                        providers: [
                            MDC_SLIDER_CONTROL_VALUE_ACCESSOR,
                            EventRegistry,
                        ],
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcSlider.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.Renderer2 },
            { type: core.ElementRef },
            { type: EventRegistry }
        ]; };
        MdcSlider.propDecorators = {
            tabIndex: [{ type: core.Input }],
            name: [{ type: core.Input }],
            discrete: [{ type: core.Input }],
            markers: [{ type: core.Input }],
            min: [{ type: core.Input }],
            max: [{ type: core.Input }],
            step: [{ type: core.Input }],
            value: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            change: [{ type: core.Output }],
            input: [{ type: core.Output }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-slider',] }],
            role: [{ type: core.HostBinding, args: ['attr.role',] }],
            classDiscrete: [{ type: core.HostBinding, args: ['class.mdc-slider--discrete',] }],
            classDisplayMarkers: [{ type: core.HostBinding, args: ['class.mdc-slider--display-markers',] }],
            thumbContainer: [{ type: core.ViewChild, args: ['thumbcontainer',] }],
            track: [{ type: core.ViewChild, args: ['track',] }],
            pinValueMarker: [{ type: core.ViewChild, args: ['pin',] }],
            trackMarkerContainer: [{ type: core.ViewChild, args: ['markercontainer',] }]
        };
        return MdcSlider;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcSliderModule = /** @class */ (function () {
        function MdcSliderModule() {
        }
        MdcSliderModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [MdcSlider],
                        declarations: [MdcSlider]
                    },] },
        ];
        return MdcSliderModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Reference to a snackbar dispatched from the snackbar service.
     * @template T
     */
    var   /**
     * Reference to a snackbar dispatched from the snackbar service.
     * @template T
     */
    MdcSnackbarRef = /** @class */ (function () {
        function MdcSnackbarRef(component) {
            /**
             * Subject for notifying the user that the snackbar has been dismissed.
             */
            this._afterDismiss = new rxjs.Subject();
            this.componentInstance = component;
        }
        /** Gets an observable that is notified when the snackbar is finished closing. */
        /**
         * Gets an observable that is notified when the snackbar is finished closing.
         * @return {?}
         */
        MdcSnackbarRef.prototype.afterDismiss = /**
         * Gets an observable that is notified when the snackbar is finished closing.
         * @return {?}
         */
        function () {
            return this._afterDismiss.asObservable();
        };
        /**
         * @return {?}
         */
        MdcSnackbarRef.prototype.dismiss = /**
         * @return {?}
         */
        function () {
            this._afterDismiss.next();
            this._afterDismiss.complete();
        };
        return MdcSnackbarRef;
    }());

    function _classCallCheck$k(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$k(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$k(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$k(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$k(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$k(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$k(subClass, superClass);
    }

    function _getPrototypeOf$k(o) {
      _getPrototypeOf$k = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$k(o);
    }

    function _setPrototypeOf$k(o, p) {
      _setPrototypeOf$k = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$k(o, p);
    }

    function _assertThisInitialized$k(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$k(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$k(self);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @template A
     */
    var MDCFoundation$j =
    /*#__PURE__*/
    function () {
      _createClass$k(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$k(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$k(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$i =
    /*#__PURE__*/
    function () {
      _createClass$k(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$j());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$k(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$k(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var cssClasses$i = {
      ROOT: 'mdc-snackbar',
      TEXT: 'mdc-snackbar__text',
      ACTION_WRAPPER: 'mdc-snackbar__action-wrapper',
      ACTION_BUTTON: 'mdc-snackbar__action-button',
      ACTIVE: 'mdc-snackbar--active',
      MULTILINE: 'mdc-snackbar--multiline',
      ACTION_ON_BOTTOM: 'mdc-snackbar--action-on-bottom'
    };
    var strings$h = {
      TEXT_SELECTOR: '.mdc-snackbar__text',
      ACTION_WRAPPER_SELECTOR: '.mdc-snackbar__action-wrapper',
      ACTION_BUTTON_SELECTOR: '.mdc-snackbar__action-button',
      SHOW_EVENT: 'MDCSnackbar:show',
      HIDE_EVENT: 'MDCSnackbar:hide'
    };
    var numbers$c = {
      MESSAGE_TIMEOUT: 2750
    };

    var MDCSnackbarFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$k(MDCSnackbarFoundation, _MDCFoundation);

      _createClass$k(MDCSnackbarFoundation, [{
        key: "active",
        get: function get() {
          return this.active_;
        }
      }], [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$i;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$h;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            setAriaHidden: function setAriaHidden() {},
            unsetAriaHidden: function unsetAriaHidden() {},
            setActionAriaHidden: function setActionAriaHidden() {},
            unsetActionAriaHidden: function unsetActionAriaHidden() {},
            setActionText: function setActionText()
            /* actionText: string */
            {},
            setMessageText: function setMessageText()
            /* message: string */
            {},
            setFocus: function setFocus() {},
            visibilityIsHidden: function visibilityIsHidden() {
              return (
                /* boolean */
                false
              );
            },
            registerCapturedBlurHandler: function registerCapturedBlurHandler()
            /* handler: EventListener */
            {},
            deregisterCapturedBlurHandler: function deregisterCapturedBlurHandler()
            /* handler: EventListener */
            {},
            registerVisibilityChangeHandler: function registerVisibilityChangeHandler()
            /* handler: EventListener */
            {},
            deregisterVisibilityChangeHandler: function deregisterVisibilityChangeHandler()
            /* handler: EventListener */
            {},
            registerCapturedInteractionHandler: function registerCapturedInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterCapturedInteractionHandler: function deregisterCapturedInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerActionClickHandler: function registerActionClickHandler()
            /* handler: EventListener */
            {},
            deregisterActionClickHandler: function deregisterActionClickHandler()
            /* handler: EventListener */
            {},
            registerTransitionEndHandler: function registerTransitionEndHandler()
            /* handler: EventListener */
            {},
            deregisterTransitionEndHandler: function deregisterTransitionEndHandler()
            /* handler: EventListener */
            {},
            notifyShow: function notifyShow() {},
            notifyHide: function notifyHide() {}
          };
        }
      }]);

      function MDCSnackbarFoundation(adapter) {
        var _this;

        _classCallCheck$k(this, MDCSnackbarFoundation);

        _this = _possibleConstructorReturn$k(this, _getPrototypeOf$k(MDCSnackbarFoundation).call(this, Object.assign(MDCSnackbarFoundation.defaultAdapter, adapter)));
        _this.active_ = false;
        _this.actionWasClicked_ = false;
        _this.dismissOnAction_ = true;
        _this.firstFocus_ = true;
        _this.pointerDownRecognized_ = false;
        _this.snackbarHasFocus_ = false;
        _this.snackbarData_ = null;
        _this.queue_ = [];

        _this.actionClickHandler_ = function () {
          _this.actionWasClicked_ = true;

          _this.invokeAction_();
        };

        _this.visibilitychangeHandler_ = function () {
          clearTimeout(_this.timeoutId_);
          _this.snackbarHasFocus_ = true;

          if (!_this.adapter_.visibilityIsHidden()) {
            setTimeout(_this.cleanup_.bind(_assertThisInitialized$k(_assertThisInitialized$k(_this))), _this.snackbarData_.timeout || numbers$c.MESSAGE_TIMEOUT);
          }
        };

        _this.interactionHandler_ = function (evt) {
          if (evt.type == 'touchstart' || evt.type == 'mousedown') {
            _this.pointerDownRecognized_ = true;
          }

          _this.handlePossibleTabKeyboardFocus_(evt);

          if (evt.type == 'focus') {
            _this.pointerDownRecognized_ = false;
          }
        };

        _this.blurHandler_ = function () {
          clearTimeout(_this.timeoutId_);
          _this.snackbarHasFocus_ = false;
          _this.timeoutId_ = setTimeout(_this.cleanup_.bind(_assertThisInitialized$k(_assertThisInitialized$k(_this))), _this.snackbarData_.timeout || numbers$c.MESSAGE_TIMEOUT);
        };

        return _this;
      }

      _createClass$k(MDCSnackbarFoundation, [{
        key: "init",
        value: function init() {
          this.adapter_.registerActionClickHandler(this.actionClickHandler_);
          this.adapter_.setAriaHidden();
          this.adapter_.setActionAriaHidden();
        }
      }, {
        key: "destroy",
        value: function destroy() {
          var _this2 = this;

          this.adapter_.deregisterActionClickHandler(this.actionClickHandler_);
          this.adapter_.deregisterCapturedBlurHandler(this.blurHandler_);
          this.adapter_.deregisterVisibilityChangeHandler(this.visibilitychangeHandler_);
          ['touchstart', 'mousedown', 'focus'].forEach(function (evtType) {
            _this2.adapter_.deregisterCapturedInteractionHandler(evtType, _this2.interactionHandler_);
          });
        }
      }, {
        key: "dismissesOnAction",
        value: function dismissesOnAction() {
          return this.dismissOnAction_;
        }
      }, {
        key: "setDismissOnAction",
        value: function setDismissOnAction(dismissOnAction) {
          this.dismissOnAction_ = !!dismissOnAction;
        }
      }, {
        key: "show",
        value: function show(data) {
          var _this3 = this;

          if (!data) {
            throw new Error('Please provide a data object with at least a message to display.');
          }

          if (!data.message) {
            throw new Error('Please provide a message to be displayed.');
          }

          if (data.actionHandler && !data.actionText) {
            throw new Error('Please provide action text with the handler.');
          }

          if (this.active) {
            this.queue_.push(data);
            return;
          }

          clearTimeout(this.timeoutId_);
          this.snackbarData_ = data;
          this.firstFocus_ = true;
          this.adapter_.registerVisibilityChangeHandler(this.visibilitychangeHandler_);
          this.adapter_.registerCapturedBlurHandler(this.blurHandler_);
          ['touchstart', 'mousedown', 'focus'].forEach(function (evtType) {
            _this3.adapter_.registerCapturedInteractionHandler(evtType, _this3.interactionHandler_);
          });
          var ACTIVE = cssClasses$i.ACTIVE,
              MULTILINE = cssClasses$i.MULTILINE,
              ACTION_ON_BOTTOM = cssClasses$i.ACTION_ON_BOTTOM;
          this.adapter_.setMessageText(this.snackbarData_.message);

          if (this.snackbarData_.multiline) {
            this.adapter_.addClass(MULTILINE);

            if (this.snackbarData_.actionOnBottom) {
              this.adapter_.addClass(ACTION_ON_BOTTOM);
            }
          }

          if (this.snackbarData_.actionHandler) {
            this.adapter_.setActionText(this.snackbarData_.actionText);
            this.actionHandler_ = this.snackbarData_.actionHandler;
            this.setActionHidden_(false);
          } else {
            this.setActionHidden_(true);
            this.actionHandler_ = null;
            this.adapter_.setActionText(null);
          }

          this.active_ = true;
          this.adapter_.addClass(ACTIVE);
          this.adapter_.unsetAriaHidden();
          this.adapter_.notifyShow();
          this.timeoutId_ = setTimeout(this.cleanup_.bind(this), this.snackbarData_.timeout || numbers$c.MESSAGE_TIMEOUT);
        }
      }, {
        key: "handlePossibleTabKeyboardFocus_",
        value: function handlePossibleTabKeyboardFocus_() {
          var hijackFocus = this.firstFocus_ && !this.pointerDownRecognized_;

          if (hijackFocus) {
            this.setFocusOnAction_();
          }

          this.firstFocus_ = false;
        }
      }, {
        key: "setFocusOnAction_",
        value: function setFocusOnAction_() {
          this.adapter_.setFocus();
          this.snackbarHasFocus_ = true;
          this.firstFocus_ = false;
        }
      }, {
        key: "invokeAction_",
        value: function invokeAction_() {
          try {
            if (!this.actionHandler_) {
              return;
            }

            this.actionHandler_();
          } finally {
            if (this.dismissOnAction_) {
              this.cleanup_();
            }
          }
        }
      }, {
        key: "cleanup_",
        value: function cleanup_() {
          var _this4 = this;

          var allowDismissal = !this.snackbarHasFocus_ || this.actionWasClicked_;

          if (allowDismissal) {
            var ACTIVE = cssClasses$i.ACTIVE,
                MULTILINE = cssClasses$i.MULTILINE,
                ACTION_ON_BOTTOM = cssClasses$i.ACTION_ON_BOTTOM;
            this.adapter_.removeClass(ACTIVE);

            var handler = function handler() {
              clearTimeout(_this4.timeoutId_);

              _this4.adapter_.deregisterTransitionEndHandler(handler);

              _this4.adapter_.removeClass(MULTILINE);

              _this4.adapter_.removeClass(ACTION_ON_BOTTOM);

              _this4.setActionHidden_(true);

              _this4.adapter_.setAriaHidden();

              _this4.active_ = false;
              _this4.snackbarHasFocus_ = false;

              _this4.adapter_.notifyHide();

              _this4.showNext_();
            };

            this.adapter_.registerTransitionEndHandler(handler);
          }
        }
      }, {
        key: "showNext_",
        value: function showNext_() {
          if (!this.queue_.length) {
            return;
          }

          this.show(this.queue_.shift());
        }
      }, {
        key: "setActionHidden_",
        value: function setActionHidden_(isHidden) {
          if (isHidden) {
            this.adapter_.setActionAriaHidden();
          } else {
            this.adapter_.unsetActionAriaHidden();
          }
        }
      }]);

      return MDCSnackbarFoundation;
    }(MDCFoundation$j);

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /** @const {Object<string, !VendorPropertyMapType>} */

    var eventTypeMap$2 = {
      'animationstart': {
        noPrefix: 'animationstart',
        webkitPrefix: 'webkitAnimationStart',
        styleProperty: 'animation'
      },
      'animationend': {
        noPrefix: 'animationend',
        webkitPrefix: 'webkitAnimationEnd',
        styleProperty: 'animation'
      },
      'animationiteration': {
        noPrefix: 'animationiteration',
        webkitPrefix: 'webkitAnimationIteration',
        styleProperty: 'animation'
      },
      'transitionend': {
        noPrefix: 'transitionend',
        webkitPrefix: 'webkitTransitionEnd',
        styleProperty: 'transition'
      }
    };
    /** @const {Object<string, !VendorPropertyMapType>} */

    var cssPropertyMap$2 = {
      'animation': {
        noPrefix: 'animation',
        webkitPrefix: '-webkit-animation'
      },
      'transform': {
        noPrefix: 'transform',
        webkitPrefix: '-webkit-transform'
      },
      'transition': {
        noPrefix: 'transition',
        webkitPrefix: '-webkit-transition'
      }
    };
    /**
     * @param {!Object} windowObj
     * @return {boolean}
     */

    function hasProperShape$2(windowObj) {
      return windowObj['document'] !== undefined && typeof windowObj['document']['createElement'] === 'function';
    }
    /**
     * @param {string} eventType
     * @return {boolean}
     */


    function eventFoundInMaps$2(eventType) {
      return eventType in eventTypeMap$2 || eventType in cssPropertyMap$2;
    }
    /**
     * @param {string} eventType
     * @param {!Object<string, !VendorPropertyMapType>} map
     * @param {!Element} el
     * @return {string}
     */


    function getJavaScriptEventName$2(eventType, map, el) {
      return map[eventType].styleProperty in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
    }
    /**
     * Helper function to determine browser prefix for CSS3 animation events
     * and property names.
     * @param {!Object} windowObj
     * @param {string} eventType
     * @return {string}
     */


    function getAnimationName$2(windowObj, eventType) {
      if (!hasProperShape$2(windowObj) || !eventFoundInMaps$2(eventType)) {
        return eventType;
      }

      var map =
      /** @type {!Object<string, !VendorPropertyMapType>} */
      eventType in eventTypeMap$2 ? eventTypeMap$2 : cssPropertyMap$2;
      var el = windowObj['document']['createElement']('div');
      var eventName = '';

      if (map === eventTypeMap$2) {
        eventName = getJavaScriptEventName$2(eventType, map, el);
      } else {
        eventName = map[eventType].noPrefix in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
      }

      return eventName;
    } // Public functions to access getAnimationName() for JavaScript events or CSS
    /**
     * @param {!Object} windowObj
     * @param {string} eventType
     * @return {string}
     */

    function getCorrectEventName$2(windowObj, eventType) {
      return getAnimationName$2(windowObj, eventType);
    }

    var MDCSnackbar =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$k(MDCSnackbar, _MDCComponent);

      function MDCSnackbar() {
        _classCallCheck$k(this, MDCSnackbar);

        return _possibleConstructorReturn$k(this, _getPrototypeOf$k(MDCSnackbar).apply(this, arguments));
      }

      _createClass$k(MDCSnackbar, [{
        key: "show",
        value: function show(data) {
          this.foundation_.show(data);
        }
      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this = this;

          var _MDCSnackbarFoundatio = MDCSnackbarFoundation.strings,
              TEXT_SELECTOR = _MDCSnackbarFoundatio.TEXT_SELECTOR,
              ACTION_BUTTON_SELECTOR = _MDCSnackbarFoundatio.ACTION_BUTTON_SELECTOR;

          var getText = function getText() {
            return _this.root_.querySelector(TEXT_SELECTOR);
          };

          var getActionButton = function getActionButton() {
            return _this.root_.querySelector(ACTION_BUTTON_SELECTOR);
          };
          /* eslint brace-style: "off" */


          return new MDCSnackbarFoundation({
            addClass: function addClass(className) {
              return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this.root_.classList.remove(className);
            },
            setAriaHidden: function setAriaHidden() {
              return _this.root_.setAttribute('aria-hidden', 'true');
            },
            unsetAriaHidden: function unsetAriaHidden() {
              return _this.root_.removeAttribute('aria-hidden');
            },
            setActionAriaHidden: function setActionAriaHidden() {
              return getActionButton().setAttribute('aria-hidden', 'true');
            },
            unsetActionAriaHidden: function unsetActionAriaHidden() {
              return getActionButton().removeAttribute('aria-hidden');
            },
            setActionText: function setActionText(text) {
              getActionButton().textContent = text;
            },
            setMessageText: function setMessageText(text) {
              getText().textContent = text;
            },
            setFocus: function setFocus() {
              return getActionButton().focus();
            },
            visibilityIsHidden: function visibilityIsHidden() {
              return document.hidden;
            },
            registerCapturedBlurHandler: function registerCapturedBlurHandler(handler) {
              return getActionButton().addEventListener('blur', handler, true);
            },
            deregisterCapturedBlurHandler: function deregisterCapturedBlurHandler(handler) {
              return getActionButton().removeEventListener('blur', handler, true);
            },
            registerVisibilityChangeHandler: function registerVisibilityChangeHandler(handler) {
              return document.addEventListener('visibilitychange', handler);
            },
            deregisterVisibilityChangeHandler: function deregisterVisibilityChangeHandler(handler) {
              return document.removeEventListener('visibilitychange', handler);
            },
            registerCapturedInteractionHandler: function registerCapturedInteractionHandler(evt, handler) {
              return document.body.addEventListener(evt, handler, true);
            },
            deregisterCapturedInteractionHandler: function deregisterCapturedInteractionHandler(evt, handler) {
              return document.body.removeEventListener(evt, handler, true);
            },
            registerActionClickHandler: function registerActionClickHandler(handler) {
              return getActionButton().addEventListener('click', handler);
            },
            deregisterActionClickHandler: function deregisterActionClickHandler(handler) {
              return getActionButton().removeEventListener('click', handler);
            },
            registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
              return _this.root_.addEventListener(getCorrectEventName$2(window, 'transitionend'), handler);
            },
            deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
              return _this.root_.removeEventListener(getCorrectEventName$2(window, 'transitionend'), handler);
            },
            notifyShow: function notifyShow() {
              return _this.emit(MDCSnackbarFoundation.strings.SHOW_EVENT);
            },
            notifyHide: function notifyHide() {
              return _this.emit(MDCSnackbarFoundation.strings.HIDE_EVENT);
            }
          });
        }
      }, {
        key: "dismissesOnAction",
        get: function get() {
          return this.foundation_.dismissesOnAction();
        },
        set: function set(dismissesOnAction) {
          this.foundation_.setDismissOnAction(dismissesOnAction);
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCSnackbar(root);
        }
      }]);

      return MDCSnackbar;
    }(MDCComponent$i);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcSnackbarComponent = /** @class */ (function () {
        function MdcSnackbarComponent(elementRef, _registry) {
            var _this = this;
            this.elementRef = elementRef;
            this._registry = _registry;
            this.isHostClass = true;
            this.ariaLive = 'assertive';
            this.ariaAtomic = 'true';
            this.ariaHidden = 'true';
            /**
             * Event emitted when the snackbar is shown.
             */
            this.shown = new core.EventEmitter();
            /**
             * Event emitted when the snackbar is dismissed.
             */
            this.dismissed = new core.EventEmitter();
            this._mdcAdapter = {
                addClass: function (className) { return _this._getHostElement().classList.add(className); },
                removeClass: function (className) { return _this._getHostElement().classList.remove(className); },
                setAriaHidden: function () { return _this._getHostElement().setAttribute('aria-hidden', 'true'); },
                unsetAriaHidden: function () { return _this._getHostElement().removeAttribute('aria-hidden'); },
                setActionAriaHidden: function () {
                    if (_this.actionButton) {
                        _this._getActionButton().setAttribute('aria-hidden', 'true');
                    }
                },
                unsetActionAriaHidden: function () {
                    if (_this.actionButton) {
                        _this._getActionButton().removeAttribute('aria-hidden');
                    }
                },
                setMessageText: function (message) { return _this._getSnackText().textContent = message; },
                setActionText: function (actionText) {
                    if (_this.actionButton) {
                        _this._getActionButton().textContent = actionText;
                    }
                },
                setFocus: function () { return _this._getActionButton().focus(); },
                visibilityIsHidden: function () { return isBrowser() ? document.hidden : false; },
                registerCapturedBlurHandler: function (handler) {
                    if (_this.actionButton) {
                        _this._registry.listen('blur', handler, _this._getActionButton(), true);
                    }
                },
                deregisterCapturedBlurHandler: function (handler) { return _this._registry.unlisten('blur', handler); },
                registerVisibilityChangeHandler: function (handler) {
                    if (isBrowser()) {
                        _this._registry.listen('visibilitychange', handler, document);
                    }
                },
                deregisterVisibilityChangeHandler: function (handler) { return _this._registry.unlisten('visibilitychange', handler); },
                registerCapturedInteractionHandler: function (evtType, handler) {
                    if (isBrowser()) {
                        _this._registry.listen(evtType, handler, document.body, true);
                    }
                },
                deregisterCapturedInteractionHandler: function (evtType, handler) {
                    return _this._registry.unlisten(evtType, handler);
                },
                registerActionClickHandler: function (handler) {
                    if (_this.actionButton) {
                        _this._registry.listen('click', handler, _this._getActionButton());
                    }
                },
                deregisterActionClickHandler: function (handler) { return _this._registry.unlisten('click', handler); },
                registerTransitionEndHandler: function (handler) {
                    if (isBrowser()) {
                        _this._registry.listen(getCorrectEventName$2(window, 'transitionend'), handler, _this._getHostElement());
                    }
                },
                deregisterTransitionEndHandler: function (handler) {
                    if (isBrowser()) {
                        _this._registry.unlisten(getCorrectEventName$2(window, 'transitionend'), handler);
                    }
                },
                notifyShow: function () { return _this.shown.emit(); },
                notifyHide: function () { return _this.dismissed.emit(); }
            };
            this._foundation = new MDCSnackbarFoundation(this._mdcAdapter);
        }
        /**
         * @return {?}
         */
        MdcSnackbarComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this._getHostElement().style.setProperty('display', 'none');
        };
        /**
         * @return {?}
         */
        MdcSnackbarComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            setTimeout(function () {
                _this._foundation.init();
                _this.setDismissOnAction(_this.config.dismissOnAction ? true : false);
                if (_this.config.align === 'start') {
                    _this._mdcAdapter.addClass('mdc-snackbar--align-start');
                }
                if (!_this.config.actionHandler && _this.data.actionText) {
                    _this.config.actionHandler = function () { };
                }
                if (!_this.data.actionText) {
                    _this.config.actionHandler = undefined;
                }
                _this._getHostElement().style.setProperty('display', 'flex');
            }, 20);
            setTimeout(function () {
                _this._foundation.show(_assign({}, _this.data, _this.config));
                if (_this.config.focusAction) {
                    _this._mdcAdapter.setFocus();
                }
            }, 40);
        };
        /**
         * @return {?}
         */
        MdcSnackbarComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this._foundation) {
                this._foundation.destroy();
            }
        };
        /**
         * @param {?} dismissOnAction
         * @return {?}
         */
        MdcSnackbarComponent.prototype.setDismissOnAction = /**
         * @param {?} dismissOnAction
         * @return {?}
         */
        function (dismissOnAction) {
            this._foundation.setDismissOnAction(dismissOnAction);
        };
        /**
         * @return {?}
         */
        MdcSnackbarComponent.prototype._getSnackText = /**
         * @return {?}
         */
        function () {
            return this.snackText.nativeElement;
        };
        /**
         * @return {?}
         */
        MdcSnackbarComponent.prototype._getActionButton = /**
         * @return {?}
         */
        function () {
            return this.actionButton.nativeElement;
        };
        /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        MdcSnackbarComponent.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcSnackbarComponent.decorators = [
            { type: core.Component, args: [{selector: 'mdc-snackbar',
                        template: "\n  <div #text class=\"mdc-snackbar__text\"></div>\n  <div class=\"mdc-snackbar__action-wrapper\">\n    <button #action type=\"submit\" class=\"mdc-snackbar__action-button\"></button>\n  </div>\n  ",
                        encapsulation: core.ViewEncapsulation.None,
                        providers: [EventRegistry]
                    },] },
        ];
        /** @nocollapse */
        MdcSnackbarComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: EventRegistry }
        ]; };
        MdcSnackbarComponent.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-snackbar',] }],
            ariaLive: [{ type: core.HostBinding, args: ['attr.aria-live',] }],
            ariaAtomic: [{ type: core.HostBinding, args: ['attr.aria-atomic',] }],
            ariaHidden: [{ type: core.HostBinding, args: ['attr.aria-hidden',] }],
            snackText: [{ type: core.ViewChild, args: ['text',] }],
            actionButton: [{ type: core.ViewChild, args: ['action',] }],
            shown: [{ type: core.Output }],
            dismissed: [{ type: core.Output }]
        };
        return MdcSnackbarComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcSnackbarConfig = /** @class */ (function () {
        function MdcSnackbarConfig() {
            this.timeout = 2750;
            this.multiline = false;
            this.actionOnBottom = false;
            this.align = 'center';
            this.dismissOnAction = true;
            this.focusAction = false;
        }
        return MdcSnackbarConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcSnackbar = /** @class */ (function () {
        function MdcSnackbar(_portalService) {
            this._portalService = _portalService;
            /**
             * Emits whenever the component is destroyed.
             */
            this._destroy = new rxjs.Subject();
            this._openedSnackbarRef = null;
        }
        /**
         * @return {?}
         */
        MdcSnackbar.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroy.next();
            this._destroy.complete();
            this.dismiss();
        };
        /**
           * Shows a snackbar with a message and an optional action.
           * @param message The message to show in the snackbar.
           * @param actionText The label for the snackbar action.
           * @param config Additional configuration options for the snackbar.
           */
        /**
         * Shows a snackbar with a message and an optional action.
         * @param {?} message The message to show in the snackbar.
         * @param {?=} actionText The label for the snackbar action.
         * @param {?=} config Additional configuration options for the snackbar.
         * @return {?}
         */
        MdcSnackbar.prototype.show = /**
         * Shows a snackbar with a message and an optional action.
         * @param {?} message The message to show in the snackbar.
         * @param {?=} actionText The label for the snackbar action.
         * @param {?=} config Additional configuration options for the snackbar.
         * @return {?}
         */
        function (message, actionText, config) {
            var _this = this;
            if (actionText === void 0) { actionText = ''; }
            if (this.isShowing()) {
                this.dismiss();
            }
            this._openedSnackbarRef
                = new MdcSnackbarRef(this._portalService.createComponentRef(MdcSnackbarComponent).instance);
            this._openedSnackbarRef.componentInstance.data = { message: message, actionText: actionText };
            this._openedSnackbarRef.componentInstance.config = _applyConfigDefaults(config);
            this._snackbarSubscription = this._openedSnackbarRef.componentInstance.dismissed
                .pipe(operators.takeUntil(this._destroy))
                .subscribe(function () {
                _this.dismiss();
            });
            return this._openedSnackbarRef;
        };
        /**
         * @return {?}
         */
        MdcSnackbar.prototype.isShowing = /**
         * @return {?}
         */
        function () {
            return !!this._openedSnackbarRef;
        };
        /**
         * Dismisses the currently-visible snack bar.
         */
        /**
         * Dismisses the currently-visible snack bar.
         * @return {?}
         */
        MdcSnackbar.prototype.dismiss = /**
         * Dismisses the currently-visible snack bar.
         * @return {?}
         */
        function () {
            if (this._openedSnackbarRef) {
                this._openedSnackbarRef.dismiss();
                this._portalService.dispose();
                this._openedSnackbarRef = null;
            }
        };
        MdcSnackbar.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        MdcSnackbar.ctorParameters = function () { return [
            { type: MdcPortalService }
        ]; };
        return MdcSnackbar;
    }());
    /**
     * Applies default options to the snackbar config.
     * @param {?=} config The configuration to which the defaults will be applied.
     * @return {?} The new configuration object with defaults applied.
     */
    function _applyConfigDefaults(config) {
        return _assign({}, new MdcSnackbarConfig(), config);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcSnackbarModule = /** @class */ (function () {
        function MdcSnackbarModule() {
        }
        MdcSnackbarModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [MdcSnackbarComponent],
                        declarations: [MdcSnackbarComponent],
                        providers: [MdcSnackbar, MdcPortalService],
                        entryComponents: [MdcSnackbarComponent]
                    },] },
        ];
        return MdcSnackbarModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ MDC_SWITCH_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return MdcSwitch; }),
        multi: true
    };
    /**
     * Change event object emitted by MdcSwitch.
     */
    var   /**
     * Change event object emitted by MdcSwitch.
     */
    MdcSwitchChange = /** @class */ (function () {
        function MdcSwitchChange(source, checked) {
            this.source = source;
            this.checked = checked;
        }
        return MdcSwitchChange;
    }());
    var /** @type {?} */ nextUniqueId$6 = 0;
    var MdcSwitch = /** @class */ (function () {
        function MdcSwitch(_changeDetectorRef, _renderer, elementRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this._renderer = _renderer;
            this.elementRef = elementRef;
            this._uniqueId = "mdc-switch-" + ++nextUniqueId$6;
            this.componentInstance = MdcSwitch;
            this.id = this._uniqueId;
            this.name = null;
            this._checked = false;
            this._disabled = false;
            this.tabIndex = 0;
            this.change = new core.EventEmitter();
            this.isHostClass = true;
            /**
             * View -> model callback called when value changes
             */
            this._onChange = function () { };
            /**
             * View -> model callback called when control has been touched
             */
            this._onTouched = function () { };
        }
        Object.defineProperty(MdcSwitch.prototype, "checked", {
            get: /**
             * @return {?}
             */
            function () { return this._checked; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setChecked(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSwitch.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setDisabledState(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSwitch.prototype, "inputId", {
            get: /**
             * @return {?}
             */
            function () { return (this.id || this._uniqueId) + "-input"; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcSwitch.prototype, "classDisabled", {
            get: /**
             * @return {?}
             */
            function () {
                return this.disabled ? 'mdc-switch--disabled' : '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcSwitch.prototype.onChange = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            evt.stopPropagation();
            this.setChecked(this.inputEl.nativeElement.checked);
        };
        /**
         * @param {?} evt
         * @return {?}
         */
        MdcSwitch.prototype.onInputClick = /**
         * @param {?} evt
         * @return {?}
         */
        function (evt) {
            evt.stopPropagation();
        };
        /**
         * @return {?}
         */
        MdcSwitch.prototype.onBlur = /**
         * @return {?}
         */
        function () {
            this._onTouched();
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MdcSwitch.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.setChecked(value);
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcSwitch.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcSwitch.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onTouched = fn;
        };
        /**
         * @param {?} disabled
         * @return {?}
         */
        MdcSwitch.prototype.setDisabled = /**
         * @param {?} disabled
         * @return {?}
         */
        function (disabled) {
            this.setDisabledState(disabled);
        };
        /**
         * @param {?} checked
         * @return {?}
         */
        MdcSwitch.prototype.setChecked = /**
         * @param {?} checked
         * @return {?}
         */
        function (checked) {
            if (this.disabled) {
                return;
            }
            var /** @type {?} */ previousValue = this.checked;
            this._checked = checked;
            if (previousValue !== null || undefined) {
                this._onChange(this.checked);
                this.change.emit(new MdcSwitchChange(this, this.checked));
            }
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @return {?}
         */
        MdcSwitch.prototype.isChecked = /**
         * @return {?}
         */
        function () {
            return this.checked;
        };
        /**
         * @return {?}
         */
        MdcSwitch.prototype.isDisabled = /**
         * @return {?}
         */
        function () {
            return this.disabled;
        };
        /**
         * @param {?} disabled
         * @return {?}
         */
        MdcSwitch.prototype.setDisabledState = /**
         * @param {?} disabled
         * @return {?}
         */
        function (disabled) {
            this._disabled = disabled;
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @return {?}
         */
        MdcSwitch.prototype.focus = /**
         * @return {?}
         */
        function () {
            this.inputEl.nativeElement.focus();
        };
        MdcSwitch.decorators = [
            { type: core.Component, args: [{selector: 'mdc-switch',
                        host: {
                            '[id]': 'id',
                        },
                        template: "\n  <input type=\"checkbox\"\n    #inputEl\n    role=\"switch\"\n    class=\"mdc-switch__native-control\"\n    [id]=\"inputId\"\n    [name]=\"name\"\n    [tabIndex]=\"tabIndex\"\n    [disabled]=\"disabled\"\n    [checked]=\"checked\"\n    (click)=\"onInputClick($event)\"\n    (blur)=\"onBlur()\"\n    (change)=\"onChange($event)\"/>\n  <div class=\"mdc-switch__background\">\n    <div class=\"mdc-switch__knob\"></div>\n  </div>\n  ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None,
                        providers: [
                            MDC_SWITCH_CONTROL_VALUE_ACCESSOR,
                            [{ provide: MdcFormFieldControl, useExisting: MdcSwitch }],
                        ]
                    },] },
        ];
        /** @nocollapse */
        MdcSwitch.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.Renderer2 },
            { type: core.ElementRef }
        ]; };
        MdcSwitch.propDecorators = {
            id: [{ type: core.Input }],
            name: [{ type: core.Input }],
            checked: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            tabIndex: [{ type: core.Input }],
            change: [{ type: core.Output }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-switch',] }],
            inputEl: [{ type: core.ViewChild, args: ['inputEl',] }],
            classDisabled: [{ type: core.HostBinding, args: ['class.mdc-switch--disabled',] }]
        };
        return MdcSwitch;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcSwitchModule = /** @class */ (function () {
        function MdcSwitchModule() {
        }
        MdcSwitchModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [MdcSwitch],
                        declarations: [MdcSwitch],
                    },] },
        ];
        return MdcSwitchModule;
    }());

    function _classCallCheck$l(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$l(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$l(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$l(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$l(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$l(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$l(subClass, superClass);
    }

    function _getPrototypeOf$l(o) {
      _getPrototypeOf$l = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$l(o);
    }

    function _setPrototypeOf$l(o, p) {
      _setPrototypeOf$l = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$l(o, p);
    }

    function _assertThisInitialized$l(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$l(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$l(self);
    }

    function _superPropBase$a(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$l(object);
        if (object === null) break;
      }

      return object;
    }

    function _get$a(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$a = Reflect.get;
      } else {
        _get$a = function _get(target, property, receiver) {
          var base = _superPropBase$a(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get$a(target, property, receiver || target);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @template A
     */
    var MDCFoundation$k =
    /*#__PURE__*/
    function () {
      _createClass$l(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$l(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$l(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$j =
    /*#__PURE__*/
    function () {
      _createClass$l(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$k());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$l(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$l(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Ripple. Provides an interface for managing
     * - classes
     * - dom
     * - CSS variables
     * - position
     * - dimensions
     * - scroll position
     * - event handlers
     * - unbounded, active and disabled states
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCRippleAdapter$a =
    /*#__PURE__*/
    function () {
      function MDCRippleAdapter() {
        _classCallCheck$l(this, MDCRippleAdapter);
      }

      _createClass$l(MDCRippleAdapter, [{
        key: "browserSupportsCssVars",

        /** @return {boolean} */
        value: function browserSupportsCssVars() {}
        /** @return {boolean} */

      }, {
        key: "isUnbounded",
        value: function isUnbounded() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceActive",
        value: function isSurfaceActive() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceDisabled",
        value: function isSurfaceDisabled() {}
        /** @param {string} className */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @param {!EventTarget} target */

      }, {
        key: "containsEventTarget",
        value: function containsEventTarget(target) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerDocumentInteractionHandler",
        value: function registerDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterDocumentInteractionHandler",
        value: function deregisterDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /**
         * @param {string} varName
         * @param {?number|string} value
         */

      }, {
        key: "updateCssVariable",
        value: function updateCssVariable(varName, value) {}
        /** @return {!ClientRect} */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}
        /** @return {{x: number, y: number}} */

      }, {
        key: "getWindowPageOffset",
        value: function getWindowPageOffset() {}
      }]);

      return MDCRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var cssClasses$j = {
      // Ripple is a special case where the "root" component is really a "mixin" of sorts,
      // given that it's an 'upgrade' to an existing component. That being said it is the root
      // CSS class that all other CSS classes derive from.
      ROOT: 'mdc-ripple-upgraded',
      UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
      BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
      FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
      FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
    };
    var strings$i = {
      VAR_LEFT: '--mdc-ripple-left',
      VAR_TOP: '--mdc-ripple-top',
      VAR_FG_SIZE: '--mdc-ripple-fg-size',
      VAR_FG_SCALE: '--mdc-ripple-fg-scale',
      VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
      VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
    };
    var numbers$d = {
      PADDING: 10,
      INITIAL_ORIGIN_SCALE: 0.6,
      DEACTIVATION_TIMEOUT_MS: 225,
      // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
      FG_DEACTIVATION_MS: 150,
      // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
      TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

    };

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
     * @private {boolean|undefined}
     */
    var supportsCssVariables_$a;
    /**
     * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
     * @private {boolean|undefined}
     */

    var supportsPassive_$b;
    /**
     * @param {!Window} windowObj
     * @return {boolean}
     */

    function detectEdgePseudoVarBug$a(windowObj) {
      // Detect versions of Edge with buggy var() support
      // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
      var document = windowObj.document;
      var node = document.createElement('div');
      node.className = 'mdc-ripple-surface--test-edge-var-bug';
      document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
      // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
      // but Firefox is known to support CSS custom properties correctly.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

      var computedStyle = windowObj.getComputedStyle(node);
      var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
      node.remove();
      return hasPseudoVarBug;
    }
    /**
     * @param {!Window} windowObj
     * @param {boolean=} forceRefresh
     * @return {boolean|undefined}
     */


    function supportsCssVariables$a(windowObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var supportsCssVariables = supportsCssVariables_$a;

      if (typeof supportsCssVariables_$a === 'boolean' && !forceRefresh) {
        return supportsCssVariables;
      }

      var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

      if (!supportsFunctionPresent) {
        return;
      }

      var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
      // See: README section on Safari

      var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

      if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVariables = !detectEdgePseudoVarBug$a(windowObj);
      } else {
        supportsCssVariables = false;
      }

      if (!forceRefresh) {
        supportsCssVariables_$a = supportsCssVariables;
      }

      return supportsCssVariables;
    } //

    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|{passive: boolean}}
     */


    function applyPassive$b() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_$b === undefined || forceRefresh) {
        var isSupported = false;

        try {
          globalObj.document.addEventListener('test', null, {
            get passive() {
              isSupported = true;
            }

          });
        } catch (e) {}

        supportsPassive_$b = isSupported;
      }

      return supportsPassive_$b ? {
        passive: true
      } : false;
    }
    /**
     * @param {!Object} HTMLElementPrototype
     * @return {!Array<string>}
     */


    function getMatchesProperty$a(HTMLElementPrototype) {
      return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(function (p) {
        return p in HTMLElementPrototype;
      }).pop();
    }
    /**
     * @param {!Event} ev
     * @param {{x: number, y: number}} pageOffset
     * @param {!ClientRect} clientRect
     * @return {{x: number, y: number}}
     */


    function getNormalizedEventCoords$a(ev, pageOffset, clientRect) {
      var x = pageOffset.x,
          y = pageOffset.y;
      var documentX = x + clientRect.left;
      var documentY = y + clientRect.top;
      var normalizedX;
      var normalizedY; // Determine touch point relative to the ripple container.

      if (ev.type === 'touchstart') {
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
      } else {
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
      }

      return {
        x: normalizedX,
        y: normalizedY
      };
    }

    var ACTIVATION_EVENT_TYPES$a = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

    var POINTER_DEACTIVATION_EVENT_TYPES$a = ['touchend', 'pointerup', 'mouseup']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

    /** @type {!Array<!EventTarget>} */

    var activatedTargets$a = [];
    /**
     * @extends {MDCFoundation<!MDCRippleAdapter>}
     */

    var MDCRippleFoundation$a =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$l(MDCRippleFoundation, _MDCFoundation);

      _createClass$l(MDCRippleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$j;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$i;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers$d;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            browserSupportsCssVars: function browserSupportsCssVars()
            /* boolean - cached */
            {},
            isUnbounded: function isUnbounded()
            /* boolean */
            {},
            isSurfaceActive: function isSurfaceActive()
            /* boolean */
            {},
            isSurfaceDisabled: function isSurfaceDisabled()
            /* boolean */
            {},
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            containsEventTarget: function containsEventTarget()
            /* target: !EventTarget */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            updateCssVariable: function updateCssVariable()
            /* varName: string, value: string */
            {},
            computeBoundingRect: function computeBoundingRect()
            /* ClientRect */
            {},
            getWindowPageOffset: function getWindowPageOffset()
            /* {x: number, y: number} */
            {}
          };
        }
      }]);

      function MDCRippleFoundation(adapter) {
        var _this;

        _classCallCheck$l(this, MDCRippleFoundation);

        _this = _possibleConstructorReturn$l(this, _getPrototypeOf$l(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
        /** @private {number} */

        _this.layoutFrame_ = 0;
        /** @private {!ClientRect} */

        _this.frame_ =
        /** @type {!ClientRect} */
        {
          width: 0,
          height: 0
        };
        /** @private {!ActivationStateType} */

        _this.activationState_ = _this.defaultActivationState_();
        /** @private {number} */

        _this.initialSize_ = 0;
        /** @private {number} */

        _this.maxRadius_ = 0;
        /** @private {function(!Event)} */

        _this.activateHandler_ = function (e) {
          return _this.activate_(e);
        };
        /** @private {function(!Event)} */


        _this.deactivateHandler_ = function (e) {
          return _this.deactivate_(e);
        };
        /** @private {function(?Event=)} */


        _this.focusHandler_ = function () {
          return _this.handleFocus();
        };
        /** @private {function(?Event=)} */


        _this.blurHandler_ = function () {
          return _this.handleBlur();
        };
        /** @private {!Function} */


        _this.resizeHandler_ = function () {
          return _this.layout();
        };
        /** @private {{left: number, top:number}} */


        _this.unboundedCoords_ = {
          left: 0,
          top: 0
        };
        /** @private {number} */

        _this.fgScale_ = 0;
        /** @private {number} */

        _this.activationTimer_ = 0;
        /** @private {number} */

        _this.fgDeactivationRemovalTimer_ = 0;
        /** @private {boolean} */

        _this.activationAnimationHasEnded_ = false;
        /** @private {!Function} */

        _this.activationTimerCallback_ = function () {
          _this.activationAnimationHasEnded_ = true;

          _this.runDeactivationUXLogicIfReady_();
        };
        /** @private {?Event} */


        _this.previousActivationEvent_ = null;
        return _this;
      }
      /**
       * We compute this property so that we are not querying information about the client
       * until the point in time where the foundation requests it. This prevents scenarios where
       * client-side feature-detection may happen too early, such as when components are rendered on the server
       * and then initialized at mount time on the client.
       * @return {boolean}
       * @private
       */


      _createClass$l(MDCRippleFoundation, [{
        key: "isSupported_",
        value: function isSupported_() {
          return this.adapter_.browserSupportsCssVars();
        }
        /**
         * @return {!ActivationStateType}
         */

      }, {
        key: "defaultActivationState_",
        value: function defaultActivationState_() {
          return {
            isActivated: false,
            hasDeactivationUXRun: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
            activationEvent: null,
            isProgrammatic: false
          };
        }
        /** @override */

      }, {
        key: "init",
        value: function init() {
          var _this2 = this;

          if (!this.isSupported_()) {
            return;
          }

          this.registerRootHandlers_();
          var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$.ROOT,
              UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
          requestAnimationFrame(function () {
            _this2.adapter_.addClass(ROOT);

            if (_this2.adapter_.isUnbounded()) {
              _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


              _this2.layoutInternal_();
            }
          });
        }
        /** @override */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          if (!this.isSupported_()) {
            return;
          }

          if (this.activationTimer_) {
            clearTimeout(this.activationTimer_);
            this.activationTimer_ = 0;
            var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
            this.adapter_.removeClass(FG_ACTIVATION);
          }

          this.deregisterRootHandlers_();
          this.deregisterDeactivationHandlers_();
          var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$2.ROOT,
              UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
          requestAnimationFrame(function () {
            _this3.adapter_.removeClass(ROOT);

            _this3.adapter_.removeClass(UNBOUNDED);

            _this3.removeCssVars_();
          });
        }
        /** @private */

      }, {
        key: "registerRootHandlers_",
        value: function registerRootHandlers_() {
          var _this4 = this;

          ACTIVATION_EVENT_TYPES$a.forEach(function (type) {
            _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
          });
          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.registerResizeHandler(this.resizeHandler_);
          }
        }
        /**
         * @param {!Event} e
         * @private
         */

      }, {
        key: "registerDeactivationHandlers_",
        value: function registerDeactivationHandlers_(e) {
          var _this5 = this;

          if (e.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
          } else {
            POINTER_DEACTIVATION_EVENT_TYPES$a.forEach(function (type) {
              _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
            });
          }
        }
        /** @private */

      }, {
        key: "deregisterRootHandlers_",
        value: function deregisterRootHandlers_() {
          var _this6 = this;

          ACTIVATION_EVENT_TYPES$a.forEach(function (type) {
            _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
          });
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          }
        }
        /** @private */

      }, {
        key: "deregisterDeactivationHandlers_",
        value: function deregisterDeactivationHandlers_() {
          var _this7 = this;

          this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
          POINTER_DEACTIVATION_EVENT_TYPES$a.forEach(function (type) {
            _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
          });
        }
        /** @private */

      }, {
        key: "removeCssVars_",
        value: function removeCssVars_() {
          var _this8 = this;

          var strings$$1 = MDCRippleFoundation.strings;
          Object.keys(strings$$1).forEach(function (k) {
            if (k.indexOf('VAR_') === 0) {
              _this8.adapter_.updateCssVariable(strings$$1[k], null);
            }
          });
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "activate_",
        value: function activate_(e) {
          var _this9 = this;

          if (this.adapter_.isSurfaceDisabled()) {
            return;
          }

          var activationState = this.activationState_;

          if (activationState.isActivated) {
            return;
          } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


          var previousActivationEvent = this.previousActivationEvent_;
          var isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;

          if (isSameInteraction) {
            return;
          }

          activationState.isActivated = true;
          activationState.isProgrammatic = e === null;
          activationState.activationEvent = e;
          activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';
          var hasActivatedChild = e && activatedTargets$a.length > 0 && activatedTargets$a.some(function (target) {
            return _this9.adapter_.containsEventTarget(target);
          });

          if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
          }

          if (e) {
            activatedTargets$a.push(
            /** @type {!EventTarget} */
            e.target);
            this.registerDeactivationHandlers_(e);
          }

          activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

          if (activationState.wasElementMadeActive) {
            this.animateActivation_();
          }

          requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets$a = [];

            if (!activationState.wasElementMadeActive && (e.key === ' ' || e.keyCode === 32)) {
              // If space was pressed, try again within an rAF call to detect :active, because different UAs report
              // active states inconsistently when they're called within event handling code:
              // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
              // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
              // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
              // variable is set within a rAF callback for a submit button interaction (#2241).
              activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

              if (activationState.wasElementMadeActive) {
                _this9.animateActivation_();
              }
            }

            if (!activationState.wasElementMadeActive) {
              // Reset activation state immediately if element was not made active.
              _this9.activationState_ = _this9.defaultActivationState_();
            }
          });
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "checkElementMadeActive_",
        value: function checkElementMadeActive_(e) {
          return e && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
        }
        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: "activate",
        value: function activate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          this.activate_(event);
        }
        /** @private */

      }, {
        key: "animateActivation_",
        value: function animateActivation_() {
          var _this10 = this;

          var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
              VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
              VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
          var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
              FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
              FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
          var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
          this.layoutInternal_();
          var translateStart = '';
          var translateEnd = '';

          if (!this.adapter_.isUnbounded()) {
            var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
                startPoint = _this$getFgTranslatio.startPoint,
                endPoint = _this$getFgTranslatio.endPoint;

            translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
            translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
          }

          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

          clearTimeout(this.activationTimer_);
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.rmBoundedActivationClasses_();
          this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

          this.adapter_.computeBoundingRect();
          this.adapter_.addClass(FG_ACTIVATION);
          this.activationTimer_ = setTimeout(function () {
            return _this10.activationTimerCallback_();
          }, DEACTIVATION_TIMEOUT_MS);
        }
        /**
         * @private
         * @return {{startPoint: PointType, endPoint: PointType}}
         */

      }, {
        key: "getFgTranslationCoordinates_",
        value: function getFgTranslationCoordinates_() {
          var _this$activationState = this.activationState_,
              activationEvent = _this$activationState.activationEvent,
              wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
          var startPoint;

          if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords$a(
            /** @type {!Event} */
            activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
          } else {
            startPoint = {
              x: this.frame_.width / 2,
              y: this.frame_.height / 2
            };
          } // Center the element around the start point.


          startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
          };
          var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
          };
          return {
            startPoint: startPoint,
            endPoint: endPoint
          };
        }
        /** @private */

      }, {
        key: "runDeactivationUXLogicIfReady_",
        value: function runDeactivationUXLogicIfReady_() {
          var _this11 = this;

          // This method is called both when a pointing device is released, and when the activation animation ends.
          // The deactivation animation should only run after both of those occur.
          var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
          var _this$activationState2 = this.activationState_,
              hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
              isActivated = _this$activationState2.isActivated;
          var activationHasEnded = hasDeactivationUXRun || !isActivated;

          if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
              _this11.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers$d.FG_DEACTIVATION_MS);
          }
        }
        /** @private */

      }, {
        key: "rmBoundedActivationClasses_",
        value: function rmBoundedActivationClasses_() {
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
          this.adapter_.removeClass(FG_ACTIVATION);
          this.activationAnimationHasEnded_ = false;
          this.adapter_.computeBoundingRect();
        }
      }, {
        key: "resetActivationState_",
        value: function resetActivationState_() {
          var _this12 = this;

          this.previousActivationEvent_ = this.activationState_.activationEvent;
          this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
          // Store the previous event until it's safe to assume that subsequent events are for new interactions.

          setTimeout(function () {
            return _this12.previousActivationEvent_ = null;
          }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "deactivate_",
        value: function deactivate_(e) {
          var _this13 = this;

          var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

          if (!activationState.isActivated) {
            return;
          }

          var state =
          /** @type {!ActivationStateType} */
          Object.assign({}, activationState);

          if (activationState.isProgrammatic) {
            var evtObject = null;
            requestAnimationFrame(function () {
              return _this13.animateDeactivation_(evtObject, state);
            });
            this.resetActivationState_();
          } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
              _this13.activationState_.hasDeactivationUXRun = true;

              _this13.animateDeactivation_(e, state);

              _this13.resetActivationState_();
            });
          }
        }
        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          this.deactivate_(event);
        }
        /**
         * @param {Event} e
         * @param {!ActivationStateType} options
         * @private
         */

      }, {
        key: "animateDeactivation_",
        value: function animateDeactivation_(e, _ref) {
          var wasActivatedByPointer = _ref.wasActivatedByPointer,
              wasElementMadeActive = _ref.wasElementMadeActive;

          if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this14 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }

          this.layoutFrame_ = requestAnimationFrame(function () {
            _this14.layoutInternal_();

            _this14.layoutFrame_ = 0;
          });
        }
        /** @private */

      }, {
        key: "layoutInternal_",
        value: function layoutInternal_() {
          var _this15 = this;

          this.frame_ = this.adapter_.computeBoundingRect();
          var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
          // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
          // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
          // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
          // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
          // `overflow: hidden`.

          var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
          };

          this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

          this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;
          this.fgScale_ = this.maxRadius_ / this.initialSize_;
          this.updateLayoutCssVars_();
        }
        /** @private */

      }, {
        key: "updateLayoutCssVars_",
        value: function updateLayoutCssVars_() {
          var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
              VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
              VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
              VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
              VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
          this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
          this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

          if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
              left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
              top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };
            this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
            this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
          }
        }
        /** @param {boolean} unbounded */

      }, {
        key: "setUnbounded",
        value: function setUnbounded(unbounded) {
          var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

          if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
          } else {
            this.adapter_.removeClass(UNBOUNDED);
          }
        }
      }, {
        key: "handleFocus",
        value: function handleFocus() {
          var _this16 = this;

          requestAnimationFrame(function () {
            return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }, {
        key: "handleBlur",
        value: function handleBlur() {
          var _this17 = this;

          requestAnimationFrame(function () {
            return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }]);

      return MDCRippleFoundation;
    }(MDCFoundation$k);

    /**
     * @extends MDCComponent<!MDCRippleFoundation>
     */

    var MDCRipple$a =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$l(MDCRipple, _MDCComponent);

      /** @param {...?} args */
      function MDCRipple() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$l(this, MDCRipple);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$l(this, (_getPrototypeOf2 = _getPrototypeOf$l(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {boolean} */

        _this.disabled = false;
        /** @private {boolean} */

        _this.unbounded_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @param {{isUnbounded: (boolean|undefined)}=} options
       * @return {!MDCRipple}
       */


      _createClass$l(MDCRipple, [{
        key: "setUnbounded_",

        /**
         * Closure Compiler throws an access control error when directly accessing a
         * protected or private property inside a getter/setter, like unbounded above.
         * By accessing the protected property inside a method, we solve that problem.
         * That's why this function exists.
         * @private
         */
        value: function setUnbounded_() {
          this.foundation_.setUnbounded(this.unbounded_);
        }
      }, {
        key: "activate",
        value: function activate() {
          this.foundation_.activate();
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
        /**
         * @return {!MDCRippleFoundation}
         * @override
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          return new MDCRippleFoundation$a(MDCRipple.createAdapter(this));
        }
        /** @override */

      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
        }
      }, {
        key: "unbounded",

        /** @return {boolean} */
        get: function get() {
          return this.unbounded_;
        }
        /** @param {boolean} unbounded */
        ,
        set: function set(unbounded) {
          this.unbounded_ = Boolean(unbounded);
          this.setUnbounded_();
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref$isUnbounded = _ref.isUnbounded,
              isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

          var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

          if (isUnbounded !== undefined) {
            ripple.unbounded =
            /** @type {boolean} */
            isUnbounded;
          }

          return ripple;
        }
        /**
         * @param {!RippleCapableSurface} instance
         * @return {!MDCRippleAdapter}
         */

      }, {
        key: "createAdapter",
        value: function createAdapter(instance) {
          var MATCHES = getMatchesProperty$a(HTMLElement.prototype);
          return {
            browserSupportsCssVars: function browserSupportsCssVars() {
              return supportsCssVariables$a(window);
            },
            isUnbounded: function isUnbounded() {
              return instance.unbounded;
            },
            isSurfaceActive: function isSurfaceActive() {
              return instance.root_[MATCHES](':active');
            },
            isSurfaceDisabled: function isSurfaceDisabled() {
              return instance.disabled;
            },
            addClass: function addClass(className) {
              return instance.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return instance.root_.classList.remove(className);
            },
            containsEventTarget: function containsEventTarget(target) {
              return instance.root_.contains(target);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return instance.root_.addEventListener(evtType, handler, applyPassive$b());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return instance.root_.removeEventListener(evtType, handler, applyPassive$b());
            },
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.addEventListener(evtType, handler, applyPassive$b());
            },
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.removeEventListener(evtType, handler, applyPassive$b());
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return instance.root_.style.setProperty(varName, value);
            },
            computeBoundingRect: function computeBoundingRect() {
              return instance.root_.getBoundingClientRect();
            },
            getWindowPageOffset: function getWindowPageOffset() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            }
          };
        }
      }]);

      return MDCRipple;
    }(MDCComponent$j);

    /**
     * Copyright 2017 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var cssClasses$1$b = {
      ACTIVE: 'mdc-tab--active'
    };
    var strings$1$b = {
      SELECTED_EVENT: 'MDCTab:selected'
    };

    var MDCTabFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$l(MDCTabFoundation, _MDCFoundation);

      _createClass$l(MDCTabFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$1$b;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$1$b;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* type: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* type: string, handler: EventListener */
            {},
            getOffsetWidth: function getOffsetWidth() {
              return (
                /* number */
                0
              );
            },
            getOffsetLeft: function getOffsetLeft() {
              return (
                /* number */
                0
              );
            },
            notifySelected: function notifySelected() {}
          };
        }
      }]);

      function MDCTabFoundation() {
        var _this;

        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$l(this, MDCTabFoundation);

        _this = _possibleConstructorReturn$l(this, _getPrototypeOf$l(MDCTabFoundation).call(this, Object.assign(MDCTabFoundation.defaultAdapter, adapter)));
        _this.computedWidth_ = 0;
        _this.computedLeft_ = 0;
        _this.isActive_ = false;
        _this.preventDefaultOnClick_ = false;

        _this.clickHandler_ = function (evt) {
          if (_this.preventDefaultOnClick_) {
            evt.preventDefault();
          }

          _this.adapter_.notifySelected();
        };

        _this.keydownHandler_ = function (evt) {
          if (evt.key && evt.key === 'Enter' || evt.keyCode === 13) {
            _this.adapter_.notifySelected();
          }
        };

        return _this;
      }

      _createClass$l(MDCTabFoundation, [{
        key: "init",
        value: function init() {
          this.adapter_.registerInteractionHandler('click', this.clickHandler_);
          this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
          this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
        }
      }, {
        key: "getComputedWidth",
        value: function getComputedWidth() {
          return this.computedWidth_;
        }
      }, {
        key: "getComputedLeft",
        value: function getComputedLeft() {
          return this.computedLeft_;
        }
      }, {
        key: "isActive",
        value: function isActive() {
          return this.isActive_;
        }
      }, {
        key: "setActive",
        value: function setActive(isActive) {
          this.isActive_ = isActive;

          if (this.isActive_) {
            this.adapter_.addClass(cssClasses$1$b.ACTIVE);
          } else {
            this.adapter_.removeClass(cssClasses$1$b.ACTIVE);
          }
        }
      }, {
        key: "preventsDefaultOnClick",
        value: function preventsDefaultOnClick() {
          return this.preventDefaultOnClick_;
        }
      }, {
        key: "setPreventDefaultOnClick",
        value: function setPreventDefaultOnClick(preventDefaultOnClick) {
          this.preventDefaultOnClick_ = preventDefaultOnClick;
        }
      }, {
        key: "measureSelf",
        value: function measureSelf() {
          this.computedWidth_ = this.adapter_.getOffsetWidth();
          this.computedLeft_ = this.adapter_.getOffsetLeft();
        }
      }]);

      return MDCTabFoundation;
    }(MDCFoundation$k);

    var MDCTab =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$l(MDCTab, _MDCComponent);

      _createClass$l(MDCTab, [{
        key: "computedWidth",
        get: function get$$1() {
          return this.foundation_.getComputedWidth();
        }
      }, {
        key: "computedLeft",
        get: function get$$1() {
          return this.foundation_.getComputedLeft();
        }
      }, {
        key: "isActive",
        get: function get$$1() {
          return this.foundation_.isActive();
        },
        set: function set(isActive) {
          this.foundation_.setActive(isActive);
        }
      }, {
        key: "preventDefaultOnClick",
        get: function get$$1() {
          return this.foundation_.preventsDefaultOnClick();
        },
        set: function set(preventDefaultOnClick) {
          this.foundation_.setPreventDefaultOnClick(preventDefaultOnClick);
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCTab(root);
        }
      }]);

      function MDCTab() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$l(this, MDCTab);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$l(this, (_getPrototypeOf2 = _getPrototypeOf$l(MDCTab)).call.apply(_getPrototypeOf2, [this].concat(args)));
        _this.ripple_ = MDCRipple$a.attachTo(_this.root_);
        return _this;
      }

      _createClass$l(MDCTab, [{
        key: "destroy",
        value: function destroy() {
          this.ripple_.destroy();

          _get$a(_getPrototypeOf$l(MDCTab.prototype), "destroy", this).call(this);
        }
      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this2 = this;

          return new MDCTabFoundation({
            addClass: function addClass(className) {
              return _this2.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this2.root_.classList.remove(className);
            },
            registerInteractionHandler: function registerInteractionHandler(type, handler) {
              return _this2.root_.addEventListener(type, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
              return _this2.root_.removeEventListener(type, handler);
            },
            getOffsetWidth: function getOffsetWidth() {
              return _this2.root_.offsetWidth;
            },
            getOffsetLeft: function getOffsetLeft() {
              return _this2.root_.offsetLeft;
            },
            notifySelected: function notifySelected() {
              return _this2.emit(MDCTabFoundation.strings.SELECTED_EVENT, {
                tab: _this2
              }, true);
            }
          });
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.isActive = this.root_.classList.contains(cssClasses$1$b.ACTIVE);
        }
      }, {
        key: "measureSelf",
        value: function measureSelf() {
          this.foundation_.measureSelf();
        }
      }]);

      return MDCTab;
    }(MDCComponent$j);

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /** @const {Object<string, !VendorPropertyMapType>} */

    var eventTypeMap$3 = {
      'animationstart': {
        noPrefix: 'animationstart',
        webkitPrefix: 'webkitAnimationStart',
        styleProperty: 'animation'
      },
      'animationend': {
        noPrefix: 'animationend',
        webkitPrefix: 'webkitAnimationEnd',
        styleProperty: 'animation'
      },
      'animationiteration': {
        noPrefix: 'animationiteration',
        webkitPrefix: 'webkitAnimationIteration',
        styleProperty: 'animation'
      },
      'transitionend': {
        noPrefix: 'transitionend',
        webkitPrefix: 'webkitTransitionEnd',
        styleProperty: 'transition'
      }
    };
    /** @const {Object<string, !VendorPropertyMapType>} */

    var cssPropertyMap$3 = {
      'animation': {
        noPrefix: 'animation',
        webkitPrefix: '-webkit-animation'
      },
      'transform': {
        noPrefix: 'transform',
        webkitPrefix: '-webkit-transform'
      },
      'transition': {
        noPrefix: 'transition',
        webkitPrefix: '-webkit-transition'
      }
    };
    /**
     * @param {!Object} windowObj
     * @return {boolean}
     */

    function hasProperShape$3(windowObj) {
      return windowObj['document'] !== undefined && typeof windowObj['document']['createElement'] === 'function';
    }
    /**
     * @param {string} eventType
     * @return {boolean}
     */


    function eventFoundInMaps$3(eventType) {
      return eventType in eventTypeMap$3 || eventType in cssPropertyMap$3;
    }
    /**
     * @param {string} eventType
     * @param {!Object<string, !VendorPropertyMapType>} map
     * @param {!Element} el
     * @return {string}
     */


    function getJavaScriptEventName$3(eventType, map, el) {
      return map[eventType].styleProperty in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
    }
    /**
     * Helper function to determine browser prefix for CSS3 animation events
     * and property names.
     * @param {!Object} windowObj
     * @param {string} eventType
     * @return {string}
     */


    function getAnimationName$3(windowObj, eventType) {
      if (!hasProperShape$3(windowObj) || !eventFoundInMaps$3(eventType)) {
        return eventType;
      }

      var map =
      /** @type {!Object<string, !VendorPropertyMapType>} */
      eventType in eventTypeMap$3 ? eventTypeMap$3 : cssPropertyMap$3;
      var el = windowObj['document']['createElement']('div');
      var eventName = '';

      if (map === eventTypeMap$3) {
        eventName = getJavaScriptEventName$3(eventType, map, el);
      } else {
        eventName = map[eventType].noPrefix in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
      }

      return eventName;
    } // Public functions to access getAnimationName() for JavaScript events or CSS
    /**
     * @param {!Object} windowObj
     * @param {string} eventType
     * @return {string}
     */


    function getCorrectPropertyName$1(windowObj, eventType) {
      return getAnimationName$3(windowObj, eventType);
    }

    /**
     * Copyright 2017 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var cssClasses$2$3 = {
      UPGRADED: 'mdc-tab-bar-upgraded'
    };
    var strings$2$3 = {
      TAB_SELECTOR: '.mdc-tab',
      INDICATOR_SELECTOR: '.mdc-tab-bar__indicator',
      CHANGE_EVENT: 'MDCTabBar:change'
    };

    var MDCTabBarFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$l(MDCTabBarFoundation, _MDCFoundation);

      _createClass$l(MDCTabBarFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$2$3;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$2$3;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            bindOnMDCTabSelectedEvent: function bindOnMDCTabSelectedEvent() {},
            unbindOnMDCTabSelectedEvent: function unbindOnMDCTabSelectedEvent() {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            getOffsetWidth: function getOffsetWidth() {
              return (
                /* number */
                0
              );
            },
            setStyleForIndicator: function setStyleForIndicator()
            /* propertyName: string, value: string */
            {},
            getOffsetWidthForIndicator: function getOffsetWidthForIndicator() {
              return (
                /* number */
                0
              );
            },
            notifyChange: function notifyChange()
            /* evtData: {activeTabIndex: number} */
            {},
            getNumberOfTabs: function getNumberOfTabs() {
              return (
                /* number */
                0
              );
            },
            isTabActiveAtIndex: function isTabActiveAtIndex() {
              return (
                /* index: number */

                /* boolean */
                false
              );
            },
            setTabActiveAtIndex: function setTabActiveAtIndex()
            /* index: number, isActive: true */
            {},
            isDefaultPreventedOnClickForTabAtIndex: function isDefaultPreventedOnClickForTabAtIndex() {
              return (
                /* index: number */

                /* boolean */
                false
              );
            },
            setPreventDefaultOnClickForTabAtIndex: function setPreventDefaultOnClickForTabAtIndex()
            /* index: number, preventDefaultOnClick: boolean */
            {},
            measureTabAtIndex: function measureTabAtIndex()
            /* index: number */
            {},
            getComputedWidthForTabAtIndex: function getComputedWidthForTabAtIndex() {
              return (
                /* index: number */

                /* number */
                0
              );
            },
            getComputedLeftForTabAtIndex: function getComputedLeftForTabAtIndex() {
              return (
                /* index: number */

                /* number */
                0
              );
            }
          };
        }
      }]);

      function MDCTabBarFoundation(adapter) {
        var _this;

        _classCallCheck$l(this, MDCTabBarFoundation);

        _this = _possibleConstructorReturn$l(this, _getPrototypeOf$l(MDCTabBarFoundation).call(this, Object.assign(MDCTabBarFoundation.defaultAdapter, adapter)));
        _this.isIndicatorShown_ = false;
        _this.computedWidth_ = 0;
        _this.computedLeft_ = 0;
        _this.activeTabIndex_ = 0;
        _this.layoutFrame_ = 0;

        _this.resizeHandler_ = function () {
          return _this.layout();
        };

        return _this;
      }

      _createClass$l(MDCTabBarFoundation, [{
        key: "init",
        value: function init() {
          this.adapter_.addClass(cssClasses$2$3.UPGRADED);
          this.adapter_.bindOnMDCTabSelectedEvent();
          this.adapter_.registerResizeHandler(this.resizeHandler_);
          var activeTabIndex = this.findActiveTabIndex_();

          if (activeTabIndex >= 0) {
            this.activeTabIndex_ = activeTabIndex;
          }

          this.layout();
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.adapter_.removeClass(cssClasses$2$3.UPGRADED);
          this.adapter_.unbindOnMDCTabSelectedEvent();
          this.adapter_.deregisterResizeHandler(this.resizeHandler_);
        }
      }, {
        key: "layoutInternal_",
        value: function layoutInternal_() {
          var _this2 = this;

          this.forEachTabIndex_(function (index) {
            return _this2.adapter_.measureTabAtIndex(index);
          });
          this.computedWidth_ = this.adapter_.getOffsetWidth();
          this.layoutIndicator_();
        }
      }, {
        key: "layoutIndicator_",
        value: function layoutIndicator_() {
          var isIndicatorFirstRender = !this.isIndicatorShown_; // Ensure that indicator appears in the right position immediately for correct first render.

          if (isIndicatorFirstRender) {
            this.adapter_.setStyleForIndicator('transition', 'none');
          }

          var translateAmtForActiveTabLeft = this.adapter_.getComputedLeftForTabAtIndex(this.activeTabIndex_);
          var scaleAmtForActiveTabWidth = this.adapter_.getComputedWidthForTabAtIndex(this.activeTabIndex_) / this.adapter_.getOffsetWidth();
          var transformValue = "translateX(".concat(translateAmtForActiveTabLeft, "px) scale(").concat(scaleAmtForActiveTabWidth, ", 1)");
          this.adapter_.setStyleForIndicator(getCorrectPropertyName$1(window, 'transform'), transformValue);

          if (isIndicatorFirstRender) {
            // Force layout so that transform styles to take effect.
            this.adapter_.getOffsetWidthForIndicator();
            this.adapter_.setStyleForIndicator('transition', '');
            this.adapter_.setStyleForIndicator('visibility', 'visible');
            this.isIndicatorShown_ = true;
          }
        }
      }, {
        key: "findActiveTabIndex_",
        value: function findActiveTabIndex_() {
          var _this3 = this;

          var activeTabIndex = -1;
          this.forEachTabIndex_(function (index) {
            if (_this3.adapter_.isTabActiveAtIndex(index)) {
              activeTabIndex = index;
              return true;
            }
          });
          return activeTabIndex;
        }
      }, {
        key: "forEachTabIndex_",
        value: function forEachTabIndex_(iterator) {
          var numTabs = this.adapter_.getNumberOfTabs();

          for (var index = 0; index < numTabs; index++) {
            var shouldBreak = iterator(index);

            if (shouldBreak) {
              break;
            }
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this4 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }

          this.layoutFrame_ = requestAnimationFrame(function () {
            _this4.layoutInternal_();

            _this4.layoutFrame_ = 0;
          });
        }
      }, {
        key: "switchToTabAtIndex",
        value: function switchToTabAtIndex(index, shouldNotify) {
          var _this5 = this;

          if (index === this.activeTabIndex_) {
            return;
          }

          if (index < 0 || index >= this.adapter_.getNumberOfTabs()) {
            throw new Error("Out of bounds index specified for tab: ".concat(index));
          }

          var prevActiveTabIndex = this.activeTabIndex_;
          this.activeTabIndex_ = index;
          requestAnimationFrame(function () {
            if (prevActiveTabIndex >= 0) {
              _this5.adapter_.setTabActiveAtIndex(prevActiveTabIndex, false);
            }

            _this5.adapter_.setTabActiveAtIndex(_this5.activeTabIndex_, true);

            _this5.layoutIndicator_();

            if (shouldNotify) {
              _this5.adapter_.notifyChange({
                activeTabIndex: _this5.activeTabIndex_
              });
            }
          });
        }
      }, {
        key: "getActiveTabIndex",
        value: function getActiveTabIndex() {
          return this.findActiveTabIndex_();
        }
      }]);

      return MDCTabBarFoundation;
    }(MDCFoundation$k);

    var MDCTabBar =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$l(MDCTabBar, _MDCComponent);

      function MDCTabBar() {
        _classCallCheck$l(this, MDCTabBar);

        return _possibleConstructorReturn$l(this, _getPrototypeOf$l(MDCTabBar).apply(this, arguments));
      }

      _createClass$l(MDCTabBar, [{
        key: "initialize",
        value: function initialize() {
          var _this = this;

          var tabFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (el) {
            return new MDCTab(el);
          };
          this.indicator_ = this.root_.querySelector(MDCTabBarFoundation.strings.INDICATOR_SELECTOR);
          this.tabs_ = this.gatherTabs_(tabFactory);

          this.tabSelectedHandler_ = function (_ref) {
            var detail = _ref.detail;
            var tab = detail.tab;

            _this.setActiveTab_(tab, true);
          };
        }
      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this2 = this;

          return new MDCTabBarFoundation({
            addClass: function addClass(className) {
              return _this2.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this2.root_.classList.remove(className);
            },
            bindOnMDCTabSelectedEvent: function bindOnMDCTabSelectedEvent() {
              return _this2.listen(MDCTabFoundation.strings.SELECTED_EVENT, _this2.tabSelectedHandler_);
            },
            unbindOnMDCTabSelectedEvent: function unbindOnMDCTabSelectedEvent() {
              return _this2.unlisten(MDCTabFoundation.strings.SELECTED_EVENT, _this2.tabSelectedHandler_);
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            getOffsetWidth: function getOffsetWidth() {
              return _this2.root_.offsetWidth;
            },
            setStyleForIndicator: function setStyleForIndicator(propertyName, value) {
              return _this2.indicator_.style.setProperty(propertyName, value);
            },
            getOffsetWidthForIndicator: function getOffsetWidthForIndicator() {
              return _this2.indicator_.offsetWidth;
            },
            notifyChange: function notifyChange(evtData) {
              return _this2.emit(MDCTabBarFoundation.strings.CHANGE_EVENT, evtData);
            },
            getNumberOfTabs: function getNumberOfTabs() {
              return _this2.tabs.length;
            },
            isTabActiveAtIndex: function isTabActiveAtIndex(index) {
              return _this2.tabs[index].isActive;
            },
            setTabActiveAtIndex: function setTabActiveAtIndex(index, isActive) {
              _this2.tabs[index].isActive = isActive;
            },
            isDefaultPreventedOnClickForTabAtIndex: function isDefaultPreventedOnClickForTabAtIndex(index) {
              return _this2.tabs[index].preventDefaultOnClick;
            },
            setPreventDefaultOnClickForTabAtIndex: function setPreventDefaultOnClickForTabAtIndex(index, preventDefaultOnClick) {
              _this2.tabs[index].preventDefaultOnClick = preventDefaultOnClick;
            },
            measureTabAtIndex: function measureTabAtIndex(index) {
              return _this2.tabs[index].measureSelf();
            },
            getComputedWidthForTabAtIndex: function getComputedWidthForTabAtIndex(index) {
              return _this2.tabs[index].computedWidth;
            },
            getComputedLeftForTabAtIndex: function getComputedLeftForTabAtIndex(index) {
              return _this2.tabs[index].computedLeft;
            }
          });
        }
      }, {
        key: "gatherTabs_",
        value: function gatherTabs_(tabFactory) {
          var tabElements = [].slice.call(this.root_.querySelectorAll(MDCTabBarFoundation.strings.TAB_SELECTOR));
          return tabElements.map(function (el) {
            return tabFactory(el);
          });
        }
      }, {
        key: "setActiveTabIndex_",
        value: function setActiveTabIndex_(activeTabIndex, notifyChange) {
          this.foundation_.switchToTabAtIndex(activeTabIndex, notifyChange);
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
      }, {
        key: "setActiveTab_",
        value: function setActiveTab_(activeTab, notifyChange) {
          var indexOfTab = this.tabs.indexOf(activeTab);

          if (indexOfTab < 0) {
            throw new Error('Invalid tab component given as activeTab: Tab not found within this component\'s tab list');
          }

          this.setActiveTabIndex_(indexOfTab, notifyChange);
        }
      }, {
        key: "tabs",
        get: function get() {
          return this.tabs_;
        }
      }, {
        key: "activeTab",
        get: function get() {
          var activeIndex = this.foundation_.getActiveTabIndex();
          return this.tabs[activeIndex];
        },
        set: function set(tab) {
          this.setActiveTab_(tab, false);
        }
      }, {
        key: "activeTabIndex",
        get: function get() {
          return this.foundation_.getActiveTabIndex();
        },
        set: function set(index) {
          this.setActiveTabIndex_(index, false);
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCTabBar(root);
        }
      }]);

      return MDCTabBar;
    }(MDCComponent$j);

    /**
     * Copyright 2017 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var cssClasses$3$2 = {
      INDICATOR_FORWARD: 'mdc-tab-bar-scroller__indicator--forward',
      INDICATOR_BACK: 'mdc-tab-bar-scroller__indicator--back',
      INDICATOR_ENABLED: 'mdc-tab-bar-scroller__indicator--enabled',
      TAB: 'mdc-tab'
    };
    var strings$3$1 = {
      FRAME_SELECTOR: '.mdc-tab-bar-scroller__scroll-frame',
      TABS_SELECTOR: '.mdc-tab-bar-scroller__scroll-frame__tabs',
      TAB_SELECTOR: '.mdc-tab',
      INDICATOR_FORWARD_SELECTOR: '.mdc-tab-bar-scroller__indicator--forward',
      INDICATOR_BACK_SELECTOR: '.mdc-tab-bar-scroller__indicator--back'
    };

    var MDCTabBarScrollerFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$l(MDCTabBarScrollerFoundation, _MDCFoundation);

      _createClass$l(MDCTabBarScrollerFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$3$2;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$3$1;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            eventTargetHasClass: function eventTargetHasClass() {
              return (
                /* target: EventTarget, className: string */

                /* boolean */
                false
              );
            },
            addClassToForwardIndicator: function addClassToForwardIndicator()
            /* className: string */
            {},
            removeClassFromForwardIndicator: function removeClassFromForwardIndicator()
            /* className: string */
            {},
            addClassToBackIndicator: function addClassToBackIndicator()
            /* className: string */
            {},
            removeClassFromBackIndicator: function removeClassFromBackIndicator()
            /* className: string */
            {},
            isRTL: function isRTL() {
              return (
                /* boolean */
                false
              );
            },
            registerBackIndicatorClickHandler: function registerBackIndicatorClickHandler()
            /* handler: EventListener */
            {},
            deregisterBackIndicatorClickHandler: function deregisterBackIndicatorClickHandler()
            /* handler: EventListener */
            {},
            registerForwardIndicatorClickHandler: function registerForwardIndicatorClickHandler()
            /* handler: EventListener */
            {},
            deregisterForwardIndicatorClickHandler: function deregisterForwardIndicatorClickHandler()
            /* handler: EventListener */
            {},
            registerCapturedInteractionHandler: function registerCapturedInteractionHandler()
            /* evt: string, handler: EventListener */
            {},
            deregisterCapturedInteractionHandler: function deregisterCapturedInteractionHandler()
            /* evt: string, handler: EventListener */
            {},
            registerWindowResizeHandler: function registerWindowResizeHandler()
            /* handler: EventListener */
            {},
            deregisterWindowResizeHandler: function deregisterWindowResizeHandler()
            /* handler: EventListener */
            {},
            getNumberOfTabs: function getNumberOfTabs() {
              return (
                /* number */
                0
              );
            },
            getComputedWidthForTabAtIndex: function getComputedWidthForTabAtIndex() {
              return (
                /* number */
                0
              );
            },
            getComputedLeftForTabAtIndex: function getComputedLeftForTabAtIndex() {
              return (
                /* number */
                0
              );
            },
            getOffsetWidthForScrollFrame: function getOffsetWidthForScrollFrame() {
              return (
                /* number */
                0
              );
            },
            getScrollLeftForScrollFrame: function getScrollLeftForScrollFrame() {
              return (
                /* number */
                0
              );
            },
            setScrollLeftForScrollFrame: function setScrollLeftForScrollFrame()
            /* scrollLeftAmount: number */
            {},
            getOffsetWidthForTabBar: function getOffsetWidthForTabBar() {
              return (
                /* number */
                0
              );
            },
            setTransformStyleForTabBar: function setTransformStyleForTabBar()
            /* value: string */
            {},
            getOffsetLeftForEventTarget: function getOffsetLeftForEventTarget() {
              return (
                /* target: EventTarget */

                /* number */
                0
              );
            },
            getOffsetWidthForEventTarget: function getOffsetWidthForEventTarget() {
              return (
                /* target: EventTarget */

                /* number */
                0
              );
            }
          };
        }
      }]);

      function MDCTabBarScrollerFoundation(adapter) {
        var _this;

        _classCallCheck$l(this, MDCTabBarScrollerFoundation);

        _this = _possibleConstructorReturn$l(this, _getPrototypeOf$l(MDCTabBarScrollerFoundation).call(this, Object.assign(MDCTabBarScrollerFoundation.defaultAdapter, adapter)));
        _this.pointerDownRecognized_ = false;
        _this.currentTranslateOffset_ = 0;
        _this.focusedTarget_ = null;
        _this.layoutFrame_ = 0;
        _this.scrollFrameScrollLeft_ = 0;

        _this.forwardIndicatorClickHandler_ = function (evt) {
          return _this.scrollForward(evt);
        };

        _this.backIndicatorClickHandler_ = function (evt) {
          return _this.scrollBack(evt);
        };

        _this.resizeHandler_ = function () {
          return _this.layout();
        };

        _this.interactionHandler_ = function (evt) {
          if (evt.type == 'touchstart' || evt.type == 'mousedown') {
            _this.pointerDownRecognized_ = true;
          }

          _this.handlePossibleTabKeyboardFocus_(evt);

          if (evt.type == 'focus') {
            _this.pointerDownRecognized_ = false;
          }
        };

        return _this;
      }

      _createClass$l(MDCTabBarScrollerFoundation, [{
        key: "init",
        value: function init() {
          var _this2 = this;

          this.adapter_.registerBackIndicatorClickHandler(this.backIndicatorClickHandler_);
          this.adapter_.registerForwardIndicatorClickHandler(this.forwardIndicatorClickHandler_);
          this.adapter_.registerWindowResizeHandler(this.resizeHandler_);
          ['touchstart', 'mousedown', 'focus'].forEach(function (evtType) {
            _this2.adapter_.registerCapturedInteractionHandler(evtType, _this2.interactionHandler_);
          });
          this.layout();
        }
      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          this.adapter_.deregisterBackIndicatorClickHandler(this.backIndicatorClickHandler_);
          this.adapter_.deregisterForwardIndicatorClickHandler(this.forwardIndicatorClickHandler_);
          this.adapter_.deregisterWindowResizeHandler(this.resizeHandler_);
          ['touchstart', 'mousedown', 'focus'].forEach(function (evtType) {
            _this3.adapter_.deregisterCapturedInteractionHandler(evtType, _this3.interactionHandler_);
          });
        }
      }, {
        key: "scrollBack",
        value: function scrollBack() {
          var evt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

          if (evt) {
            evt.preventDefault();
          }

          var tabWidthAccumulator = 0;
          var scrollTargetIndex = 0;

          for (var i = this.adapter_.getNumberOfTabs() - 1; i > 0; i--) {
            var tabOffsetLeft = this.adapter_.getComputedLeftForTabAtIndex(i);
            var tabBarWidthLessTabOffsetLeft = this.adapter_.getOffsetWidthForTabBar() - tabOffsetLeft;
            var tabIsNotOccluded = tabOffsetLeft > this.currentTranslateOffset_;

            if (this.isRTL_()) {
              tabIsNotOccluded = tabBarWidthLessTabOffsetLeft > this.currentTranslateOffset_;
            }

            if (tabIsNotOccluded) {
              continue;
            }

            tabWidthAccumulator += this.adapter_.getComputedWidthForTabAtIndex(i);
            var scrollTargetDetermined = tabWidthAccumulator > this.adapter_.getOffsetWidthForScrollFrame();

            if (scrollTargetDetermined) {
              scrollTargetIndex = this.isRTL_() ? i + 1 : i;
              break;
            }
          }

          this.scrollToTabAtIndex(scrollTargetIndex);
        }
      }, {
        key: "scrollForward",
        value: function scrollForward() {
          var evt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

          if (evt) {
            evt.preventDefault();
          }

          var scrollFrameOffsetWidth = this.adapter_.getOffsetWidthForScrollFrame() + this.currentTranslateOffset_;
          var scrollTargetIndex = 0;

          for (var i = 0; i < this.adapter_.getNumberOfTabs(); i++) {
            var tabOffsetLeftAndWidth = this.adapter_.getComputedLeftForTabAtIndex(i) + this.adapter_.getComputedWidthForTabAtIndex(i);
            var scrollTargetDetermined = tabOffsetLeftAndWidth > scrollFrameOffsetWidth;

            if (this.isRTL_()) {
              var frameOffsetAndTabWidth = scrollFrameOffsetWidth - this.adapter_.getComputedWidthForTabAtIndex(i);

              var _tabOffsetLeftAndWidth = this.adapter_.getComputedLeftForTabAtIndex(i) + this.adapter_.getComputedWidthForTabAtIndex(i);

              var tabRightOffset = this.adapter_.getOffsetWidthForTabBar() - _tabOffsetLeftAndWidth;

              scrollTargetDetermined = tabRightOffset > frameOffsetAndTabWidth;
            }

            if (scrollTargetDetermined) {
              scrollTargetIndex = i;
              break;
            }
          }

          this.scrollToTabAtIndex(scrollTargetIndex);
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this4 = this;

          cancelAnimationFrame(this.layoutFrame_);
          this.scrollFrameScrollLeft_ = this.adapter_.getScrollLeftForScrollFrame();
          this.layoutFrame_ = requestAnimationFrame(function () {
            return _this4.layout_();
          });
        }
      }, {
        key: "isRTL_",
        value: function isRTL_() {
          return this.adapter_.isRTL();
        }
      }, {
        key: "handlePossibleTabKeyboardFocus_",
        value: function handlePossibleTabKeyboardFocus_(evt) {
          if (!this.adapter_.eventTargetHasClass(evt.target, cssClasses$3$2.TAB) || this.pointerDownRecognized_) {
            return;
          }

          var resetAmt = this.isRTL_() ? this.scrollFrameScrollLeft_ : 0;
          this.adapter_.setScrollLeftForScrollFrame(resetAmt);
          this.focusedTarget_ = evt.target;
          var scrollFrameWidth = this.adapter_.getOffsetWidthForScrollFrame();
          var tabBarWidth = this.adapter_.getOffsetWidthForTabBar();
          var leftEdge = this.adapter_.getOffsetLeftForEventTarget(this.focusedTarget_);
          var rightEdge = leftEdge + this.adapter_.getOffsetWidthForEventTarget(this.focusedTarget_);
          var shouldScrollBack = rightEdge <= this.currentTranslateOffset_;
          var shouldScrollForward = rightEdge > this.currentTranslateOffset_ + scrollFrameWidth;

          if (this.isRTL_()) {
            var normalizedLeftOffset = tabBarWidth - leftEdge;
            shouldScrollBack = leftEdge >= tabBarWidth - this.currentTranslateOffset_;
            shouldScrollForward = normalizedLeftOffset > scrollFrameWidth + this.currentTranslateOffset_;
          }

          if (shouldScrollForward) {
            this.scrollForward();
          } else if (shouldScrollBack) {
            this.scrollBack();
          }

          this.pointerDownRecognized_ = false;
        }
      }, {
        key: "layout_",
        value: function layout_() {
          var frameWidth = this.adapter_.getOffsetWidthForScrollFrame();
          var isOverflowing = this.adapter_.getOffsetWidthForTabBar() > frameWidth;

          if (!isOverflowing) {
            this.currentTranslateOffset_ = 0;
          }

          this.shiftFrame_();
          this.updateIndicatorEnabledStates_();
        }
      }, {
        key: "scrollToTabAtIndex",
        value: function scrollToTabAtIndex(index) {
          var _this5 = this;

          var scrollTargetOffsetLeft = this.adapter_.getComputedLeftForTabAtIndex(index);
          var scrollTargetOffsetWidth = this.adapter_.getComputedWidthForTabAtIndex(index);
          this.currentTranslateOffset_ = this.normalizeForRTL_(scrollTargetOffsetLeft, scrollTargetOffsetWidth);
          requestAnimationFrame(function () {
            return _this5.shiftFrame_();
          });
        }
      }, {
        key: "normalizeForRTL_",
        value: function normalizeForRTL_(left, width) {
          return this.isRTL_() ? this.adapter_.getOffsetWidthForTabBar() - (left + width) : left;
        }
      }, {
        key: "shiftFrame_",
        value: function shiftFrame_() {
          var shiftAmount = this.isRTL_() ? this.currentTranslateOffset_ : -this.currentTranslateOffset_;
          this.adapter_.setTransformStyleForTabBar("translateX(".concat(shiftAmount, "px)"));
          this.updateIndicatorEnabledStates_();
        }
      }, {
        key: "updateIndicatorEnabledStates_",
        value: function updateIndicatorEnabledStates_() {
          var INDICATOR_ENABLED = cssClasses$3$2.INDICATOR_ENABLED;

          if (this.currentTranslateOffset_ === 0) {
            this.adapter_.removeClassFromBackIndicator(INDICATOR_ENABLED);
          } else {
            this.adapter_.addClassToBackIndicator(INDICATOR_ENABLED);
          }

          var remainingTabBarWidth = this.adapter_.getOffsetWidthForTabBar() - this.currentTranslateOffset_;

          if (remainingTabBarWidth > this.adapter_.getOffsetWidthForScrollFrame()) {
            this.adapter_.addClassToForwardIndicator(INDICATOR_ENABLED);
          } else {
            this.adapter_.removeClassFromForwardIndicator(INDICATOR_ENABLED);
          }
        }
      }]);

      return MDCTabBarScrollerFoundation;
    }(MDCFoundation$k);

    var MDCTabBarScroller =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$l(MDCTabBarScroller, _MDCComponent);

      function MDCTabBarScroller() {
        _classCallCheck$l(this, MDCTabBarScroller);

        return _possibleConstructorReturn$l(this, _getPrototypeOf$l(MDCTabBarScroller).apply(this, arguments));
      }

      _createClass$l(MDCTabBarScroller, [{
        key: "initialize",
        value: function initialize() {
          var tabBarFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (root) {
            return new MDCTabBar(root);
          };
          this.scrollFrame_ = this.root_.querySelector(MDCTabBarScrollerFoundation.strings.FRAME_SELECTOR);
          this.tabBarEl_ = this.root_.querySelector(MDCTabBarScrollerFoundation.strings.TABS_SELECTOR);
          this.forwardIndicator_ = this.root_.querySelector(MDCTabBarScrollerFoundation.strings.INDICATOR_FORWARD_SELECTOR);
          this.backIndicator_ = this.root_.querySelector(MDCTabBarScrollerFoundation.strings.INDICATOR_BACK_SELECTOR);
          this.tabBar_ = tabBarFactory(this.tabBarEl_);
        }
      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCTabBarScrollerFoundation({
            addClass: function addClass(className) {
              return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this.root_.classList.remove(className);
            },
            eventTargetHasClass: function eventTargetHasClass(target, className) {
              return target.classList.contains(className);
            },
            addClassToForwardIndicator: function addClassToForwardIndicator(className) {
              return _this.forwardIndicator_.classList.add(className);
            },
            removeClassFromForwardIndicator: function removeClassFromForwardIndicator(className) {
              return _this.forwardIndicator_.classList.remove(className);
            },
            addClassToBackIndicator: function addClassToBackIndicator(className) {
              return _this.backIndicator_.classList.add(className);
            },
            removeClassFromBackIndicator: function removeClassFromBackIndicator(className) {
              return _this.backIndicator_.classList.remove(className);
            },
            isRTL: function isRTL() {
              return getComputedStyle(_this.root_).getPropertyValue('direction') === 'rtl';
            },
            registerBackIndicatorClickHandler: function registerBackIndicatorClickHandler(handler) {
              return _this.backIndicator_.addEventListener('click', handler);
            },
            deregisterBackIndicatorClickHandler: function deregisterBackIndicatorClickHandler(handler) {
              return _this.backIndicator_.removeEventListener('click', handler);
            },
            registerForwardIndicatorClickHandler: function registerForwardIndicatorClickHandler(handler) {
              return _this.forwardIndicator_.addEventListener('click', handler);
            },
            deregisterForwardIndicatorClickHandler: function deregisterForwardIndicatorClickHandler(handler) {
              return _this.forwardIndicator_.removeEventListener('click', handler);
            },
            registerCapturedInteractionHandler: function registerCapturedInteractionHandler(evt, handler) {
              return _this.root_.addEventListener(evt, handler, true);
            },
            deregisterCapturedInteractionHandler: function deregisterCapturedInteractionHandler(evt, handler) {
              return _this.root_.removeEventListener(evt, handler, true);
            },
            registerWindowResizeHandler: function registerWindowResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterWindowResizeHandler: function deregisterWindowResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            getNumberOfTabs: function getNumberOfTabs() {
              return _this.tabBar.tabs.length;
            },
            getComputedWidthForTabAtIndex: function getComputedWidthForTabAtIndex(index) {
              return _this.tabBar.tabs[index].computedWidth;
            },
            getComputedLeftForTabAtIndex: function getComputedLeftForTabAtIndex(index) {
              return _this.tabBar.tabs[index].computedLeft;
            },
            getOffsetWidthForScrollFrame: function getOffsetWidthForScrollFrame() {
              return _this.scrollFrame_.offsetWidth;
            },
            getScrollLeftForScrollFrame: function getScrollLeftForScrollFrame() {
              return _this.scrollFrame_.scrollLeft;
            },
            setScrollLeftForScrollFrame: function setScrollLeftForScrollFrame(scrollLeftAmount) {
              return _this.scrollFrame_.scrollLeft = scrollLeftAmount;
            },
            getOffsetWidthForTabBar: function getOffsetWidthForTabBar() {
              return _this.tabBarEl_.offsetWidth;
            },
            setTransformStyleForTabBar: function setTransformStyleForTabBar(value) {
              _this.tabBarEl_.style.setProperty(getCorrectPropertyName$1(window, 'transform'), value);
            },
            getOffsetLeftForEventTarget: function getOffsetLeftForEventTarget(target) {
              return target.offsetLeft;
            },
            getOffsetWidthForEventTarget: function getOffsetWidthForEventTarget(target) {
              return target.offsetWidth;
            }
          });
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
      }, {
        key: "tabBar",
        get: function get() {
          return this.tabBar_;
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCTabBarScroller(root);
        }
      }]);

      return MDCTabBarScroller;
    }(MDCComponent$j);

    /**
     * Copyright 2017 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcTabIconText = /** @class */ (function () {
        function MdcTabIconText(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcTabIconText.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdc-tab-icon-text], mdc-tab-icon-text',
                        exportAs: 'mdcTabIconText'
                    },] },
        ];
        /** @nocollapse */
        MdcTabIconText.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcTabIconText.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-tab__icon-text',] }]
        };
        return MdcTabIconText;
    }());
    var MdcTab = /** @class */ (function () {
        function MdcTab(_changeDetectorRef, _renderer, elementRef, _registry, ripple) {
            var _this = this;
            this._changeDetectorRef = _changeDetectorRef;
            this._renderer = _renderer;
            this.elementRef = elementRef;
            this._registry = _registry;
            this.ripple = ripple;
            /**
             * Emits whenever the component is destroyed.
             */
            this._destroy = new rxjs.Subject();
            this._active = false;
            this._disabled = false;
            /**
             * Event emitted when the option is selected.
             */
            this.selected = new core.EventEmitter();
            this.isHostClass = true;
            this.role = 'tab';
            this._mdcAdapter = {
                addClass: function (className) {
                    _this._renderer.addClass(_this._getHostElement(), className);
                },
                removeClass: function (className) {
                    _this._renderer.removeClass(_this._getHostElement(), className);
                },
                registerInteractionHandler: function (type, handler) {
                    _this._registry.listen(type, handler, _this._getHostElement());
                },
                deregisterInteractionHandler: function (type, handler) {
                    _this._registry.unlisten(type, handler);
                },
                getOffsetWidth: function () { return _this._getHostElement().offsetWidth; },
                getOffsetLeft: function () { return _this._getHostElement().offsetLeft; },
                notifySelected: function () { return _this._emitSelectedEvent(); }
            };
            this._foundation = new MDCTabFoundation(this._mdcAdapter);
        }
        Object.defineProperty(MdcTab.prototype, "active", {
            get: /**
             * @return {?}
             */
            function () { return this._active; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setActive(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTab.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setDisabled(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTab.prototype, "classIconText", {
            get: /**
             * @return {?}
             */
            function () {
                return this.tabIcon != null && this.tabIconText != null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTab.prototype, "classActive", {
            get: /**
             * @return {?}
             */
            function () {
                return this._active ? 'mdc-tab--active' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTab.prototype, "classDisabled", {
            get: /**
             * @return {?}
             */
            function () {
                return this._disabled ? 'ng-mdc-tab--disabled' : '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcTab.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this._foundation.init();
            this.setPreventDefaultOnClick(true);
            if (this.tabRouter) {
                this._routerChangeSubscription = this.tabRouter.routeChange
                    .pipe(operators.takeUntil(this._destroy))
                    .subscribe(function (_) {
                    _this.setActive(_.active);
                    _this._emitSelectedEvent();
                });
            }
        };
        /**
         * @return {?}
         */
        MdcTab.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroy.next();
            this._destroy.complete();
            this._foundation.destroy();
        };
        /**
         * @return {?}
         */
        MdcTab.prototype.isActive = /**
         * @return {?}
         */
        function () {
            return this._foundation.isActive();
        };
        /**
         * @param {?} active
         * @return {?}
         */
        MdcTab.prototype.setActive = /**
         * @param {?} active
         * @return {?}
         */
        function (active) {
            this._active = toBoolean(active);
            this._foundation.setActive(active);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} disabled
         * @return {?}
         */
        MdcTab.prototype.setDisabled = /**
         * @param {?} disabled
         * @return {?}
         */
        function (disabled) {
            this._disabled = disabled;
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @return {?}
         */
        MdcTab.prototype.getComputedWidth = /**
         * @return {?}
         */
        function () {
            return this._foundation.getComputedWidth();
        };
        /**
         * @return {?}
         */
        MdcTab.prototype.getComputedLeft = /**
         * @return {?}
         */
        function () {
            return this._mdcAdapter.getOffsetLeft();
        };
        /**
         * @return {?}
         */
        MdcTab.prototype.getPreventDefaultOnClick = /**
         * @return {?}
         */
        function () {
            return this._foundation.preventsDefaultOnClick();
        };
        /**
         * @param {?} preventDefaultOnClick
         * @return {?}
         */
        MdcTab.prototype.setPreventDefaultOnClick = /**
         * @param {?} preventDefaultOnClick
         * @return {?}
         */
        function (preventDefaultOnClick) {
            this._foundation.setPreventDefaultOnClick(preventDefaultOnClick);
        };
        /**
         * @return {?}
         */
        MdcTab.prototype.measureSelf = /**
         * @return {?}
         */
        function () {
            this._foundation.measureSelf();
        };
        /**
         * Emits the tab selected event.
         * @return {?}
         */
        MdcTab.prototype._emitSelectedEvent = /**
         * Emits the tab selected event.
         * @return {?}
         */
        function () {
            this.selected.emit({ tab: this });
        };
        /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        MdcTab.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcTab.decorators = [
            { type: core.Component, args: [{selector: '[mdc-tab], mdc-tab',
                        exportAs: 'mdcTab',
                        template: '<ng-content></ng-content>',
                        providers: [
                            MdcRipple,
                            EventRegistry
                        ],
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcTab.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.Renderer2 },
            { type: core.ElementRef },
            { type: EventRegistry },
            { type: MdcRipple }
        ]; };
        MdcTab.propDecorators = {
            active: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            selected: [{ type: core.Output }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-tab',] }],
            role: [{ type: core.HostBinding, args: ['attr.role',] }],
            classIconText: [{ type: core.HostBinding, args: ['class.mdc-tab--with-icon-and-text',] }],
            classActive: [{ type: core.HostBinding, args: ['class.mdc-tab--active',] }],
            classDisabled: [{ type: core.HostBinding, args: ['class.ng-mdc-tab--disabled',] }],
            tabIcon: [{ type: core.ContentChild, args: [MdcIcon,] }],
            tabIconText: [{ type: core.ContentChild, args: [MdcTabIconText,] }],
            tabRouter: [{ type: core.ContentChild, args: [MdcRouter,] }]
        };
        return MdcTab;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * A simple change event emitted selection changes.
     */
    var   /**
     * A simple change event emitted selection changes.
     */
    MdcTabChangeEvent = /** @class */ (function () {
        function MdcTabChangeEvent(index, tab) {
            this.index = index;
            this.tab = tab;
        }
        return MdcTabChangeEvent;
    }());
    var MdcTabBarIndicator = /** @class */ (function () {
        function MdcTabBarIndicator(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcTabBarIndicator.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdc-tab-bar-indicator], mdc-tab-bar-indicator',
                        exportAs: 'mdcTabBarIndicator'
                    },] },
        ];
        /** @nocollapse */
        MdcTabBarIndicator.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcTabBarIndicator.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-tab-bar__indicator',] }]
        };
        return MdcTabBarIndicator;
    }());
    var MdcTabBar = /** @class */ (function () {
        function MdcTabBar(_ngZone, _changeDetectorRef, _renderer, elementRef, _registry) {
            var _this = this;
            this._ngZone = _ngZone;
            this._changeDetectorRef = _changeDetectorRef;
            this._renderer = _renderer;
            this.elementRef = elementRef;
            this._registry = _registry;
            /**
             * Emits whenever the component is destroyed.
             */
            this._destroy = new rxjs.Subject();
            this._disableRipple = false;
            this._primary = false;
            this._secondary = false;
            /**
             * The tab index that should be selected after the content has been checked.
             */
            this._indexToSelect = 0;
            this._selectedIndex = null;
            /**
             * Event emitted when the tab selection has changed.
             */
            this.selectedTabChange = new core.EventEmitter(true);
            /**
             * Event emitted when tabs are added or removed.
             */
            this.tabsChangeEvent = new core.EventEmitter();
            this.isHostClass = true;
            this.scrollFrameContent = false;
            this.role = 'tablist';
            /**
             * Combined stream of all of the tab change events.
             */
            this.optionSelectionChanges = rxjs.defer(function () {
                if (_this.tabs) {
                    return rxjs.merge.apply(void 0, _this.tabs.map(function (option) { return option.selected; }));
                }
                return _this._ngZone.onStable
                    .asObservable()
                    .pipe(operators.take(1), operators.switchMap(function () { return _this.optionSelectionChanges; }));
            });
            this._mdcAdapter = {
                addClass: function (className) {
                    _this._renderer.addClass(_this.elementRef.nativeElement, className);
                },
                removeClass: function (className) {
                    _this._renderer.removeClass(_this.elementRef.nativeElement, className);
                },
                bindOnMDCTabSelectedEvent: function () {
                    var /** @type {?} */ changedOrDestroyed = rxjs.merge(_this.tabs.changes, _this._destroy);
                    _this.optionSelectionChanges
                        .pipe(operators.takeUntil(changedOrDestroyed)).subscribe(function (event) {
                        if (event.tab.disabled) {
                            return;
                        }
                        _this.setActiveTab(event.tab, true);
                        _this._foundation.switchToTabAtIndex(_this.getActiveTabIndex(), true);
                        _this.selectedTabChange.emit(new MdcTabChangeEvent(_this.getActiveTabIndex(), event.tab));
                    });
                },
                unbindOnMDCTabSelectedEvent: function () {
                    /* not needed */ 
                },
                registerResizeHandler: function (handler) {
                    if (isBrowser()) {
                        _this._registry.listen('resize', handler, window);
                    }
                },
                deregisterResizeHandler: function (handler) {
                    if (isBrowser()) {
                        _this._registry.unlisten('resize', handler);
                    }
                },
                getOffsetWidth: function () { return _this.elementRef.nativeElement.offsetWidth; },
                setStyleForIndicator: function (propertyName, value) {
                    return _this._renderer.setStyle(_this.indicator.elementRef.nativeElement, propertyName, value);
                },
                getOffsetWidthForIndicator: function () { return _this.indicator.elementRef.nativeElement.offsetWidth; },
                getNumberOfTabs: function () { return _this.tabs.length; },
                isTabActiveAtIndex: function (index) { return _this.tabs.toArray()[index].isActive(); },
                setTabActiveAtIndex: function (index, isActive) { return _this.tabs.toArray()[index].setActive(isActive); },
                isDefaultPreventedOnClickForTabAtIndex: function (index) { return !!_this.tabs.toArray()[index].getPreventDefaultOnClick(); },
                setPreventDefaultOnClickForTabAtIndex: function (index, preventDefaultOnClick) {
                    return _this.tabs.toArray()[index].setPreventDefaultOnClick(preventDefaultOnClick);
                },
                measureTabAtIndex: function (index) { return _this.tabs.toArray()[index].measureSelf(); },
                getComputedWidthForTabAtIndex: function (index) {
                    return _this.tabs.length ? _this.tabs.toArray()[index].getComputedWidth() : -1;
                },
                getComputedLeftForTabAtIndex: function (index) {
                    return _this.tabs.length ? _this.tabs.toArray()[index].getComputedLeft() : -1;
                }
            };
            this._foundation = new MDCTabBarFoundation(this._mdcAdapter);
        }
        Object.defineProperty(MdcTabBar.prototype, "selectedIndex", {
            get: /**
             * @return {?}
             */
            function () { return this._selectedIndex; },
            /** The index of the active tab. */
            set: /**
             * The index of the active tab.
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._indexToSelect = toNumber(value, null);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTabBar.prototype, "primary", {
            get: /**
             * @return {?}
             */
            function () { return this._primary; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._primary = toBoolean(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTabBar.prototype, "secondary", {
            get: /**
             * @return {?}
             */
            function () { return this._secondary; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._secondary = toBoolean(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTabBar.prototype, "disableRipple", {
            get: /**
             * @return {?}
             */
            function () { return this._disableRipple; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setDisableRipple(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTabBar.prototype, "classTabIcon", {
            get: /**
             * @return {?}
             */
            function () {
                return this.tabs.length > 0
                    && this.tabs.first.tabIcon != null
                    && this.tabs.first.tabIconText == null ? 'mdc-tab-bar--icon-tab-bar' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTabBar.prototype, "classTabIconText", {
            get: /**
             * @return {?}
             */
            function () {
                return this.tabs.length > 0
                    && this.tabs.first.tabIcon != null
                    && this.tabs.first.tabIconText != null ? 'mdc-tab-bar--icons-with-text' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTabBar.prototype, "classPrimary", {
            get: /**
             * @return {?}
             */
            function () {
                return this.primary ? 'ng-mdc-tab--primary' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTabBar.prototype, "classSecondary", {
            get: /**
             * @return {?}
             */
            function () {
                return this.secondary ? 'ng-mdc-tab--secondary' : '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcTabBar.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            // Subscribe to changes in the amount of tabs, in order to be
            // able to re-render the content as new tabs are added or removed.
            this.tabs.changes.pipe(operators.startWith(null), operators.takeUntil(this._destroy)).subscribe(function () {
                _this._foundation.init();
                _this._initializeSelection();
                _this.setDisableRipple(_this.disableRipple);
                _this._foundation.layout();
                _this.tabsChangeEvent.emit();
            });
        };
        /**
         * @return {?}
         */
        MdcTabBar.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this._destroy.next();
            this._destroy.complete();
            this._foundation.destroy();
        };
        /**
         * @return {?}
         */
        MdcTabBar.prototype._initializeSelection = /**
         * @return {?}
         */
        function () {
            var _this = this;
            // Defer setting the value in order to avoid the "Expression
            // has changed after it was checked" errors from Angular.
            Promise.resolve().then(function () {
                if (_this.getActiveTabIndex() < 0 && _this.tabs.first) {
                    _this.tabs.first.setActive(true);
                }
            });
        };
        /**
         * @param {?} disabled
         * @return {?}
         */
        MdcTabBar.prototype.setDisableRipple = /**
         * @param {?} disabled
         * @return {?}
         */
        function (disabled) {
            if (!this.tabs) {
                return;
            }
            if (this._disableRipple !== disabled) {
                this._disableRipple = disabled;
            }
            this.tabs.forEach(function (tab) {
                disabled ? tab.ripple.destroy() : tab.ripple.attachTo(tab.elementRef.nativeElement);
            });
        };
        /**
         * @param {?} index
         * @return {?}
         */
        MdcTabBar.prototype.setTabActiveAtIndex = /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            if (this.tabs.toArray()[index].disabled) {
                return;
            }
            this._foundation.switchToTabAtIndex(index, true);
            this._mdcAdapter.setTabActiveAtIndex(index, true);
        };
        /**
         * @return {?}
         */
        MdcTabBar.prototype.getActiveTabIndex = /**
         * @return {?}
         */
        function () {
            return this._foundation.getActiveTabIndex();
        };
        /**
         * @return {?}
         */
        MdcTabBar.prototype.getActiveTab = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ tab = this.tabs.find(function (_) { return _.isActive(); });
            return tab ? tab[0] : null;
        };
        /**
         * @param {?} tab
         * @param {?} active
         * @return {?}
         */
        MdcTabBar.prototype.setActiveTab = /**
         * @param {?} tab
         * @param {?} active
         * @return {?}
         */
        function (tab, active) {
            this.tabs.forEach(function (_) {
                _.setActive(false);
            }); /** @type {?} */
            ((this.tabs.find(function (_) { return _ === tab; }))).setActive(active);
        };
        /**
         * @return {?}
         */
        MdcTabBar.prototype.layout = /**
         * @return {?}
         */
        function () {
            this._foundation.layout();
        };
        /**
         * @return {?}
         */
        MdcTabBar.prototype.getNumberOfTabs = /**
         * @return {?}
         */
        function () {
            return this._mdcAdapter.getNumberOfTabs();
        };
        /**
         * @return {?}
         */
        MdcTabBar.prototype.getComputedWidth = /**
         * @return {?}
         */
        function () {
            return this._mdcAdapter.getOffsetWidth();
        };
        /**
         * @param {?} index
         * @param {?} preventDefaultOnClick
         * @return {?}
         */
        MdcTabBar.prototype.setPreventDefaultOnClickForTabAtIndex = /**
         * @param {?} index
         * @param {?} preventDefaultOnClick
         * @return {?}
         */
        function (index, preventDefaultOnClick) {
            this._mdcAdapter.setPreventDefaultOnClickForTabAtIndex(index, preventDefaultOnClick);
        };
        /**
         * @param {?} index
         * @return {?}
         */
        MdcTabBar.prototype.isDefaultPreventedOnClickForTabAtIndex = /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            return this._mdcAdapter.isDefaultPreventedOnClickForTabAtIndex(index);
        };
        MdcTabBar.decorators = [
            { type: core.Component, args: [{selector: '[mdc-tab-bar], mdc-tab-bar',
                        exportAs: 'mdcTabBar',
                        template: "\n  <ng-content></ng-content>\n  <mdc-tab-bar-indicator></mdc-tab-bar-indicator>\n  ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [EventRegistry]
                    },] },
        ];
        /** @nocollapse */
        MdcTabBar.ctorParameters = function () { return [
            { type: core.NgZone },
            { type: core.ChangeDetectorRef },
            { type: core.Renderer2 },
            { type: core.ElementRef },
            { type: EventRegistry }
        ]; };
        MdcTabBar.propDecorators = {
            selectedIndex: [{ type: core.Input }],
            primary: [{ type: core.Input }],
            secondary: [{ type: core.Input }],
            disableRipple: [{ type: core.Input }],
            selectedTabChange: [{ type: core.Output }],
            tabsChangeEvent: [{ type: core.Output }],
            tabs: [{ type: core.ContentChildren, args: [MdcTab,] }],
            indicator: [{ type: core.ViewChild, args: [MdcTabBarIndicator,] }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-tab-bar',] }],
            scrollFrameContent: [{ type: core.HostBinding, args: ['class.mdc-tab-bar-scroller__scroll-frame__tabs',] }],
            role: [{ type: core.HostBinding, args: ['attr.role',] }],
            classTabIcon: [{ type: core.HostBinding, args: ['class.mdc-tab-bar--icon-tab-bar',] }],
            classTabIconText: [{ type: core.HostBinding, args: ['class.mdc-tab-bar--icons-with-text',] }],
            classPrimary: [{ type: core.HostBinding, args: ['class.ng-mdc-tab--primary',] }],
            classSecondary: [{ type: core.HostBinding, args: ['class.ng-mdc-tab--secondary',] }]
        };
        return MdcTabBar;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcTabBarScrollBack = /** @class */ (function () {
        function MdcTabBarScrollBack(_renderer, elementRef) {
            this._renderer = _renderer;
            this.elementRef = elementRef;
            this.isHostClass = true;
            this.isBackClass = true;
        }
        /**
         * @return {?}
         */
        MdcTabBarScrollBack.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            if (this.icon) {
                this._renderer.addClass(this.icon.elementRef.nativeElement, 'mdc-tab-bar-scroller__indicator__inner');
            }
        };
        MdcTabBarScrollBack.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdc-tab-bar-scroll-back], mdc-tab-bar-scroll-back',
                        exportAs: 'mdcTabBarScrollBack'
                    },] },
        ];
        /** @nocollapse */
        MdcTabBarScrollBack.ctorParameters = function () { return [
            { type: core.Renderer2 },
            { type: core.ElementRef }
        ]; };
        MdcTabBarScrollBack.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-tab-bar-scroller__indicator',] }],
            isBackClass: [{ type: core.HostBinding, args: ['class.mdc-tab-bar-scroller__indicator--back',] }],
            icon: [{ type: core.ContentChild, args: [MdcIcon,] }]
        };
        return MdcTabBarScrollBack;
    }());
    var MdcTabBarScrollForward = /** @class */ (function () {
        function MdcTabBarScrollForward(_renderer, elementRef) {
            this._renderer = _renderer;
            this.elementRef = elementRef;
            this.isHostClass = true;
            this.isForwardClass = true;
        }
        /**
         * @return {?}
         */
        MdcTabBarScrollForward.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            if (this.icon) {
                this._renderer.addClass(this.icon.elementRef.nativeElement, 'mdc-tab-bar-scroller__indicator__inner');
            }
        };
        MdcTabBarScrollForward.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdc-tab-bar-scroll-forward], mdc-tab-bar-scroll-forward',
                        exportAs: 'mdcTabBarScrollForward'
                    },] },
        ];
        /** @nocollapse */
        MdcTabBarScrollForward.ctorParameters = function () { return [
            { type: core.Renderer2 },
            { type: core.ElementRef }
        ]; };
        MdcTabBarScrollForward.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-tab-bar-scroller__indicator',] }],
            isForwardClass: [{ type: core.HostBinding, args: ['class.mdc-tab-bar-scroller__indicator--forward',] }],
            icon: [{ type: core.ContentChild, args: [MdcIcon,] }]
        };
        return MdcTabBarScrollForward;
    }());
    var MdcTabBarScrollFrame = /** @class */ (function () {
        function MdcTabBarScrollFrame(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        /**
         * @return {?}
         */
        MdcTabBarScrollFrame.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            if (this.tabBar) {
                this.tabBar.scrollFrameContent = true;
            }
        };
        /**
         * @param {?} index
         * @return {?}
         */
        MdcTabBarScrollFrame.prototype.findTab = /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            return this.tabBar.tabs.toArray()[index];
        };
        MdcTabBarScrollFrame.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdc-tab-bar-scroll-frame], mdc-tab-bar-scroll-frame',
                        exportAs: 'mdcTabBarScrollFrame'
                    },] },
        ];
        /** @nocollapse */
        MdcTabBarScrollFrame.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcTabBarScrollFrame.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-tab-bar-scroller__scroll-frame',] }],
            tabBar: [{ type: core.ContentChild, args: [MdcTabBar,] }]
        };
        return MdcTabBarScrollFrame;
    }());
    var MdcTabBarScroller = /** @class */ (function () {
        function MdcTabBarScroller(_renderer, elementRef, _registry) {
            var _this = this;
            this._renderer = _renderer;
            this.elementRef = elementRef;
            this._registry = _registry;
            this.direction = 'ltr';
            this.isHostClass = true;
            this._mdcAdapter = {
                addClass: function (className) {
                    _this._renderer.addClass(_this.elementRef.nativeElement, className);
                },
                removeClass: function (className) {
                    _this._renderer.removeClass(_this.elementRef.nativeElement, className);
                },
                eventTargetHasClass: function (target, className) { return target.classList.contains(className); },
                addClassToForwardIndicator: function (className) {
                    if (_this.scrollForward) {
                        _this._renderer.addClass(_this.forward.elementRef.nativeElement, className);
                    }
                },
                removeClassFromForwardIndicator: function (className) {
                    if (_this.scrollForward) {
                        _this._renderer.removeClass(_this.forward.elementRef.nativeElement, className);
                    }
                },
                addClassToBackIndicator: function (className) {
                    if (_this.scrollBack) {
                        _this._renderer.addClass(_this.back.elementRef.nativeElement, className);
                    }
                },
                removeClassFromBackIndicator: function (className) {
                    if (_this.scrollBack) {
                        _this._renderer.removeClass(_this.back.elementRef.nativeElement, className);
                    }
                },
                isRTL: function () { return _this.direction === 'rtl'; },
                registerBackIndicatorClickHandler: function (handler) {
                    if (_this.scrollBack) {
                        _this._registry.listen('click', handler, _this.back.elementRef.nativeElement);
                    }
                },
                deregisterBackIndicatorClickHandler: function (handler) {
                    if (_this.scrollBack) {
                        _this._registry.unlisten('click', handler);
                    }
                },
                registerForwardIndicatorClickHandler: function (handler) {
                    if (_this.scrollForward) {
                        _this._registry.listen('click', handler, _this.forward.elementRef.nativeElement);
                    }
                },
                deregisterForwardIndicatorClickHandler: function (handler) {
                    if (_this.scrollForward) {
                        _this._registry.unlisten('click', handler);
                    }
                },
                registerCapturedInteractionHandler: function (evt, handler) {
                    _this._registry.listen(evt, handler, _this.elementRef.nativeElement);
                },
                deregisterCapturedInteractionHandler: function (evt, handler) {
                    _this._registry.unlisten(evt, handler);
                },
                registerWindowResizeHandler: function (handler) {
                    if (isBrowser()) {
                        _this._registry.listen('resize', handler, window);
                    }
                },
                deregisterWindowResizeHandler: function (handler) {
                    if (isBrowser()) {
                        _this._registry.unlisten('resize', handler);
                    }
                },
                getNumberOfTabs: function () {
                    return (_this.scrollFrame && _this.scrollFrame.tabBar) ? _this.scrollFrame.tabBar.tabs.length : 0;
                },
                getComputedWidthForTabAtIndex: function (index) { return _this.scrollFrame.findTab(index).getComputedWidth(); },
                getComputedLeftForTabAtIndex: function (index) { return _this.scrollFrame.findTab(index).getComputedLeft(); },
                getOffsetWidthForScrollFrame: function () {
                    return _this.scrollFrame ? _this.scrollFrame.elementRef.nativeElement.offsetWidth : 0;
                },
                getScrollLeftForScrollFrame: function () {
                    return _this.scrollFrame ? _this.scrollFrame.elementRef.nativeElement.scrollLeft : 0;
                },
                setScrollLeftForScrollFrame: function (scrollLeftAmount) {
                    if (_this.scrollFrame) {
                        _this._renderer.setProperty(_this.scrollFrame.elementRef.nativeElement, 'scrollLeft', scrollLeftAmount);
                    }
                },
                getOffsetWidthForTabBar: function () {
                    return (_this.scrollFrame && _this.scrollFrame.tabBar) ? _this.scrollFrame.tabBar.elementRef.nativeElement.offsetWidth : 0;
                },
                setTransformStyleForTabBar: function (value) {
                    if (_this.scrollFrame && _this.scrollFrame.tabBar) {
                        _this._renderer.setStyle(_this.scrollFrame.tabBar.elementRef.nativeElement, getCorrectPropertyName$1(window, 'transform'), value);
                    }
                },
                getOffsetLeftForEventTarget: function (target) { return target.offsetLeft; },
                getOffsetWidthForEventTarget: function (target) { return target.offsetWidth; }
            };
            this._foundation = new MDCTabBarScrollerFoundation(this._mdcAdapter);
        }
        /**
         * @return {?}
         */
        MdcTabBarScroller.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this._foundation.init();
        };
        /**
         * @return {?}
         */
        MdcTabBarScroller.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this._tabBarChangeSubscription = this.scrollFrame.tabBar.tabsChangeEvent.subscribe(function () {
                _this.layout();
            });
        };
        /**
         * @return {?}
         */
        MdcTabBarScroller.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this._tabBarChangeSubscription) {
                this._tabBarChangeSubscription.unsubscribe();
                this._tabBarChangeSubscription = null;
            }
            this._foundation.destroy();
        };
        /**
         * @param {?} index
         * @return {?}
         */
        MdcTabBarScroller.prototype.scrollToTabAtIndex = /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            this._foundation.scrollToTabAtIndex(index);
        };
        /**
         * @return {?}
         */
        MdcTabBarScroller.prototype.layout = /**
         * @return {?}
         */
        function () {
            this._foundation.layout();
        };
        /**
         * @param {?=} event
         * @return {?}
         */
        MdcTabBarScroller.prototype.scrollBack = /**
         * @param {?=} event
         * @return {?}
         */
        function (event) {
            this._foundation.scrollBack(event);
        };
        /**
         * @param {?=} event
         * @return {?}
         */
        MdcTabBarScroller.prototype.scrollForward = /**
         * @param {?=} event
         * @return {?}
         */
        function (event) {
            this._foundation.scrollForward(event);
        };
        MdcTabBarScroller.decorators = [
            { type: core.Component, args: [{selector: '[mdc-tab-bar-scroller], mdc-tab-bar-scroller',
                        exportAs: 'mdcTabBarScroller',
                        template: '<ng-content></ng-content>',
                        providers: [EventRegistry],
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcTabBarScroller.ctorParameters = function () { return [
            { type: core.Renderer2 },
            { type: core.ElementRef },
            { type: EventRegistry }
        ]; };
        MdcTabBarScroller.propDecorators = {
            direction: [{ type: core.Input }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-tab-bar-scroller',] }],
            scrollFrame: [{ type: core.ContentChild, args: [MdcTabBarScrollFrame,] }],
            back: [{ type: core.ContentChild, args: [MdcTabBarScrollBack,] }],
            forward: [{ type: core.ContentChild, args: [MdcTabBarScrollForward,] }]
        };
        return MdcTabBarScroller;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ TAB_DECLARATIONS = [
        MdcTab,
        MdcTabIconText,
        MdcTabBar,
        MdcTabBarIndicator,
        MdcTabBarScroller,
        MdcTabBarScrollBack,
        MdcTabBarScrollForward,
        MdcTabBarScrollFrame,
    ];
    var MdcTabModule = /** @class */ (function () {
        function MdcTabModule() {
        }
        MdcTabModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [MdcRouterModule],
                        exports: [
                            MdcRouterModule,
                            TAB_DECLARATIONS
                        ],
                        declarations: [
                            TAB_DECLARATIONS
                        ]
                    },] },
        ];
        return MdcTabModule;
    }());

    function _classCallCheck$m(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$m(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$m(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$m(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$m(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$m(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$m(subClass, superClass);
    }

    function _getPrototypeOf$m(o) {
      _getPrototypeOf$m = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$m(o);
    }

    function _setPrototypeOf$m(o, p) {
      _setPrototypeOf$m = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$m(o, p);
    }

    function _assertThisInitialized$m(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$m(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$m(self);
    }

    function _superPropBase$b(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$m(object);
        if (object === null) break;
      }

      return object;
    }

    function _get$b(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$b = Reflect.get;
      } else {
        _get$b = function _get(target, property, receiver) {
          var base = _superPropBase$b(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get$b(target, property, receiver || target);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @template A
     */
    var MDCFoundation$l =
    /*#__PURE__*/
    function () {
      _createClass$m(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$m(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$m(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$k =
    /*#__PURE__*/
    function () {
      _createClass$m(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$l());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$m(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$m(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2017 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Text Field Helper Text.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the TextField helper text into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCTextFieldHelperTextAdapter =
    /*#__PURE__*/
    function () {
      function MDCTextFieldHelperTextAdapter() {
        _classCallCheck$m(this, MDCTextFieldHelperTextAdapter);
      }

      _createClass$m(MDCTextFieldHelperTextAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the helper text element.
         * @param {string} className
         */
        value: function addClass(className) {}
        /**
         * Removes a class from the helper text element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Returns whether or not the helper text element contains the given class.
         * @param {string} className
         * @return {boolean}
         */

      }, {
        key: "hasClass",
        value: function hasClass(className) {}
        /**
         * Sets an attribute with a given value on the helper text element.
         * @param {string} attr
         * @param {string} value
         */

      }, {
        key: "setAttr",
        value: function setAttr(attr, value) {}
        /**
         * Removes an attribute from the helper text element.
         * @param {string} attr
         */

      }, {
        key: "removeAttr",
        value: function removeAttr(attr) {}
        /**
         * Sets the text content for the helper text element.
         * @param {string} content
         */

      }, {
        key: "setContent",
        value: function setContent(content) {}
      }]);

      return MDCTextFieldHelperTextAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var strings$j = {
      ARIA_HIDDEN: 'aria-hidden',
      ROLE: 'role'
    };
    /** @enum {string} */

    var cssClasses$k = {
      HELPER_TEXT_PERSISTENT: 'mdc-text-field-helper-text--persistent',
      HELPER_TEXT_VALIDATION_MSG: 'mdc-text-field-helper-text--validation-msg'
    };

    /**
     * @extends {MDCFoundation<!MDCTextFieldHelperTextAdapter>}
     * @final
     */

    var MDCTextFieldHelperTextFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$m(MDCTextFieldHelperTextFoundation, _MDCFoundation);

      _createClass$m(MDCTextFieldHelperTextFoundation, null, [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$k;
        }
        /** @return enum {string} */

      }, {
        key: "strings",
        get: function get() {
          return strings$j;
        }
        /**
         * {@see MDCTextFieldHelperTextAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCTextFieldHelperTextAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCTextFieldHelperTextAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              hasClass: function hasClass() {},
              setAttr: function setAttr() {},
              removeAttr: function removeAttr() {},
              setContent: function setContent() {}
            }
          );
        }
        /**
         * @param {!MDCTextFieldHelperTextAdapter} adapter
         */

      }]);

      function MDCTextFieldHelperTextFoundation(adapter) {
        _classCallCheck$m(this, MDCTextFieldHelperTextFoundation);

        return _possibleConstructorReturn$m(this, _getPrototypeOf$m(MDCTextFieldHelperTextFoundation).call(this, Object.assign(MDCTextFieldHelperTextFoundation.defaultAdapter, adapter)));
      }
      /**
       * Sets the content of the helper text field.
       * @param {string} content
       */


      _createClass$m(MDCTextFieldHelperTextFoundation, [{
        key: "setContent",
        value: function setContent(content) {
          this.adapter_.setContent(content);
        }
        /** @param {boolean} isPersistent Sets the persistency of the helper text. */

      }, {
        key: "setPersistent",
        value: function setPersistent(isPersistent) {
          if (isPersistent) {
            this.adapter_.addClass(cssClasses$k.HELPER_TEXT_PERSISTENT);
          } else {
            this.adapter_.removeClass(cssClasses$k.HELPER_TEXT_PERSISTENT);
          }
        }
        /**
         * @param {boolean} isValidation True to make the helper text act as an
         *   error validation message.
         */

      }, {
        key: "setValidation",
        value: function setValidation(isValidation) {
          if (isValidation) {
            this.adapter_.addClass(cssClasses$k.HELPER_TEXT_VALIDATION_MSG);
          } else {
            this.adapter_.removeClass(cssClasses$k.HELPER_TEXT_VALIDATION_MSG);
          }
        }
        /** Makes the helper text visible to the screen reader. */

      }, {
        key: "showToScreenReader",
        value: function showToScreenReader() {
          this.adapter_.removeAttr(strings$j.ARIA_HIDDEN);
        }
        /**
         * Sets the validity of the helper text based on the input validity.
         * @param {boolean} inputIsValid
         */

      }, {
        key: "setValidity",
        value: function setValidity(inputIsValid) {
          var helperTextIsPersistent = this.adapter_.hasClass(cssClasses$k.HELPER_TEXT_PERSISTENT);
          var helperTextIsValidationMsg = this.adapter_.hasClass(cssClasses$k.HELPER_TEXT_VALIDATION_MSG);
          var validationMsgNeedsDisplay = helperTextIsValidationMsg && !inputIsValid;

          if (validationMsgNeedsDisplay) {
            this.adapter_.setAttr(strings$j.ROLE, 'alert');
          } else {
            this.adapter_.removeAttr(strings$j.ROLE);
          }

          if (!helperTextIsPersistent && !validationMsgNeedsDisplay) {
            this.hide_();
          }
        }
        /**
         * Hides the help text from screen readers.
         * @private
         */

      }, {
        key: "hide_",
        value: function hide_() {
          this.adapter_.setAttr(strings$j.ARIA_HIDDEN, 'true');
        }
      }]);

      return MDCTextFieldHelperTextFoundation;
    }(MDCFoundation$l);

    /**
     * @extends {MDCComponent<!MDCTextFieldHelperTextFoundation>}
     * @final
     */

    var MDCTextFieldHelperText =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$m(MDCTextFieldHelperText, _MDCComponent);

      function MDCTextFieldHelperText() {
        _classCallCheck$m(this, MDCTextFieldHelperText);

        return _possibleConstructorReturn$m(this, _getPrototypeOf$m(MDCTextFieldHelperText).apply(this, arguments));
      }

      _createClass$m(MDCTextFieldHelperText, [{
        key: "getDefaultFoundation",

        /**
         * @return {!MDCTextFieldHelperTextFoundation}
         */
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCTextFieldHelperTextFoundation(
          /** @type {!MDCTextFieldHelperTextAdapter} */
          Object.assign({
            addClass: function addClass(className) {
              return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
              return _this.root_.classList.contains(className);
            },
            setAttr: function setAttr(attr, value) {
              return _this.root_.setAttribute(attr, value);
            },
            removeAttr: function removeAttr(attr) {
              return _this.root_.removeAttribute(attr);
            },
            setContent: function setContent(content) {
              _this.root_.textContent = content;
            }
          }));
        }
      }, {
        key: "foundation",

        /**
         * @return {!MDCTextFieldHelperTextFoundation}
         */
        get: function get() {
          return this.foundation_;
        }
      }], [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCTextFieldHelperText}
         */
        value: function attachTo(root) {
          return new MDCTextFieldHelperText(root);
        }
      }]);

      return MDCTextFieldHelperText;
    }(MDCComponent$k);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcTextFieldHelperText = /** @class */ (function () {
        function MdcTextFieldHelperText(elementRef) {
            var _this = this;
            this.elementRef = elementRef;
            this.isHostClass = true;
            this.ariaHidden = 'true';
            this._mdcAdapter = {
                addClass: function (className) { return _this._getHostElement().classList.add(className); },
                removeClass: function (className) { return _this._getHostElement().classList.remove(className); },
                hasClass: function (className) { return _this._getHostElement().classList.contains(className); },
                setAttr: function (attr, value) { return _this._getHostElement().setAttribute(attr, value); },
                removeAttr: function (attr) { return _this._getHostElement().removeAttribute(attr); },
                setContent: function (content) { return _this._getHostElement().textContent = content; }
            };
            this.foundation = new MDCTextFieldHelperTextFoundation(this._mdcAdapter);
        }
        Object.defineProperty(MdcTextFieldHelperText.prototype, "persistent", {
            get: /**
             * @return {?}
             */
            function () { return this._persistent; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setPersistent(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextFieldHelperText.prototype, "validation", {
            get: /**
             * @return {?}
             */
            function () { return this._validation; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setValidation(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextFieldHelperText.prototype, "classPersistent", {
            get: /**
             * @return {?}
             */
            function () {
                return this.persistent ? 'mdc-text-field-helper-text--persistent' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextFieldHelperText.prototype, "classValidation", {
            get: /**
             * @return {?}
             */
            function () {
                return this.validation ? 'mdc-text-field-helper-text--validation-msg' : '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MdcTextFieldHelperText.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.foundation.init();
        };
        /**
         * @return {?}
         */
        MdcTextFieldHelperText.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.foundation.destroy();
        };
        /** Sets the content of the helper text field. */
        /**
         * Sets the content of the helper text field.
         * @param {?} content
         * @return {?}
         */
        MdcTextFieldHelperText.prototype.setContent = /**
         * Sets the content of the helper text field.
         * @param {?} content
         * @return {?}
         */
        function (content) {
            this.foundation.setContent(content);
        };
        /** Sets the validity of the helper text based on the input validity. */
        /**
         * Sets the validity of the helper text based on the input validity.
         * @param {?} validity
         * @return {?}
         */
        MdcTextFieldHelperText.prototype.setValidity = /**
         * Sets the validity of the helper text based on the input validity.
         * @param {?} validity
         * @return {?}
         */
        function (validity) {
            this.foundation.setValidity(validity);
        };
        /** Makes the helper text visible to the screen reader. */
        /**
         * Makes the helper text visible to the screen reader.
         * @return {?}
         */
        MdcTextFieldHelperText.prototype.showToScreenReader = /**
         * Makes the helper text visible to the screen reader.
         * @return {?}
         */
        function () {
            this.foundation.showToScreenReader();
        };
        /** Sets the persistency of the helper text. */
        /**
         * Sets the persistency of the helper text.
         * @param {?} persistent
         * @return {?}
         */
        MdcTextFieldHelperText.prototype.setPersistent = /**
         * Sets the persistency of the helper text.
         * @param {?} persistent
         * @return {?}
         */
        function (persistent) {
            this._persistent = persistent;
            this.foundation.setPersistent(persistent);
        };
        /** True to make the helper text act as an error validation message. */
        /**
         * True to make the helper text act as an error validation message.
         * @param {?} validation
         * @return {?}
         */
        MdcTextFieldHelperText.prototype.setValidation = /**
         * True to make the helper text act as an error validation message.
         * @param {?} validation
         * @return {?}
         */
        function (validation) {
            this._validation = validation;
            this.foundation.setValidation(validation);
        };
        /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        MdcTextFieldHelperText.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcTextFieldHelperText.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcTextFieldHelperText], mdc-text-field-helper-text',
                        exportAs: 'mdcHelperText'
                    },] },
        ];
        /** @nocollapse */
        MdcTextFieldHelperText.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcTextFieldHelperText.propDecorators = {
            id: [{ type: core.Input }],
            persistent: [{ type: core.Input }],
            validation: [{ type: core.Input }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-text-field-helper-text',] }],
            ariaHidden: [{ type: core.HostBinding, args: ['attr.aria-hidden',] }],
            classPersistent: [{ type: core.HostBinding, args: ['class.mdc-text-field-helper-text--persistent',] }],
            classValidation: [{ type: core.HostBinding, args: ['class.mdc-text-field-helper-text--validation-msg',] }]
        };
        return MdcTextFieldHelperText;
    }());

    /**
     * @license
     * Copyright 2017 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Text Field Icon.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the text field icon into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCTextFieldIconAdapter =
    /*#__PURE__*/
    function () {
      function MDCTextFieldIconAdapter() {
        _classCallCheck$m(this, MDCTextFieldIconAdapter);
      }

      _createClass$m(MDCTextFieldIconAdapter, [{
        key: "getAttr",

        /**
         * Gets the value of an attribute on the icon element.
         * @param {string} attr
         * @return {string}
         */
        value: function getAttr(attr) {}
        /**
         * Sets an attribute on the icon element.
         * @param {string} attr
         * @param {string} value
         */

      }, {
        key: "setAttr",
        value: function setAttr(attr, value) {}
        /**
         * Removes an attribute from the icon element.
         * @param {string} attr
         */

      }, {
        key: "removeAttr",
        value: function removeAttr(attr) {}
        /**
         * Sets the text content of the icon element.
         * @param {string} content
         */

      }, {
        key: "setContent",
        value: function setContent(content) {}
        /**
         * Registers an event listener on the icon element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * Deregisters an event listener on the icon element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * Emits a custom event "MDCTextField:icon" denoting a user has clicked the icon.
         */

      }, {
        key: "notifyIconAction",
        value: function notifyIconAction() {}
      }]);

      return MDCTextFieldIconAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var strings$1$c = {
      ICON_EVENT: 'MDCTextField:icon',
      ICON_ROLE: 'button'
    };

    /**
     * @extends {MDCFoundation<!MDCTextFieldIconAdapter>}
     * @final
     */

    var MDCTextFieldIconFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$m(MDCTextFieldIconFoundation, _MDCFoundation);

      _createClass$m(MDCTextFieldIconFoundation, null, [{
        key: "strings",

        /** @return enum {string} */
        get: function get() {
          return strings$1$c;
        }
        /**
         * {@see MDCTextFieldIconAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCTextFieldIconAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCTextFieldIconAdapter} */
            {
              getAttr: function getAttr() {},
              setAttr: function setAttr() {},
              removeAttr: function removeAttr() {},
              setContent: function setContent() {},
              registerInteractionHandler: function registerInteractionHandler() {},
              deregisterInteractionHandler: function deregisterInteractionHandler() {},
              notifyIconAction: function notifyIconAction() {}
            }
          );
        }
        /**
         * @param {!MDCTextFieldIconAdapter} adapter
         */

      }]);

      function MDCTextFieldIconFoundation(adapter) {
        var _this;

        _classCallCheck$m(this, MDCTextFieldIconFoundation);

        _this = _possibleConstructorReturn$m(this, _getPrototypeOf$m(MDCTextFieldIconFoundation).call(this, Object.assign(MDCTextFieldIconFoundation.defaultAdapter, adapter)));
        /** @private {string?} */

        _this.savedTabIndex_ = null;
        /** @private {function(!Event): undefined} */

        _this.interactionHandler_ = function (evt) {
          return _this.handleInteraction(evt);
        };

        return _this;
      }

      _createClass$m(MDCTextFieldIconFoundation, [{
        key: "init",
        value: function init() {
          var _this2 = this;

          this.savedTabIndex_ = this.adapter_.getAttr('tabindex');
          ['click', 'keydown'].forEach(function (evtType) {
            _this2.adapter_.registerInteractionHandler(evtType, _this2.interactionHandler_);
          });
        }
      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          ['click', 'keydown'].forEach(function (evtType) {
            _this3.adapter_.deregisterInteractionHandler(evtType, _this3.interactionHandler_);
          });
        }
        /** @param {boolean} disabled */

      }, {
        key: "setDisabled",
        value: function setDisabled(disabled) {
          if (!this.savedTabIndex_) {
            return;
          }

          if (disabled) {
            this.adapter_.setAttr('tabindex', '-1');
            this.adapter_.removeAttr('role');
          } else {
            this.adapter_.setAttr('tabindex', this.savedTabIndex_);
            this.adapter_.setAttr('role', strings$1$c.ICON_ROLE);
          }
        }
        /** @param {string} label */

      }, {
        key: "setAriaLabel",
        value: function setAriaLabel(label) {
          this.adapter_.setAttr('aria-label', label);
        }
        /** @param {string} content */

      }, {
        key: "setContent",
        value: function setContent(content) {
          this.adapter_.setContent(content);
        }
        /**
         * Handles an interaction event
         * @param {!Event} evt
         */

      }, {
        key: "handleInteraction",
        value: function handleInteraction(evt) {
          if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
            this.adapter_.notifyIconAction();
          }
        }
      }]);

      return MDCTextFieldIconFoundation;
    }(MDCFoundation$l);

    /**
     * @extends {MDCComponent<!MDCTextFieldIconFoundation>}
     * @final
     */

    var MDCTextFieldIcon =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$m(MDCTextFieldIcon, _MDCComponent);

      function MDCTextFieldIcon() {
        _classCallCheck$m(this, MDCTextFieldIcon);

        return _possibleConstructorReturn$m(this, _getPrototypeOf$m(MDCTextFieldIcon).apply(this, arguments));
      }

      _createClass$m(MDCTextFieldIcon, [{
        key: "getDefaultFoundation",

        /**
         * @return {!MDCTextFieldIconFoundation}
         */
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCTextFieldIconFoundation(
          /** @type {!MDCTextFieldIconAdapter} */
          Object.assign({
            getAttr: function getAttr(attr) {
              return _this.root_.getAttribute(attr);
            },
            setAttr: function setAttr(attr, value) {
              return _this.root_.setAttribute(attr, value);
            },
            removeAttr: function removeAttr(attr) {
              return _this.root_.removeAttribute(attr);
            },
            setContent: function setContent(content) {
              _this.root_.textContent = content;
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return _this.root_.addEventListener(evtType, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return _this.root_.removeEventListener(evtType, handler);
            },
            notifyIconAction: function notifyIconAction() {
              return _this.emit(MDCTextFieldIconFoundation.strings.ICON_EVENT, {}
              /* evtData */
              , true
              /* shouldBubble */
              );
            }
          }));
        }
      }, {
        key: "foundation",

        /**
         * @return {!MDCTextFieldIconFoundation}
         */
        get: function get() {
          return this.foundation_;
        }
      }], [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCTextFieldIcon}
         */
        value: function attachTo(root) {
          return new MDCTextFieldIcon(root);
        }
      }]);

      return MDCTextFieldIcon;
    }(MDCComponent$k);

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Ripple. Provides an interface for managing
     * - classes
     * - dom
     * - CSS variables
     * - position
     * - dimensions
     * - scroll position
     * - event handlers
     * - unbounded, active and disabled states
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCRippleAdapter$b =
    /*#__PURE__*/
    function () {
      function MDCRippleAdapter() {
        _classCallCheck$m(this, MDCRippleAdapter);
      }

      _createClass$m(MDCRippleAdapter, [{
        key: "browserSupportsCssVars",

        /** @return {boolean} */
        value: function browserSupportsCssVars() {}
        /** @return {boolean} */

      }, {
        key: "isUnbounded",
        value: function isUnbounded() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceActive",
        value: function isSurfaceActive() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceDisabled",
        value: function isSurfaceDisabled() {}
        /** @param {string} className */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @param {!EventTarget} target */

      }, {
        key: "containsEventTarget",
        value: function containsEventTarget(target) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerDocumentInteractionHandler",
        value: function registerDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterDocumentInteractionHandler",
        value: function deregisterDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /**
         * @param {string} varName
         * @param {?number|string} value
         */

      }, {
        key: "updateCssVariable",
        value: function updateCssVariable(varName, value) {}
        /** @return {!ClientRect} */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}
        /** @return {{x: number, y: number}} */

      }, {
        key: "getWindowPageOffset",
        value: function getWindowPageOffset() {}
      }]);

      return MDCRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var cssClasses$1$c = {
      // Ripple is a special case where the "root" component is really a "mixin" of sorts,
      // given that it's an 'upgrade' to an existing component. That being said it is the root
      // CSS class that all other CSS classes derive from.
      ROOT: 'mdc-ripple-upgraded',
      UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
      BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
      FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
      FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
    };
    var strings$2$4 = {
      VAR_LEFT: '--mdc-ripple-left',
      VAR_TOP: '--mdc-ripple-top',
      VAR_FG_SIZE: '--mdc-ripple-fg-size',
      VAR_FG_SCALE: '--mdc-ripple-fg-scale',
      VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
      VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
    };
    var numbers$e = {
      PADDING: 10,
      INITIAL_ORIGIN_SCALE: 0.6,
      DEACTIVATION_TIMEOUT_MS: 225,
      // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
      FG_DEACTIVATION_MS: 150,
      // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
      TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

    };

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
     * @private {boolean|undefined}
     */
    var supportsCssVariables_$b;
    /**
     * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
     * @private {boolean|undefined}
     */

    var supportsPassive_$c;
    /**
     * @param {!Window} windowObj
     * @return {boolean}
     */

    function detectEdgePseudoVarBug$b(windowObj) {
      // Detect versions of Edge with buggy var() support
      // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
      var document = windowObj.document;
      var node = document.createElement('div');
      node.className = 'mdc-ripple-surface--test-edge-var-bug';
      document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
      // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
      // but Firefox is known to support CSS custom properties correctly.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

      var computedStyle = windowObj.getComputedStyle(node);
      var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
      node.remove();
      return hasPseudoVarBug;
    }
    /**
     * @param {!Window} windowObj
     * @param {boolean=} forceRefresh
     * @return {boolean|undefined}
     */


    function supportsCssVariables$b(windowObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var supportsCssVariables = supportsCssVariables_$b;

      if (typeof supportsCssVariables_$b === 'boolean' && !forceRefresh) {
        return supportsCssVariables;
      }

      var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

      if (!supportsFunctionPresent) {
        return;
      }

      var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
      // See: README section on Safari

      var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

      if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVariables = !detectEdgePseudoVarBug$b(windowObj);
      } else {
        supportsCssVariables = false;
      }

      if (!forceRefresh) {
        supportsCssVariables_$b = supportsCssVariables;
      }

      return supportsCssVariables;
    } //

    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|{passive: boolean}}
     */


    function applyPassive$c() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_$c === undefined || forceRefresh) {
        var isSupported = false;

        try {
          globalObj.document.addEventListener('test', null, {
            get passive() {
              isSupported = true;
            }

          });
        } catch (e) {}

        supportsPassive_$c = isSupported;
      }

      return supportsPassive_$c ? {
        passive: true
      } : false;
    }
    /**
     * @param {!Object} HTMLElementPrototype
     * @return {!Array<string>}
     */


    function getMatchesProperty$b(HTMLElementPrototype) {
      return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(function (p) {
        return p in HTMLElementPrototype;
      }).pop();
    }
    /**
     * @param {!Event} ev
     * @param {{x: number, y: number}} pageOffset
     * @param {!ClientRect} clientRect
     * @return {{x: number, y: number}}
     */


    function getNormalizedEventCoords$b(ev, pageOffset, clientRect) {
      var x = pageOffset.x,
          y = pageOffset.y;
      var documentX = x + clientRect.left;
      var documentY = y + clientRect.top;
      var normalizedX;
      var normalizedY; // Determine touch point relative to the ripple container.

      if (ev.type === 'touchstart') {
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
      } else {
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
      }

      return {
        x: normalizedX,
        y: normalizedY
      };
    }

    var ACTIVATION_EVENT_TYPES$b = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

    var POINTER_DEACTIVATION_EVENT_TYPES$b = ['touchend', 'pointerup', 'mouseup']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

    /** @type {!Array<!EventTarget>} */

    var activatedTargets$b = [];
    /**
     * @extends {MDCFoundation<!MDCRippleAdapter>}
     */

    var MDCRippleFoundation$b =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$m(MDCRippleFoundation, _MDCFoundation);

      _createClass$m(MDCRippleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$1$c;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$2$4;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers$e;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            browserSupportsCssVars: function browserSupportsCssVars()
            /* boolean - cached */
            {},
            isUnbounded: function isUnbounded()
            /* boolean */
            {},
            isSurfaceActive: function isSurfaceActive()
            /* boolean */
            {},
            isSurfaceDisabled: function isSurfaceDisabled()
            /* boolean */
            {},
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            containsEventTarget: function containsEventTarget()
            /* target: !EventTarget */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            updateCssVariable: function updateCssVariable()
            /* varName: string, value: string */
            {},
            computeBoundingRect: function computeBoundingRect()
            /* ClientRect */
            {},
            getWindowPageOffset: function getWindowPageOffset()
            /* {x: number, y: number} */
            {}
          };
        }
      }]);

      function MDCRippleFoundation(adapter) {
        var _this;

        _classCallCheck$m(this, MDCRippleFoundation);

        _this = _possibleConstructorReturn$m(this, _getPrototypeOf$m(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
        /** @private {number} */

        _this.layoutFrame_ = 0;
        /** @private {!ClientRect} */

        _this.frame_ =
        /** @type {!ClientRect} */
        {
          width: 0,
          height: 0
        };
        /** @private {!ActivationStateType} */

        _this.activationState_ = _this.defaultActivationState_();
        /** @private {number} */

        _this.initialSize_ = 0;
        /** @private {number} */

        _this.maxRadius_ = 0;
        /** @private {function(!Event)} */

        _this.activateHandler_ = function (e) {
          return _this.activate_(e);
        };
        /** @private {function(!Event)} */


        _this.deactivateHandler_ = function (e) {
          return _this.deactivate_(e);
        };
        /** @private {function(?Event=)} */


        _this.focusHandler_ = function () {
          return _this.handleFocus();
        };
        /** @private {function(?Event=)} */


        _this.blurHandler_ = function () {
          return _this.handleBlur();
        };
        /** @private {!Function} */


        _this.resizeHandler_ = function () {
          return _this.layout();
        };
        /** @private {{left: number, top:number}} */


        _this.unboundedCoords_ = {
          left: 0,
          top: 0
        };
        /** @private {number} */

        _this.fgScale_ = 0;
        /** @private {number} */

        _this.activationTimer_ = 0;
        /** @private {number} */

        _this.fgDeactivationRemovalTimer_ = 0;
        /** @private {boolean} */

        _this.activationAnimationHasEnded_ = false;
        /** @private {!Function} */

        _this.activationTimerCallback_ = function () {
          _this.activationAnimationHasEnded_ = true;

          _this.runDeactivationUXLogicIfReady_();
        };
        /** @private {?Event} */


        _this.previousActivationEvent_ = null;
        return _this;
      }
      /**
       * We compute this property so that we are not querying information about the client
       * until the point in time where the foundation requests it. This prevents scenarios where
       * client-side feature-detection may happen too early, such as when components are rendered on the server
       * and then initialized at mount time on the client.
       * @return {boolean}
       * @private
       */


      _createClass$m(MDCRippleFoundation, [{
        key: "isSupported_",
        value: function isSupported_() {
          return this.adapter_.browserSupportsCssVars();
        }
        /**
         * @return {!ActivationStateType}
         */

      }, {
        key: "defaultActivationState_",
        value: function defaultActivationState_() {
          return {
            isActivated: false,
            hasDeactivationUXRun: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
            activationEvent: null,
            isProgrammatic: false
          };
        }
        /** @override */

      }, {
        key: "init",
        value: function init() {
          var _this2 = this;

          if (!this.isSupported_()) {
            return;
          }

          this.registerRootHandlers_();
          var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$.ROOT,
              UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
          requestAnimationFrame(function () {
            _this2.adapter_.addClass(ROOT);

            if (_this2.adapter_.isUnbounded()) {
              _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


              _this2.layoutInternal_();
            }
          });
        }
        /** @override */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          if (!this.isSupported_()) {
            return;
          }

          if (this.activationTimer_) {
            clearTimeout(this.activationTimer_);
            this.activationTimer_ = 0;
            var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
            this.adapter_.removeClass(FG_ACTIVATION);
          }

          this.deregisterRootHandlers_();
          this.deregisterDeactivationHandlers_();
          var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$2.ROOT,
              UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
          requestAnimationFrame(function () {
            _this3.adapter_.removeClass(ROOT);

            _this3.adapter_.removeClass(UNBOUNDED);

            _this3.removeCssVars_();
          });
        }
        /** @private */

      }, {
        key: "registerRootHandlers_",
        value: function registerRootHandlers_() {
          var _this4 = this;

          ACTIVATION_EVENT_TYPES$b.forEach(function (type) {
            _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
          });
          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.registerResizeHandler(this.resizeHandler_);
          }
        }
        /**
         * @param {!Event} e
         * @private
         */

      }, {
        key: "registerDeactivationHandlers_",
        value: function registerDeactivationHandlers_(e) {
          var _this5 = this;

          if (e.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
          } else {
            POINTER_DEACTIVATION_EVENT_TYPES$b.forEach(function (type) {
              _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
            });
          }
        }
        /** @private */

      }, {
        key: "deregisterRootHandlers_",
        value: function deregisterRootHandlers_() {
          var _this6 = this;

          ACTIVATION_EVENT_TYPES$b.forEach(function (type) {
            _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
          });
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          }
        }
        /** @private */

      }, {
        key: "deregisterDeactivationHandlers_",
        value: function deregisterDeactivationHandlers_() {
          var _this7 = this;

          this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
          POINTER_DEACTIVATION_EVENT_TYPES$b.forEach(function (type) {
            _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
          });
        }
        /** @private */

      }, {
        key: "removeCssVars_",
        value: function removeCssVars_() {
          var _this8 = this;

          var strings = MDCRippleFoundation.strings;
          Object.keys(strings).forEach(function (k) {
            if (k.indexOf('VAR_') === 0) {
              _this8.adapter_.updateCssVariable(strings[k], null);
            }
          });
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "activate_",
        value: function activate_(e) {
          var _this9 = this;

          if (this.adapter_.isSurfaceDisabled()) {
            return;
          }

          var activationState = this.activationState_;

          if (activationState.isActivated) {
            return;
          } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


          var previousActivationEvent = this.previousActivationEvent_;
          var isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;

          if (isSameInteraction) {
            return;
          }

          activationState.isActivated = true;
          activationState.isProgrammatic = e === null;
          activationState.activationEvent = e;
          activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';
          var hasActivatedChild = e && activatedTargets$b.length > 0 && activatedTargets$b.some(function (target) {
            return _this9.adapter_.containsEventTarget(target);
          });

          if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
          }

          if (e) {
            activatedTargets$b.push(
            /** @type {!EventTarget} */
            e.target);
            this.registerDeactivationHandlers_(e);
          }

          activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

          if (activationState.wasElementMadeActive) {
            this.animateActivation_();
          }

          requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets$b = [];

            if (!activationState.wasElementMadeActive && (e.key === ' ' || e.keyCode === 32)) {
              // If space was pressed, try again within an rAF call to detect :active, because different UAs report
              // active states inconsistently when they're called within event handling code:
              // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
              // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
              // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
              // variable is set within a rAF callback for a submit button interaction (#2241).
              activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

              if (activationState.wasElementMadeActive) {
                _this9.animateActivation_();
              }
            }

            if (!activationState.wasElementMadeActive) {
              // Reset activation state immediately if element was not made active.
              _this9.activationState_ = _this9.defaultActivationState_();
            }
          });
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "checkElementMadeActive_",
        value: function checkElementMadeActive_(e) {
          return e && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
        }
        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: "activate",
        value: function activate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          this.activate_(event);
        }
        /** @private */

      }, {
        key: "animateActivation_",
        value: function animateActivation_() {
          var _this10 = this;

          var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
              VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
              VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
          var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
              FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
              FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
          var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
          this.layoutInternal_();
          var translateStart = '';
          var translateEnd = '';

          if (!this.adapter_.isUnbounded()) {
            var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
                startPoint = _this$getFgTranslatio.startPoint,
                endPoint = _this$getFgTranslatio.endPoint;

            translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
            translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
          }

          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

          clearTimeout(this.activationTimer_);
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.rmBoundedActivationClasses_();
          this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

          this.adapter_.computeBoundingRect();
          this.adapter_.addClass(FG_ACTIVATION);
          this.activationTimer_ = setTimeout(function () {
            return _this10.activationTimerCallback_();
          }, DEACTIVATION_TIMEOUT_MS);
        }
        /**
         * @private
         * @return {{startPoint: PointType, endPoint: PointType}}
         */

      }, {
        key: "getFgTranslationCoordinates_",
        value: function getFgTranslationCoordinates_() {
          var _this$activationState = this.activationState_,
              activationEvent = _this$activationState.activationEvent,
              wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
          var startPoint;

          if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords$b(
            /** @type {!Event} */
            activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
          } else {
            startPoint = {
              x: this.frame_.width / 2,
              y: this.frame_.height / 2
            };
          } // Center the element around the start point.


          startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
          };
          var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
          };
          return {
            startPoint: startPoint,
            endPoint: endPoint
          };
        }
        /** @private */

      }, {
        key: "runDeactivationUXLogicIfReady_",
        value: function runDeactivationUXLogicIfReady_() {
          var _this11 = this;

          // This method is called both when a pointing device is released, and when the activation animation ends.
          // The deactivation animation should only run after both of those occur.
          var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
          var _this$activationState2 = this.activationState_,
              hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
              isActivated = _this$activationState2.isActivated;
          var activationHasEnded = hasDeactivationUXRun || !isActivated;

          if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
              _this11.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers$e.FG_DEACTIVATION_MS);
          }
        }
        /** @private */

      }, {
        key: "rmBoundedActivationClasses_",
        value: function rmBoundedActivationClasses_() {
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
          this.adapter_.removeClass(FG_ACTIVATION);
          this.activationAnimationHasEnded_ = false;
          this.adapter_.computeBoundingRect();
        }
      }, {
        key: "resetActivationState_",
        value: function resetActivationState_() {
          var _this12 = this;

          this.previousActivationEvent_ = this.activationState_.activationEvent;
          this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
          // Store the previous event until it's safe to assume that subsequent events are for new interactions.

          setTimeout(function () {
            return _this12.previousActivationEvent_ = null;
          }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "deactivate_",
        value: function deactivate_(e) {
          var _this13 = this;

          var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

          if (!activationState.isActivated) {
            return;
          }

          var state =
          /** @type {!ActivationStateType} */
          Object.assign({}, activationState);

          if (activationState.isProgrammatic) {
            var evtObject = null;
            requestAnimationFrame(function () {
              return _this13.animateDeactivation_(evtObject, state);
            });
            this.resetActivationState_();
          } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
              _this13.activationState_.hasDeactivationUXRun = true;

              _this13.animateDeactivation_(e, state);

              _this13.resetActivationState_();
            });
          }
        }
        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          this.deactivate_(event);
        }
        /**
         * @param {Event} e
         * @param {!ActivationStateType} options
         * @private
         */

      }, {
        key: "animateDeactivation_",
        value: function animateDeactivation_(e, _ref) {
          var wasActivatedByPointer = _ref.wasActivatedByPointer,
              wasElementMadeActive = _ref.wasElementMadeActive;

          if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this14 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }

          this.layoutFrame_ = requestAnimationFrame(function () {
            _this14.layoutInternal_();

            _this14.layoutFrame_ = 0;
          });
        }
        /** @private */

      }, {
        key: "layoutInternal_",
        value: function layoutInternal_() {
          var _this15 = this;

          this.frame_ = this.adapter_.computeBoundingRect();
          var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
          // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
          // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
          // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
          // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
          // `overflow: hidden`.

          var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
          };

          this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

          this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;
          this.fgScale_ = this.maxRadius_ / this.initialSize_;
          this.updateLayoutCssVars_();
        }
        /** @private */

      }, {
        key: "updateLayoutCssVars_",
        value: function updateLayoutCssVars_() {
          var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
              VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
              VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
              VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
              VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
          this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
          this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

          if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
              left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
              top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };
            this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
            this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
          }
        }
        /** @param {boolean} unbounded */

      }, {
        key: "setUnbounded",
        value: function setUnbounded(unbounded) {
          var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

          if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
          } else {
            this.adapter_.removeClass(UNBOUNDED);
          }
        }
      }, {
        key: "handleFocus",
        value: function handleFocus() {
          var _this16 = this;

          requestAnimationFrame(function () {
            return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }, {
        key: "handleBlur",
        value: function handleBlur() {
          var _this17 = this;

          requestAnimationFrame(function () {
            return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }]);

      return MDCRippleFoundation;
    }(MDCFoundation$l);

    /**
     * @extends MDCComponent<!MDCRippleFoundation>
     */

    var MDCRipple$b =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$m(MDCRipple, _MDCComponent);

      /** @param {...?} args */
      function MDCRipple() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$m(this, MDCRipple);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$m(this, (_getPrototypeOf2 = _getPrototypeOf$m(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {boolean} */

        _this.disabled = false;
        /** @private {boolean} */

        _this.unbounded_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @param {{isUnbounded: (boolean|undefined)}=} options
       * @return {!MDCRipple}
       */


      _createClass$m(MDCRipple, [{
        key: "setUnbounded_",

        /**
         * Closure Compiler throws an access control error when directly accessing a
         * protected or private property inside a getter/setter, like unbounded above.
         * By accessing the protected property inside a method, we solve that problem.
         * That's why this function exists.
         * @private
         */
        value: function setUnbounded_() {
          this.foundation_.setUnbounded(this.unbounded_);
        }
      }, {
        key: "activate",
        value: function activate() {
          this.foundation_.activate();
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
        /**
         * @return {!MDCRippleFoundation}
         * @override
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          return new MDCRippleFoundation$b(MDCRipple.createAdapter(this));
        }
        /** @override */

      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
        }
      }, {
        key: "unbounded",

        /** @return {boolean} */
        get: function get() {
          return this.unbounded_;
        }
        /** @param {boolean} unbounded */
        ,
        set: function set(unbounded) {
          this.unbounded_ = Boolean(unbounded);
          this.setUnbounded_();
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref$isUnbounded = _ref.isUnbounded,
              isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

          var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

          if (isUnbounded !== undefined) {
            ripple.unbounded =
            /** @type {boolean} */
            isUnbounded;
          }

          return ripple;
        }
        /**
         * @param {!RippleCapableSurface} instance
         * @return {!MDCRippleAdapter}
         */

      }, {
        key: "createAdapter",
        value: function createAdapter(instance) {
          var MATCHES = getMatchesProperty$b(HTMLElement.prototype);
          return {
            browserSupportsCssVars: function browserSupportsCssVars() {
              return supportsCssVariables$b(window);
            },
            isUnbounded: function isUnbounded() {
              return instance.unbounded;
            },
            isSurfaceActive: function isSurfaceActive() {
              return instance.root_[MATCHES](':active');
            },
            isSurfaceDisabled: function isSurfaceDisabled() {
              return instance.disabled;
            },
            addClass: function addClass(className) {
              return instance.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return instance.root_.classList.remove(className);
            },
            containsEventTarget: function containsEventTarget(target) {
              return instance.root_.contains(target);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return instance.root_.addEventListener(evtType, handler, applyPassive$c());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return instance.root_.removeEventListener(evtType, handler, applyPassive$c());
            },
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.addEventListener(evtType, handler, applyPassive$c());
            },
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.removeEventListener(evtType, handler, applyPassive$c());
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return instance.root_.style.setProperty(varName, value);
            },
            computeBoundingRect: function computeBoundingRect() {
              return instance.root_.getBoundingClientRect();
            },
            getWindowPageOffset: function getWindowPageOffset() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            }
          };
        }
      }]);

      return MDCRipple;
    }(MDCComponent$k);

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var strings$3$2 = {
      ARIA_CONTROLS: 'aria-controls',
      INPUT_SELECTOR: '.mdc-text-field__input',
      LABEL_SELECTOR: '.mdc-floating-label',
      ICON_SELECTOR: '.mdc-text-field__icon',
      OUTLINE_SELECTOR: '.mdc-notched-outline',
      LINE_RIPPLE_SELECTOR: '.mdc-line-ripple'
    };
    /** @enum {string} */

    var cssClasses$2$4 = {
      ROOT: 'mdc-text-field',
      UPGRADED: 'mdc-text-field--upgraded',
      DISABLED: 'mdc-text-field--disabled',
      DENSE: 'mdc-text-field--dense',
      FOCUSED: 'mdc-text-field--focused',
      INVALID: 'mdc-text-field--invalid',
      BOX: 'mdc-text-field--box',
      OUTLINED: 'mdc-text-field--outlined'
    };
    /** @enum {number} */

    var numbers$1$4 = {
      LABEL_SCALE: 0.75,
      DENSE_LABEL_SCALE: 0.923
    }; // whitelist based off of https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation
    // under section: `Validation-related attributes`

    var VALIDATION_ATTR_WHITELIST = ['pattern', 'min', 'max', 'required', 'step', 'minlength', 'maxlength'];

    /**
     * Adapter for MDC Text Field.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Text Field into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */

    var MDCTextFieldAdapter =
    /*#__PURE__*/
    function () {
      function MDCTextFieldAdapter() {
        _classCallCheck$m(this, MDCTextFieldAdapter);
      }

      _createClass$m(MDCTextFieldAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the root Element.
         * @param {string} className
         */
        value: function addClass(className) {}
        /**
         * Removes a class from the root Element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Returns true if the root element contains the given class name.
         * @param {string} className
         * @return {boolean}
         */

      }, {
        key: "hasClass",
        value: function hasClass(className) {}
        /**
         * Registers an event handler on the root element for a given event.
         * @param {string} type
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerTextFieldInteractionHandler",
        value: function registerTextFieldInteractionHandler(type, handler) {}
        /**
         * Deregisters an event handler on the root element for a given event.
         * @param {string} type
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterTextFieldInteractionHandler",
        value: function deregisterTextFieldInteractionHandler(type, handler) {}
        /**
         * Registers an event listener on the native input element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerInputInteractionHandler",
        value: function registerInputInteractionHandler(evtType, handler) {}
        /**
         * Deregisters an event listener on the native input element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterInputInteractionHandler",
        value: function deregisterInputInteractionHandler(evtType, handler) {}
        /**
         * Registers a validation attribute change listener on the input element.
         * Handler accepts list of attribute names.
         * @param {function(!Array<string>): undefined} handler
         * @return {!MutationObserver}
         */

      }, {
        key: "registerValidationAttributeChangeHandler",
        value: function registerValidationAttributeChangeHandler(handler) {}
        /**
         * Disconnects a validation attribute observer on the input element.
         * @param {!MutationObserver} observer
         */

      }, {
        key: "deregisterValidationAttributeChangeHandler",
        value: function deregisterValidationAttributeChangeHandler(observer) {}
        /**
         * Returns an object representing the native text input element, with a
         * similar API shape. The object returned should include the value, disabled
         * and badInput properties, as well as the checkValidity() function. We never
         * alter the value within our code, however we do update the disabled
         * property, so if you choose to duck-type the return value for this method
         * in your implementation it's important to keep this in mind. Also note that
         * this method can return null, which the foundation will handle gracefully.
         * @return {?Element|?NativeInputType}
         */

      }, {
        key: "getNativeInput",
        value: function getNativeInput() {}
        /**
         * Returns true if the textfield is focused.
         * We achieve this via `document.activeElement === this.root_`.
         * @return {boolean}
         */

      }, {
        key: "isFocused",
        value: function isFocused() {}
        /**
         * Returns true if the direction of the root element is set to RTL.
         * @return {boolean}
         */

      }, {
        key: "isRtl",
        value: function isRtl() {}
        /**
         * Activates the line ripple.
         */

      }, {
        key: "activateLineRipple",
        value: function activateLineRipple() {}
        /**
         * Deactivates the line ripple.
         */

      }, {
        key: "deactivateLineRipple",
        value: function deactivateLineRipple() {}
        /**
         * Sets the transform origin of the line ripple.
         * @param {number} normalizedX
         */

      }, {
        key: "setLineRippleTransformOrigin",
        value: function setLineRippleTransformOrigin(normalizedX) {}
        /**
         * Only implement if label exists.
         * Shakes label if shouldShake is true.
         * @param {boolean} shouldShake
         */

      }, {
        key: "shakeLabel",
        value: function shakeLabel(shouldShake) {}
        /**
         * Only implement if label exists.
         * Floats the label above the input element if shouldFloat is true.
         * @param {boolean} shouldFloat
         */

      }, {
        key: "floatLabel",
        value: function floatLabel(shouldFloat) {}
        /**
         * Returns true if label element exists, false if it doesn't.
         * @return {boolean}
         */

      }, {
        key: "hasLabel",
        value: function hasLabel() {}
        /**
         * Only implement if label exists.
         * Returns width of label in pixels.
         * @return {number}
         */

      }, {
        key: "getLabelWidth",
        value: function getLabelWidth() {}
        /**
         * Returns true if outline element exists, false if it doesn't.
         * @return {boolean}
         */

      }, {
        key: "hasOutline",
        value: function hasOutline() {}
        /**
         * Only implement if outline element exists.
         * Updates SVG Path and outline element based on the
         * label element width and RTL context.
         * @param {number} labelWidth
         * @param {boolean=} isRtl
         */

      }, {
        key: "notchOutline",
        value: function notchOutline(labelWidth, isRtl) {}
        /**
         * Only implement if outline element exists.
         * Closes notch in outline element.
         */

      }, {
        key: "closeOutline",
        value: function closeOutline() {}
      }]);

      return MDCTextFieldAdapter;
    }();

    /**
     * @extends {MDCFoundation<!MDCTextFieldAdapter>}
     * @final
     */

    var MDCTextFieldFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$m(MDCTextFieldFoundation, _MDCFoundation);

      _createClass$m(MDCTextFieldFoundation, [{
        key: "shouldShake",

        /** @return {boolean} */
        get: function get() {
          return !this.isValid() && !this.isFocused_;
        }
        /** @return {boolean} */

      }, {
        key: "shouldFloat",
        get: function get() {
          return this.isFocused_ || !!this.getValue() || this.isBadInput_();
        }
        /**
         * {@see MDCTextFieldAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCTextFieldAdapter}
         */

      }], [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$2$4;
        }
        /** @return enum {string} */

      }, {
        key: "strings",
        get: function get() {
          return strings$3$2;
        }
        /** @return enum {string} */

      }, {
        key: "numbers",
        get: function get() {
          return numbers$1$4;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCTextFieldAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              hasClass: function hasClass() {},
              registerTextFieldInteractionHandler: function registerTextFieldInteractionHandler() {},
              deregisterTextFieldInteractionHandler: function deregisterTextFieldInteractionHandler() {},
              registerInputInteractionHandler: function registerInputInteractionHandler() {},
              deregisterInputInteractionHandler: function deregisterInputInteractionHandler() {},
              registerValidationAttributeChangeHandler: function registerValidationAttributeChangeHandler() {},
              deregisterValidationAttributeChangeHandler: function deregisterValidationAttributeChangeHandler() {},
              getNativeInput: function getNativeInput() {},
              isFocused: function isFocused() {},
              isRtl: function isRtl() {},
              activateLineRipple: function activateLineRipple() {},
              deactivateLineRipple: function deactivateLineRipple() {},
              setLineRippleTransformOrigin: function setLineRippleTransformOrigin() {},
              shakeLabel: function shakeLabel() {},
              floatLabel: function floatLabel() {},
              hasLabel: function hasLabel() {},
              getLabelWidth: function getLabelWidth() {},
              hasOutline: function hasOutline() {},
              notchOutline: function notchOutline() {},
              closeOutline: function closeOutline() {}
            }
          );
        }
        /**
         * @param {!MDCTextFieldAdapter} adapter
         * @param {!FoundationMapType=} foundationMap Map from subcomponent names to their subfoundations.
         */

      }]);

      function MDCTextFieldFoundation(adapter) {
        var _this;

        var foundationMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] :
        /** @type {!FoundationMapType} */
        {};

        _classCallCheck$m(this, MDCTextFieldFoundation);

        _this = _possibleConstructorReturn$m(this, _getPrototypeOf$m(MDCTextFieldFoundation).call(this, Object.assign(MDCTextFieldFoundation.defaultAdapter, adapter)));
        /** @type {!MDCTextFieldHelperTextFoundation|undefined} */

        _this.helperText_ = foundationMap.helperText;
        /** @type {!MDCTextFieldIconFoundation|undefined} */

        _this.icon_ = foundationMap.icon;
        /** @private {boolean} */

        _this.isFocused_ = false;
        /** @private {boolean} */

        _this.receivedUserInput_ = false;
        /** @private {boolean} */

        _this.useCustomValidityChecking_ = false;
        /** @private {boolean} */

        _this.isValid_ = true;
        /** @private {function(): undefined} */

        _this.inputFocusHandler_ = function () {
          return _this.activateFocus();
        };
        /** @private {function(): undefined} */


        _this.inputBlurHandler_ = function () {
          return _this.deactivateFocus();
        };
        /** @private {function(): undefined} */


        _this.inputInputHandler_ = function () {
          return _this.autoCompleteFocus();
        };
        /** @private {function(!Event): undefined} */


        _this.setPointerXOffset_ = function (evt) {
          return _this.setTransformOrigin(evt);
        };
        /** @private {function(!Event): undefined} */


        _this.textFieldInteractionHandler_ = function () {
          return _this.handleTextFieldInteraction();
        };
        /** @private {function(!Array): undefined} */


        _this.validationAttributeChangeHandler_ = function (attributesList) {
          return _this.handleValidationAttributeChange(attributesList);
        };
        /** @private {!MutationObserver} */


        _this.validationObserver_;
        return _this;
      }

      _createClass$m(MDCTextFieldFoundation, [{
        key: "init",
        value: function init() {
          var _this2 = this;

          this.adapter_.addClass(MDCTextFieldFoundation.cssClasses.UPGRADED); // Ensure label does not collide with any pre-filled value.

          if (this.adapter_.hasLabel() && (this.getValue() || this.isBadInput_())) {
            this.adapter_.floatLabel(this.shouldFloat);
            this.notchOutline(this.shouldFloat);
          }

          if (this.adapter_.isFocused()) {
            this.inputFocusHandler_();
          }

          this.adapter_.registerInputInteractionHandler('focus', this.inputFocusHandler_);
          this.adapter_.registerInputInteractionHandler('blur', this.inputBlurHandler_);
          this.adapter_.registerInputInteractionHandler('input', this.inputInputHandler_);
          ['mousedown', 'touchstart'].forEach(function (evtType) {
            _this2.adapter_.registerInputInteractionHandler(evtType, _this2.setPointerXOffset_);
          });
          ['click', 'keydown'].forEach(function (evtType) {
            _this2.adapter_.registerTextFieldInteractionHandler(evtType, _this2.textFieldInteractionHandler_);
          });
          this.validationObserver_ = this.adapter_.registerValidationAttributeChangeHandler(this.validationAttributeChangeHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          this.adapter_.removeClass(MDCTextFieldFoundation.cssClasses.UPGRADED);
          this.adapter_.deregisterInputInteractionHandler('focus', this.inputFocusHandler_);
          this.adapter_.deregisterInputInteractionHandler('blur', this.inputBlurHandler_);
          this.adapter_.deregisterInputInteractionHandler('input', this.inputInputHandler_);
          ['mousedown', 'touchstart'].forEach(function (evtType) {
            _this3.adapter_.deregisterInputInteractionHandler(evtType, _this3.setPointerXOffset_);
          });
          ['click', 'keydown'].forEach(function (evtType) {
            _this3.adapter_.deregisterTextFieldInteractionHandler(evtType, _this3.textFieldInteractionHandler_);
          });
          this.adapter_.deregisterValidationAttributeChangeHandler(this.validationObserver_);
        }
        /**
         * Handles user interactions with the Text Field.
         */

      }, {
        key: "handleTextFieldInteraction",
        value: function handleTextFieldInteraction() {
          if (this.adapter_.getNativeInput().disabled) {
            return;
          }

          this.receivedUserInput_ = true;
        }
        /**
         * Handles validation attribute changes
         * @param {!Array<string>} attributesList
         */

      }, {
        key: "handleValidationAttributeChange",
        value: function handleValidationAttributeChange(attributesList) {
          var _this4 = this;

          attributesList.some(function (attributeName) {
            if (VALIDATION_ATTR_WHITELIST.indexOf(attributeName) > -1) {
              _this4.styleValidity_(true);

              return true;
            }
          });
        }
        /**
         * Opens/closes the notched outline.
         * @param {boolean} openNotch
         */

      }, {
        key: "notchOutline",
        value: function notchOutline(openNotch) {
          if (!this.adapter_.hasOutline() || !this.adapter_.hasLabel()) {
            return;
          }

          if (openNotch) {
            var isDense = this.adapter_.hasClass(cssClasses$2$4.DENSE);
            var labelScale = isDense ? numbers$1$4.DENSE_LABEL_SCALE : numbers$1$4.LABEL_SCALE;
            var labelWidth = this.adapter_.getLabelWidth() * labelScale;
            var isRtl = this.adapter_.isRtl();
            this.adapter_.notchOutline(labelWidth, isRtl);
          } else {
            this.adapter_.closeOutline();
          }
        }
        /**
         * Activates the text field focus state.
         */

      }, {
        key: "activateFocus",
        value: function activateFocus() {
          this.isFocused_ = true;
          this.styleFocused_(this.isFocused_);
          this.adapter_.activateLineRipple();
          this.notchOutline(this.shouldFloat);

          if (this.adapter_.hasLabel()) {
            this.adapter_.shakeLabel(this.shouldShake);
            this.adapter_.floatLabel(this.shouldFloat);
          }

          if (this.helperText_) {
            this.helperText_.showToScreenReader();
          }
        }
        /**
         * Sets the line ripple's transform origin, so that the line ripple activate
         * animation will animate out from the user's click location.
         * @param {!Event} evt
         */

      }, {
        key: "setTransformOrigin",
        value: function setTransformOrigin(evt) {
          var targetClientRect = evt.target.getBoundingClientRect();
          var evtCoords = {
            x: evt.clientX,
            y: evt.clientY
          };
          var normalizedX = evtCoords.x - targetClientRect.left;
          this.adapter_.setLineRippleTransformOrigin(normalizedX);
        }
        /**
         * Activates the Text Field's focus state in cases when the input value
         * changes without user input (e.g. programatically).
         */

      }, {
        key: "autoCompleteFocus",
        value: function autoCompleteFocus() {
          if (!this.receivedUserInput_) {
            this.activateFocus();
          }
        }
        /**
         * Deactivates the Text Field's focus state.
         */

      }, {
        key: "deactivateFocus",
        value: function deactivateFocus() {
          this.isFocused_ = false;
          this.adapter_.deactivateLineRipple();
          var input = this.getNativeInput_();
          var shouldRemoveLabelFloat = !input.value && !this.isBadInput_();
          var isValid = this.isValid();
          this.styleValidity_(isValid);
          this.styleFocused_(this.isFocused_);

          if (this.adapter_.hasLabel()) {
            this.adapter_.shakeLabel(this.shouldShake);
            this.adapter_.floatLabel(this.shouldFloat);
            this.notchOutline(this.shouldFloat);
          }

          if (shouldRemoveLabelFloat) {
            this.receivedUserInput_ = false;
          }
        }
        /**
         * @return {string} The value of the input Element.
         */

      }, {
        key: "getValue",
        value: function getValue() {
          return this.getNativeInput_().value;
        }
        /**
         * @param {string} value The value to set on the input Element.
         */

      }, {
        key: "setValue",
        value: function setValue(value) {
          this.getNativeInput_().value = value;
          var isValid = this.isValid();
          this.styleValidity_(isValid);

          if (this.adapter_.hasLabel()) {
            this.adapter_.shakeLabel(this.shouldShake);
            this.adapter_.floatLabel(this.shouldFloat);
            this.notchOutline(this.shouldFloat);
          }
        }
        /**
         * @return {boolean} If a custom validity is set, returns that value.
         *     Otherwise, returns the result of native validity checks.
         */

      }, {
        key: "isValid",
        value: function isValid() {
          return this.useCustomValidityChecking_ ? this.isValid_ : this.isNativeInputValid_();
        }
        /**
         * @param {boolean} isValid Sets the validity state of the Text Field.
         */

      }, {
        key: "setValid",
        value: function setValid(isValid) {
          this.useCustomValidityChecking_ = true;
          this.isValid_ = isValid; // Retrieve from the getter to ensure correct logic is applied.

          isValid = this.isValid();
          this.styleValidity_(isValid);

          if (this.adapter_.hasLabel()) {
            this.adapter_.shakeLabel(this.shouldShake);
          }
        }
        /**
         * @return {boolean} True if the Text Field is disabled.
         */

      }, {
        key: "isDisabled",
        value: function isDisabled() {
          return this.getNativeInput_().disabled;
        }
        /**
         * @param {boolean} disabled Sets the text-field disabled or enabled.
         */

      }, {
        key: "setDisabled",
        value: function setDisabled(disabled) {
          this.getNativeInput_().disabled = disabled;
          this.styleDisabled_(disabled);
        }
        /**
         * @param {string} content Sets the content of the helper text.
         */

      }, {
        key: "setHelperTextContent",
        value: function setHelperTextContent(content) {
          if (this.helperText_) {
            this.helperText_.setContent(content);
          }
        }
        /**
         * Sets the aria label of the icon.
         * @param {string} label
         */

      }, {
        key: "setIconAriaLabel",
        value: function setIconAriaLabel(label) {
          if (this.icon_) {
            this.icon_.setAriaLabel(label);
          }
        }
        /**
         * Sets the text content of the icon.
         * @param {string} content
         */

      }, {
        key: "setIconContent",
        value: function setIconContent(content) {
          if (this.icon_) {
            this.icon_.setContent(content);
          }
        }
        /**
         * @return {boolean} True if the Text Field input fails in converting the
         *     user-supplied value.
         * @private
         */

      }, {
        key: "isBadInput_",
        value: function isBadInput_() {
          return this.getNativeInput_().validity.badInput;
        }
        /**
         * @return {boolean} The result of native validity checking
         *     (ValidityState.valid).
         */

      }, {
        key: "isNativeInputValid_",
        value: function isNativeInputValid_() {
          return this.getNativeInput_().validity.valid;
        }
        /**
         * Styles the component based on the validity state.
         * @param {boolean} isValid
         * @private
         */

      }, {
        key: "styleValidity_",
        value: function styleValidity_(isValid) {
          var INVALID = MDCTextFieldFoundation.cssClasses.INVALID;

          if (isValid) {
            this.adapter_.removeClass(INVALID);
          } else {
            this.adapter_.addClass(INVALID);
          }

          if (this.helperText_) {
            this.helperText_.setValidity(isValid);
          }
        }
        /**
         * Styles the component based on the focused state.
         * @param {boolean} isFocused
         * @private
         */

      }, {
        key: "styleFocused_",
        value: function styleFocused_(isFocused) {
          var FOCUSED = MDCTextFieldFoundation.cssClasses.FOCUSED;

          if (isFocused) {
            this.adapter_.addClass(FOCUSED);
          } else {
            this.adapter_.removeClass(FOCUSED);
          }
        }
        /**
         * Styles the component based on the disabled state.
         * @param {boolean} isDisabled
         * @private
         */

      }, {
        key: "styleDisabled_",
        value: function styleDisabled_(isDisabled) {
          var _MDCTextFieldFoundati = MDCTextFieldFoundation.cssClasses,
              DISABLED = _MDCTextFieldFoundati.DISABLED,
              INVALID = _MDCTextFieldFoundati.INVALID;

          if (isDisabled) {
            this.adapter_.addClass(DISABLED);
            this.adapter_.removeClass(INVALID);
          } else {
            this.adapter_.removeClass(DISABLED);
          }

          if (this.icon_) {
            this.icon_.setDisabled(isDisabled);
          }
        }
        /**
         * @return {!Element|!NativeInputType} The native text input from the
         * host environment, or a dummy if none exists.
         * @private
         */

      }, {
        key: "getNativeInput_",
        value: function getNativeInput_() {
          return this.adapter_.getNativeInput() ||
          /** @type {!NativeInputType} */
          {
            value: '',
            disabled: false,
            validity: {
              badInput: false,
              valid: true
            }
          };
        }
      }]);

      return MDCTextFieldFoundation;
    }(MDCFoundation$l);

    /**
     * @license
     * Copyright 2018 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC TextField Line Ripple.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the line ripple into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCLineRippleAdapter$2 =
    /*#__PURE__*/
    function () {
      function MDCLineRippleAdapter() {
        _classCallCheck$m(this, MDCLineRippleAdapter);
      }

      _createClass$m(MDCLineRippleAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the line ripple element.
         * @param {string} className
         */
        value: function addClass(className) {}
        /**
         * Removes a class from the line ripple element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * @param {string} className
         * @return {boolean}
         */

      }, {
        key: "hasClass",
        value: function hasClass(className) {}
        /**
         * Sets the style property with propertyName to value on the root element.
         * @param {string} propertyName
         * @param {string} value
         */

      }, {
        key: "setStyle",
        value: function setStyle(propertyName, value) {}
        /**
         * Registers an event listener on the line ripple element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerEventHandler",
        value: function registerEventHandler(evtType, handler) {}
        /**
         * Deregisters an event listener on the line ripple element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterEventHandler",
        value: function deregisterEventHandler(evtType, handler) {}
      }]);

      return MDCLineRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var cssClasses$3$3 = {
      LINE_RIPPLE_ACTIVE: 'mdc-line-ripple--active',
      LINE_RIPPLE_DEACTIVATING: 'mdc-line-ripple--deactivating'
    };

    /**
     * @extends {MDCFoundation<!MDCLineRippleAdapter>}
     * @final
     */

    var MDCLineRippleFoundation$2 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$m(MDCLineRippleFoundation, _MDCFoundation);

      _createClass$m(MDCLineRippleFoundation, null, [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$3$3;
        }
        /**
         * {@see MDCLineRippleAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCLineRippleAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCLineRippleAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              hasClass: function hasClass() {},
              setStyle: function setStyle() {},
              registerEventHandler: function registerEventHandler() {},
              deregisterEventHandler: function deregisterEventHandler() {}
            }
          );
        }
        /**
         * @param {!MDCLineRippleAdapter=} adapter
         */

      }]);

      function MDCLineRippleFoundation() {
        var _this;

        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] :
        /** @type {!MDCLineRippleAdapter} */
        {};

        _classCallCheck$m(this, MDCLineRippleFoundation);

        _this = _possibleConstructorReturn$m(this, _getPrototypeOf$m(MDCLineRippleFoundation).call(this, Object.assign(MDCLineRippleFoundation.defaultAdapter, adapter)));
        /** @private {function(!Event): undefined} */

        _this.transitionEndHandler_ = function (evt) {
          return _this.handleTransitionEnd(evt);
        };

        return _this;
      }

      _createClass$m(MDCLineRippleFoundation, [{
        key: "init",
        value: function init() {
          this.adapter_.registerEventHandler('transitionend', this.transitionEndHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.adapter_.deregisterEventHandler('transitionend', this.transitionEndHandler_);
        }
        /**
         * Activates the line ripple
         */

      }, {
        key: "activate",
        value: function activate() {
          this.adapter_.removeClass(cssClasses$3$3.LINE_RIPPLE_DEACTIVATING);
          this.adapter_.addClass(cssClasses$3$3.LINE_RIPPLE_ACTIVE);
        }
        /**
         * Sets the center of the ripple animation to the given X coordinate.
         * @param {number} xCoordinate
         */

      }, {
        key: "setRippleCenter",
        value: function setRippleCenter(xCoordinate) {
          this.adapter_.setStyle('transform-origin', "".concat(xCoordinate, "px center"));
        }
        /**
         * Deactivates the line ripple
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          this.adapter_.addClass(cssClasses$3$3.LINE_RIPPLE_DEACTIVATING);
        }
        /**
         * Handles a transition end event
         * @param {!Event} evt
         */

      }, {
        key: "handleTransitionEnd",
        value: function handleTransitionEnd(evt) {
          // Wait for the line ripple to be either transparent or opaque
          // before emitting the animation end event
          var isDeactivating = this.adapter_.hasClass(cssClasses$3$3.LINE_RIPPLE_DEACTIVATING);

          if (evt.propertyName === 'opacity') {
            if (isDeactivating) {
              this.adapter_.removeClass(cssClasses$3$3.LINE_RIPPLE_ACTIVE);
              this.adapter_.removeClass(cssClasses$3$3.LINE_RIPPLE_DEACTIVATING);
            }
          }
        }
      }]);

      return MDCLineRippleFoundation;
    }(MDCFoundation$l);

    /**
     * @extends {MDCComponent<!MDCLineRippleFoundation>}
     * @final
     */

    var MDCLineRipple$2 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$m(MDCLineRipple, _MDCComponent);

      function MDCLineRipple() {
        _classCallCheck$m(this, MDCLineRipple);

        return _possibleConstructorReturn$m(this, _getPrototypeOf$m(MDCLineRipple).apply(this, arguments));
      }

      _createClass$m(MDCLineRipple, [{
        key: "activate",

        /**
         * Activates the line ripple
         */
        value: function activate() {
          this.foundation_.activate();
        }
        /**
         * Deactivates the line ripple
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
        /**
         * Sets the transform origin given a user's click location. The `rippleCenter` is the
         * x-coordinate of the middle of the ripple.
         * @param {number} xCoordinate
         */

      }, {
        key: "setRippleCenter",
        value: function setRippleCenter(xCoordinate) {
          this.foundation_.setRippleCenter(xCoordinate);
        }
        /**
         * @return {!MDCLineRippleFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCLineRippleFoundation$2(
          /** @type {!MDCLineRippleAdapter} */
          Object.assign({
            addClass: function addClass(className) {
              return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
              return _this.root_.classList.contains(className);
            },
            setStyle: function setStyle(propertyName, value) {
              return _this.root_.style[propertyName] = value;
            },
            registerEventHandler: function registerEventHandler(evtType, handler) {
              return _this.root_.addEventListener(evtType, handler);
            },
            deregisterEventHandler: function deregisterEventHandler(evtType, handler) {
              return _this.root_.removeEventListener(evtType, handler);
            }
          }));
        }
      }], [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCLineRipple}
         */
        value: function attachTo(root) {
          return new MDCLineRipple(root);
        }
      }]);

      return MDCLineRipple;
    }(MDCComponent$k);

    /**
     * @license
     * Copyright 2017 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Floating Label.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the floating label into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCFloatingLabelAdapter$2 =
    /*#__PURE__*/
    function () {
      function MDCFloatingLabelAdapter() {
        _classCallCheck$m(this, MDCFloatingLabelAdapter);
      }

      _createClass$m(MDCFloatingLabelAdapter, [{
        key: "addClass",

        /**
         * Adds a class to the label element.
         * @param {string} className
         */
        value: function addClass(className) {}
        /**
         * Removes a class from the label element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Returns the width of the label element.
         * @return {number}
         */

      }, {
        key: "getWidth",
        value: function getWidth() {}
        /**
         * Registers an event listener on the root element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * Deregisters an event listener on the root element for a given event.
         * @param {string} evtType
         * @param {function(!Event): undefined} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
      }]);

      return MDCFloatingLabelAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var cssClasses$4$2 = {
      LABEL_FLOAT_ABOVE: 'mdc-floating-label--float-above',
      LABEL_SHAKE: 'mdc-floating-label--shake'
    };

    /**
     * @extends {MDCFoundation<!MDCFloatingLabelAdapter>}
     * @final
     */

    var MDCFloatingLabelFoundation$2 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$m(MDCFloatingLabelFoundation, _MDCFoundation);

      _createClass$m(MDCFloatingLabelFoundation, null, [{
        key: "cssClasses",

        /** @return enum {string} */
        get: function get() {
          return cssClasses$4$2;
        }
        /**
         * {@see MDCFloatingLabelAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCFloatingLabelAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCFloatingLabelAdapter} */
            {
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              getWidth: function getWidth() {},
              registerInteractionHandler: function registerInteractionHandler() {},
              deregisterInteractionHandler: function deregisterInteractionHandler() {}
            }
          );
        }
        /**
         * @param {!MDCFloatingLabelAdapter} adapter
         */

      }]);

      function MDCFloatingLabelFoundation(adapter) {
        var _this;

        _classCallCheck$m(this, MDCFloatingLabelFoundation);

        _this = _possibleConstructorReturn$m(this, _getPrototypeOf$m(MDCFloatingLabelFoundation).call(this, Object.assign(MDCFloatingLabelFoundation.defaultAdapter, adapter)));
        /** @private {function(!Event): undefined} */

        _this.shakeAnimationEndHandler_ = function () {
          return _this.handleShakeAnimationEnd_();
        };

        return _this;
      }

      _createClass$m(MDCFloatingLabelFoundation, [{
        key: "init",
        value: function init() {
          this.adapter_.registerInteractionHandler('animationend', this.shakeAnimationEndHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.adapter_.deregisterInteractionHandler('animationend', this.shakeAnimationEndHandler_);
        }
        /**
         * Returns the width of the label element.
         * @return {number}
         */

      }, {
        key: "getWidth",
        value: function getWidth() {
          return this.adapter_.getWidth();
        }
        /**
         * Styles the label to produce the label shake for errors.
         * @param {boolean} shouldShake adds shake class if true,
         * otherwise removes shake class.
         */

      }, {
        key: "shake",
        value: function shake(shouldShake) {
          var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;

          if (shouldShake) {
            this.adapter_.addClass(LABEL_SHAKE);
          } else {
            this.adapter_.removeClass(LABEL_SHAKE);
          }
        }
        /**
         * Styles the label to float or dock.
         * @param {boolean} shouldFloat adds float class if true, otherwise remove
         * float and shake class to dock label.
         */

      }, {
        key: "float",
        value: function float(shouldFloat) {
          var _MDCFloatingLabelFoun = MDCFloatingLabelFoundation.cssClasses,
              LABEL_FLOAT_ABOVE = _MDCFloatingLabelFoun.LABEL_FLOAT_ABOVE,
              LABEL_SHAKE = _MDCFloatingLabelFoun.LABEL_SHAKE;

          if (shouldFloat) {
            this.adapter_.addClass(LABEL_FLOAT_ABOVE);
          } else {
            this.adapter_.removeClass(LABEL_FLOAT_ABOVE);
            this.adapter_.removeClass(LABEL_SHAKE);
          }
        }
        /**
         * Handles an interaction event on the root element.
         */

      }, {
        key: "handleShakeAnimationEnd_",
        value: function handleShakeAnimationEnd_() {
          var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;
          this.adapter_.removeClass(LABEL_SHAKE);
        }
      }]);

      return MDCFloatingLabelFoundation;
    }(MDCFoundation$l);

    /**
     * @extends {MDCComponent<!MDCFloatingLabelFoundation>}
     * @final
     */

    var MDCFloatingLabel$2 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$m(MDCFloatingLabel, _MDCComponent);

      function MDCFloatingLabel() {
        _classCallCheck$m(this, MDCFloatingLabel);

        return _possibleConstructorReturn$m(this, _getPrototypeOf$m(MDCFloatingLabel).apply(this, arguments));
      }

      _createClass$m(MDCFloatingLabel, [{
        key: "shake",

        /**
         * Styles the label to produce the label shake for errors.
         * @param {boolean} shouldShake styles the label to shake by adding shake class
         * if true, otherwise will stop shaking by removing shake class.
         */
        value: function shake(shouldShake) {
          this.foundation_.shake(shouldShake);
        }
        /**
         * Styles label to float/dock.
         * @param {boolean} shouldFloat styles the label to float by adding float class
         * if true, otherwise docks the label by removing the float class.
         */

      }, {
        key: "float",
        value: function float(shouldFloat) {
          this.foundation_.float(shouldFloat);
        }
        /**
         * @return {number}
         */

      }, {
        key: "getWidth",
        value: function getWidth() {
          return this.foundation_.getWidth();
        }
        /**
         * @return {!MDCFloatingLabelFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCFloatingLabelFoundation$2({
            addClass: function addClass(className) {
              return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this.root_.classList.remove(className);
            },
            getWidth: function getWidth() {
              return _this.root_.offsetWidth;
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return _this.root_.addEventListener(evtType, handler);
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return _this.root_.removeEventListener(evtType, handler);
            }
          });
        }
      }], [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCFloatingLabel}
         */
        value: function attachTo(root) {
          return new MDCFloatingLabel(root);
        }
      }]);

      return MDCFloatingLabel;
    }(MDCComponent$k);

    /**
     * @license
     * Copyright 2017 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Notched Outline.
     *
     * Defines the shape of the adapter expected by the foundation. Implement this
     * adapter to integrate the Notched Outline into your framework. See
     * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
     * for more information.
     *
     * @record
     */
    var MDCNotchedOutlineAdapter$2 =
    /*#__PURE__*/
    function () {
      function MDCNotchedOutlineAdapter() {
        _classCallCheck$m(this, MDCNotchedOutlineAdapter);
      }

      _createClass$m(MDCNotchedOutlineAdapter, [{
        key: "getWidth",

        /**
         * Returns the width of the root element.
         * @return {number}
         */
        value: function getWidth() {}
        /**
         * Returns the height of the root element.
         * @return {number}
         */

      }, {
        key: "getHeight",
        value: function getHeight() {}
        /**
         * Adds a class to the root element.
         * @param {string} className
         */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /**
         * Removes a class from the root element.
         * @param {string} className
         */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /**
         * Sets the "d" attribute of the outline element's SVG path.
         * @param {string} value
         */

      }, {
        key: "setOutlinePathAttr",
        value: function setOutlinePathAttr(value) {}
        /**
         * Returns the idle outline element's computed style value of the given css property `propertyName`.
         * We achieve this via `getComputedStyle(...).getPropertyValue(propertyName)`.
         * @param {string} propertyName
         * @return {string}
         */

      }, {
        key: "getIdleOutlineStyleValue",
        value: function getIdleOutlineStyleValue(propertyName) {}
      }]);

      return MDCNotchedOutlineAdapter;
    }();

    /**
     * @license
     * Copyright 2018 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /** @enum {string} */
    var strings$4$1 = {
      PATH_SELECTOR: '.mdc-notched-outline__path',
      IDLE_OUTLINE_SELECTOR: '.mdc-notched-outline__idle'
    };
    /** @enum {string} */

    var cssClasses$5$1 = {
      OUTLINE_NOTCHED: 'mdc-notched-outline--notched'
    };

    /**
     * @extends {MDCFoundation<!MDCNotchedOutlineAdapter>}
     * @final
     */

    var MDCNotchedOutlineFoundation$2 =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$m(MDCNotchedOutlineFoundation, _MDCFoundation);

      _createClass$m(MDCNotchedOutlineFoundation, null, [{
        key: "strings",

        /** @return enum {string} */
        get: function get() {
          return strings$4$1;
        }
        /** @return enum {string} */

      }, {
        key: "cssClasses",
        get: function get() {
          return cssClasses$5$1;
        }
        /**
         * {@see MDCNotchedOutlineAdapter} for typing information on parameters and return
         * types.
         * @return {!MDCNotchedOutlineAdapter}
         */

      }, {
        key: "defaultAdapter",
        get: function get() {
          return (
            /** @type {!MDCNotchedOutlineAdapter} */
            {
              getWidth: function getWidth() {},
              getHeight: function getHeight() {},
              addClass: function addClass() {},
              removeClass: function removeClass() {},
              setOutlinePathAttr: function setOutlinePathAttr() {},
              getIdleOutlineStyleValue: function getIdleOutlineStyleValue() {}
            }
          );
        }
        /**
         * @param {!MDCNotchedOutlineAdapter} adapter
         */

      }]);

      function MDCNotchedOutlineFoundation(adapter) {
        _classCallCheck$m(this, MDCNotchedOutlineFoundation);

        return _possibleConstructorReturn$m(this, _getPrototypeOf$m(MDCNotchedOutlineFoundation).call(this, Object.assign(MDCNotchedOutlineFoundation.defaultAdapter, adapter)));
      }
      /**
       * Adds the outline notched selector and updates the notch width
       * calculated based off of notchWidth and isRtl.
       * @param {number} notchWidth
       * @param {boolean=} isRtl
       */


      _createClass$m(MDCNotchedOutlineFoundation, [{
        key: "notch",
        value: function notch(notchWidth) {
          var isRtl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;
          this.adapter_.addClass(OUTLINE_NOTCHED);
          this.updateSvgPath_(notchWidth, isRtl);
        }
        /**
         * Removes notched outline selector to close the notch in the outline.
         */

      }, {
        key: "closeNotch",
        value: function closeNotch() {
          var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;
          this.adapter_.removeClass(OUTLINE_NOTCHED);
        }
        /**
         * Updates the SVG path of the focus outline element based on the notchWidth
         * and the RTL context.
         * @param {number} notchWidth
         * @param {boolean=} isRtl
         * @private
         */

      }, {
        key: "updateSvgPath_",
        value: function updateSvgPath_(notchWidth, isRtl) {
          // Fall back to reading a specific corner's style because Firefox doesn't report the style on border-radius.
          var radiusStyleValue = this.adapter_.getIdleOutlineStyleValue('border-radius') || this.adapter_.getIdleOutlineStyleValue('border-top-left-radius');
          var radius = parseFloat(radiusStyleValue);
          var width = this.adapter_.getWidth();
          var height = this.adapter_.getHeight();
          var cornerWidth = radius + 1.2;
          var leadingStrokeLength = Math.abs(11 - cornerWidth);
          var paddedNotchWidth = notchWidth + 8; // The right, bottom, and left sides of the outline follow the same SVG path.

          var pathMiddle = 'a' + radius + ',' + radius + ' 0 0 1 ' + radius + ',' + radius + 'v' + (height - 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + -radius + ',' + radius + 'h' + (-width + 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + -radius + ',' + -radius + 'v' + (-height + 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + radius + ',' + -radius;
          var path;

          if (!isRtl) {
            path = 'M' + (cornerWidth + leadingStrokeLength + paddedNotchWidth) + ',' + 1 + 'h' + (width - 2 * cornerWidth - paddedNotchWidth - leadingStrokeLength) + pathMiddle + 'h' + leadingStrokeLength;
          } else {
            path = 'M' + (width - cornerWidth - leadingStrokeLength) + ',' + 1 + 'h' + leadingStrokeLength + pathMiddle + 'h' + (width - 2 * cornerWidth - paddedNotchWidth - leadingStrokeLength);
          }

          this.adapter_.setOutlinePathAttr(path);
        }
      }]);

      return MDCNotchedOutlineFoundation;
    }(MDCFoundation$l);

    /**
     * @extends {MDCComponent<!MDCNotchedOutlineFoundation>}
     * @final
     */

    var MDCNotchedOutline$2 =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$m(MDCNotchedOutline, _MDCComponent);

      function MDCNotchedOutline() {
        _classCallCheck$m(this, MDCNotchedOutline);

        return _possibleConstructorReturn$m(this, _getPrototypeOf$m(MDCNotchedOutline).apply(this, arguments));
      }

      _createClass$m(MDCNotchedOutline, [{
        key: "notch",

        /**
          * Updates outline selectors and SVG path to open notch.
          * @param {number} notchWidth The notch width in the outline.
          * @param {boolean=} isRtl Determines if outline is rtl. If rtl is true, notch
          * will be right justified in outline path, otherwise left justified.
          */
        value: function notch(notchWidth, isRtl) {
          this.foundation_.notch(notchWidth, isRtl);
        }
        /**
         * Updates the outline selectors to close notch and return it to idle state.
         */

      }, {
        key: "closeNotch",
        value: function closeNotch() {
          this.foundation_.closeNotch();
        }
        /**
         * @return {!MDCNotchedOutlineFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCNotchedOutlineFoundation$2({
            getWidth: function getWidth() {
              return _this.root_.offsetWidth;
            },
            getHeight: function getHeight() {
              return _this.root_.offsetHeight;
            },
            addClass: function addClass(className) {
              return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this.root_.classList.remove(className);
            },
            setOutlinePathAttr: function setOutlinePathAttr(value) {
              var path = _this.root_.querySelector(strings$4$1.PATH_SELECTOR);

              path.setAttribute('d', value);
            },
            getIdleOutlineStyleValue: function getIdleOutlineStyleValue(propertyName) {
              var idleOutlineElement = _this.root_.parentNode.querySelector(strings$4$1.IDLE_OUTLINE_SELECTOR);

              return window.getComputedStyle(idleOutlineElement).getPropertyValue(propertyName);
            }
          });
        }
      }], [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCNotchedOutline}
         */
        value: function attachTo(root) {
          return new MDCNotchedOutline(root);
        }
      }]);

      return MDCNotchedOutline;
    }(MDCComponent$k);

    /* eslint-enable no-unused-vars */

    /**
     * @extends {MDCComponent<!MDCTextFieldFoundation>}
     * @final
     */

    var MDCTextField =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$m(MDCTextField, _MDCComponent);

      /**
       * @param {...?} args
       */
      function MDCTextField() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$m(this, MDCTextField);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$m(this, (_getPrototypeOf2 = _getPrototypeOf$m(MDCTextField)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @private {?Element} */

        _this.input_;
        /** @type {?MDCRipple} */

        _this.ripple;
        /** @private {?MDCLineRipple} */

        _this.lineRipple_;
        /** @private {?MDCTextFieldHelperText} */

        _this.helperText_;
        /** @private {?MDCTextFieldIcon} */

        _this.icon_;
        /** @private {?MDCFloatingLabel} */

        _this.label_;
        /** @private {?MDCNotchedOutline} */

        _this.outline_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @return {!MDCTextField}
       */


      _createClass$m(MDCTextField, [{
        key: "initialize",

        /**
         * @param {(function(!Element): !MDCRipple)=} rippleFactory A function which
         * creates a new MDCRipple.
         * @param {(function(!Element): !MDCLineRipple)=} lineRippleFactory A function which
         * creates a new MDCLineRipple.
         * @param {(function(!Element): !MDCTextFieldHelperText)=} helperTextFactory A function which
         * creates a new MDCTextFieldHelperText.
         * @param {(function(!Element): !MDCTextFieldIcon)=} iconFactory A function which
         * creates a new MDCTextFieldIcon.
         * @param {(function(!Element): !MDCFloatingLabel)=} labelFactory A function which
         * creates a new MDCFloatingLabel.
         * @param {(function(!Element): !MDCNotchedOutline)=} outlineFactory A function which
         * creates a new MDCNotchedOutline.
         */
        value: function initialize() {
          var _this2 = this;

          var rippleFactory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (el, foundation) {
            return new MDCRipple$b(el, foundation);
          };
          var lineRippleFactory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (el) {
            return new MDCLineRipple$2(el);
          };
          var helperTextFactory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (el) {
            return new MDCTextFieldHelperText(el);
          };
          var iconFactory = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (el) {
            return new MDCTextFieldIcon(el);
          };
          var labelFactory = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function (el) {
            return new MDCFloatingLabel$2(el);
          };
          var outlineFactory = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : function (el) {
            return new MDCNotchedOutline$2(el);
          };
          this.input_ = this.root_.querySelector(strings$3$2.INPUT_SELECTOR);
          var labelElement = this.root_.querySelector(strings$3$2.LABEL_SELECTOR);

          if (labelElement) {
            this.label_ = labelFactory(labelElement);
          }

          var lineRippleElement = this.root_.querySelector(strings$3$2.LINE_RIPPLE_SELECTOR);

          if (lineRippleElement) {
            this.lineRipple_ = lineRippleFactory(lineRippleElement);
          }

          var outlineElement = this.root_.querySelector(strings$3$2.OUTLINE_SELECTOR);

          if (outlineElement) {
            this.outline_ = outlineFactory(outlineElement);
          }

          if (this.input_.hasAttribute(strings$3$2.ARIA_CONTROLS)) {
            var helperTextElement = document.getElementById(this.input_.getAttribute(strings$3$2.ARIA_CONTROLS));

            if (helperTextElement) {
              this.helperText_ = helperTextFactory(helperTextElement);
            }
          }

          var iconElement = this.root_.querySelector(strings$3$2.ICON_SELECTOR);

          if (iconElement) {
            this.icon_ = iconFactory(iconElement);
          }

          this.ripple = null;

          if (this.root_.classList.contains(cssClasses$2$4.BOX)) {
            var MATCHES = getMatchesProperty$b(HTMLElement.prototype);
            var adapter = Object.assign(MDCRipple$b.createAdapter(
            /** @type {!RippleCapableSurface} */
            this), {
              isSurfaceActive: function isSurfaceActive() {
                return _this2.input_[MATCHES](':active');
              },
              registerInteractionHandler: function registerInteractionHandler(type, handler) {
                return _this2.input_.addEventListener(type, handler);
              },
              deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
                return _this2.input_.removeEventListener(type, handler);
              }
            });
            var foundation = new MDCRippleFoundation$b(adapter);
            this.ripple = rippleFactory(this.root_, foundation);
          }
        }
      }, {
        key: "destroy",
        value: function destroy() {
          if (this.ripple) {
            this.ripple.destroy();
          }

          if (this.lineRipple_) {
            this.lineRipple_.destroy();
          }

          if (this.helperText_) {
            this.helperText_.destroy();
          }

          if (this.icon_) {
            this.icon_.destroy();
          }

          if (this.label_) {
            this.label_.destroy();
          }

          if (this.outline_) {
            this.outline_.destroy();
          }

          _get$b(_getPrototypeOf$m(MDCTextField.prototype), "destroy", this).call(this);
        }
        /**
         * Initiliazes the Text Field's internal state based on the environment's
         * state.
         */

      }, {
        key: "initialSyncWithDom",
        value: function initialSyncWithDom() {
          this.disabled = this.input_.disabled;
        }
        /**
         * @return {string} The value of the input.
         */

      }, {
        key: "layout",

        /**
         * Recomputes the outline SVG path for the outline element.
         */
        value: function layout() {
          var openNotch = this.foundation_.shouldFloat;
          this.foundation_.notchOutline(openNotch);
        }
        /**
         * @return {!MDCTextFieldFoundation}
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this3 = this;

          return new MDCTextFieldFoundation(
          /** @type {!MDCTextFieldAdapter} */
          Object.assign({
            addClass: function addClass(className) {
              return _this3.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this3.root_.classList.remove(className);
            },
            hasClass: function hasClass(className) {
              return _this3.root_.classList.contains(className);
            },
            registerTextFieldInteractionHandler: function registerTextFieldInteractionHandler(evtType, handler) {
              return _this3.root_.addEventListener(evtType, handler);
            },
            deregisterTextFieldInteractionHandler: function deregisterTextFieldInteractionHandler(evtType, handler) {
              return _this3.root_.removeEventListener(evtType, handler);
            },
            registerValidationAttributeChangeHandler: function registerValidationAttributeChangeHandler(handler) {
              var getAttributesList = function getAttributesList(mutationsList) {
                return mutationsList.map(function (mutation) {
                  return mutation.attributeName;
                });
              };

              var observer = new MutationObserver(function (mutationsList) {
                return handler(getAttributesList(mutationsList));
              });

              var targetNode = _this3.root_.querySelector(strings$3$2.INPUT_SELECTOR);

              var config = {
                attributes: true
              };
              observer.observe(targetNode, config);
              return observer;
            },
            deregisterValidationAttributeChangeHandler: function deregisterValidationAttributeChangeHandler(observer) {
              return observer.disconnect();
            },
            isFocused: function isFocused() {
              return document.activeElement === _this3.root_.querySelector(strings$3$2.INPUT_SELECTOR);
            },
            isRtl: function isRtl() {
              return window.getComputedStyle(_this3.root_).getPropertyValue('direction') === 'rtl';
            }
          }, this.getInputAdapterMethods_(), this.getLabelAdapterMethods_(), this.getLineRippleAdapterMethods_(), this.getOutlineAdapterMethods_()), this.getFoundationMap_());
        }
        /**
         * @return {!{
         *   shakeLabel: function(boolean): undefined,
         *   floatLabel: function(boolean): undefined,
         *   hasLabel: function(): boolean,
         *   getLabelWidth: function(): number,
         * }}
         */

      }, {
        key: "getLabelAdapterMethods_",
        value: function getLabelAdapterMethods_() {
          var _this4 = this;

          return {
            shakeLabel: function shakeLabel(shouldShake) {
              return _this4.label_.shake(shouldShake);
            },
            floatLabel: function floatLabel(shouldFloat) {
              return _this4.label_.float(shouldFloat);
            },
            hasLabel: function hasLabel() {
              return !!_this4.label_;
            },
            getLabelWidth: function getLabelWidth() {
              return _this4.label_.getWidth();
            }
          };
        }
        /**
         * @return {!{
         *   activateLineRipple: function(): undefined,
         *   deactivateLineRipple: function(): undefined,
         *   setLineRippleTransformOrigin: function(number): undefined,
         * }}
         */

      }, {
        key: "getLineRippleAdapterMethods_",
        value: function getLineRippleAdapterMethods_() {
          var _this5 = this;

          return {
            activateLineRipple: function activateLineRipple() {
              if (_this5.lineRipple_) {
                _this5.lineRipple_.activate();
              }
            },
            deactivateLineRipple: function deactivateLineRipple() {
              if (_this5.lineRipple_) {
                _this5.lineRipple_.deactivate();
              }
            },
            setLineRippleTransformOrigin: function setLineRippleTransformOrigin(normalizedX) {
              if (_this5.lineRipple_) {
                _this5.lineRipple_.setRippleCenter(normalizedX);
              }
            }
          };
        }
        /**
         * @return {!{
         *   notchOutline: function(number, boolean): undefined,
         *   hasOutline: function(): boolean,
         * }}
         */

      }, {
        key: "getOutlineAdapterMethods_",
        value: function getOutlineAdapterMethods_() {
          var _this6 = this;

          return {
            notchOutline: function notchOutline(labelWidth, isRtl) {
              return _this6.outline_.notch(labelWidth, isRtl);
            },
            closeOutline: function closeOutline() {
              return _this6.outline_.closeNotch();
            },
            hasOutline: function hasOutline() {
              return !!_this6.outline_;
            }
          };
        }
        /**
         * @return {!{
         *   registerInputInteractionHandler: function(string, function()): undefined,
         *   deregisterInputInteractionHandler: function(string, function()): undefined,
         *   getNativeInput: function(): ?Element,
         * }}
         */

      }, {
        key: "getInputAdapterMethods_",
        value: function getInputAdapterMethods_() {
          var _this7 = this;

          return {
            registerInputInteractionHandler: function registerInputInteractionHandler(evtType, handler) {
              return _this7.input_.addEventListener(evtType, handler);
            },
            deregisterInputInteractionHandler: function deregisterInputInteractionHandler(evtType, handler) {
              return _this7.input_.removeEventListener(evtType, handler);
            },
            getNativeInput: function getNativeInput() {
              return _this7.input_;
            }
          };
        }
        /**
         * Returns a map of all subcomponents to subfoundations.
         * @return {!FoundationMapType}
         */

      }, {
        key: "getFoundationMap_",
        value: function getFoundationMap_() {
          return {
            helperText: this.helperText_ ? this.helperText_.foundation : undefined,
            icon: this.icon_ ? this.icon_.foundation : undefined
          };
        }
      }, {
        key: "value",
        get: function get$$1() {
          return this.foundation_.getValue();
        }
        /**
         * @param {string} value The value to set on the input.
         */
        ,
        set: function set(value) {
          this.foundation_.setValue(value);
        }
        /**
         * @return {boolean} True if the Text Field is disabled.
         */

      }, {
        key: "disabled",
        get: function get$$1() {
          return this.foundation_.isDisabled();
        }
        /**
         * @param {boolean} disabled Sets the Text Field disabled or enabled.
         */
        ,
        set: function set(disabled) {
          this.foundation_.setDisabled(disabled);
        }
        /**
         * @return {boolean} valid True if the Text Field is valid.
         */

      }, {
        key: "valid",
        get: function get$$1() {
          return this.foundation_.isValid();
        }
        /**
         * @param {boolean} valid Sets the Text Field valid or invalid.
         */
        ,
        set: function set(valid) {
          this.foundation_.setValid(valid);
        }
        /**
         * @return {boolean} True if the Text Field is required.
         */

      }, {
        key: "required",
        get: function get$$1() {
          return this.input_.required;
        }
        /**
         * @param {boolean} required Sets the Text Field to required.
         */
        ,
        set: function set(required) {
          this.input_.required = required;
        }
        /**
         * @return {string} The input element's validation pattern.
         */

      }, {
        key: "pattern",
        get: function get$$1() {
          return this.input_.pattern;
        }
        /**
         * @param {string} pattern Sets the input element's validation pattern.
         */
        ,
        set: function set(pattern) {
          this.input_.pattern = pattern;
        }
        /**
         * @return {number} The input element's minLength.
         */

      }, {
        key: "minLength",
        get: function get$$1() {
          return this.input_.minLength;
        }
        /**
         * @param {number} minLength Sets the input element's minLength.
         */
        ,
        set: function set(minLength) {
          this.input_.minLength = minLength;
        }
        /**
         * @return {number} The input element's maxLength.
         */

      }, {
        key: "maxLength",
        get: function get$$1() {
          return this.input_.maxLength;
        }
        /**
         * @param {number} maxLength Sets the input element's maxLength.
         */
        ,
        set: function set(maxLength) {
          // Chrome throws exception if maxLength is set < 0
          if (maxLength < 0) {
            this.input_.removeAttribute('maxLength');
          } else {
            this.input_.maxLength = maxLength;
          }
        }
        /**
         * @return {string} The input element's min.
         */

      }, {
        key: "min",
        get: function get$$1() {
          return this.input_.min;
        }
        /**
         * @param {string} min Sets the input element's min.
         */
        ,
        set: function set(min) {
          this.input_.min = min;
        }
        /**
         * @return {string} The input element's max.
         */

      }, {
        key: "max",
        get: function get$$1() {
          return this.input_.max;
        }
        /**
         * @param {string} max Sets the input element's max.
         */
        ,
        set: function set(max) {
          this.input_.max = max;
        }
        /**
         * @return {string} The input element's step.
         */

      }, {
        key: "step",
        get: function get$$1() {
          return this.input_.step;
        }
        /**
         * @param {string} step Sets the input element's step.
         */
        ,
        set: function set(step) {
          this.input_.step = step;
        }
        /**
         * Sets the helper text element content.
         * @param {string} content
         */

      }, {
        key: "helperTextContent",
        set: function set(content) {
          this.foundation_.setHelperTextContent(content);
        }
        /**
         * Sets the aria label of the icon.
         * @param {string} label
         */

      }, {
        key: "iconAriaLabel",
        set: function set(label) {
          this.foundation_.setIconAriaLabel(label);
        }
        /**
         * Sets the text content of the icon.
         * @param {string} content
         */

      }, {
        key: "iconContent",
        set: function set(content) {
          this.foundation_.setIconContent(content);
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCTextField(root);
        }
      }]);

      return MDCTextField;
    }(MDCComponent$k);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ MDC_TEXTFIELD_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return MdcTextField; }),
        multi: true
    };
    var /** @type {?} */ nextUniqueId$7 = 0;
    var MdcTextField = /** @class */ (function () {
        function MdcTextField(_changeDetectorRef, elementRef, _ripple, _registry) {
            var _this = this;
            this._changeDetectorRef = _changeDetectorRef;
            this.elementRef = elementRef;
            this._ripple = _ripple;
            this._registry = _registry;
            /**
             * Emits whenever the component is destroyed.
             */
            this._destroy = new rxjs.Subject();
            this._uid = "mdc-input-" + nextUniqueId$7++;
            this.tabIndex = 0;
            this.direction = 'ltr';
            this._type = 'text';
            this._box = true;
            this._outline = false;
            this._required = false;
            this._focused = false;
            this.iconAction = new core.EventEmitter();
            this.change = new core.EventEmitter();
            this.blur = new core.EventEmitter();
            this.isHostClass = true;
            this._mdcAdapter = {
                addClass: function (className) { return _this._getHostElement().classList.add(className); },
                removeClass: function (className) { return _this._getHostElement().classList.remove(className); },
                hasClass: function (className) { return _this._getHostElement().classList.contains(className); },
                registerTextFieldInteractionHandler: function (evtType, handler) {
                    return _this._registry.listen(evtType, handler, _this._getInputElement());
                },
                deregisterTextFieldInteractionHandler: function (evtType, handler) {
                    return _this._registry.unlisten(evtType, handler);
                },
                registerInputInteractionHandler: function (evtType, handler) {
                    return _this._registry.listen(evtType, handler, _this._getInputElement());
                },
                deregisterInputInteractionHandler: function (evtType, handler) { return _this._registry.unlisten(evtType, handler); },
                isFocused: function () { return _this._focused; },
                isRtl: function () { return _this.direction === 'rtl'; },
                activateLineRipple: function () {
                    if (_this._lineRipple) {
                        _this._lineRipple.activate();
                    }
                },
                deactivateLineRipple: function () {
                    if (_this._lineRipple) {
                        _this._lineRipple.deactivate();
                    }
                },
                setLineRippleTransformOrigin: function (normalizedX) {
                    if (_this._lineRipple) {
                        _this._lineRipple.setRippleCenter(normalizedX);
                    }
                },
                shakeLabel: function (shouldShake) { return _this._floatingLabel.shake(shouldShake); },
                floatLabel: function (shouldFloat) { return _this._floatingLabel.float(shouldFloat); },
                hasLabel: function () { return !!_this._floatingLabel; },
                getLabelWidth: function () { return _this._floatingLabel.getWidth(); },
                hasOutline: function () { return !!_this._notchedOutline; },
                notchOutline: function (labelWidth, isRtl) { return _this._notchedOutline.notch(labelWidth, isRtl); },
                closeOutline: function () { return _this._notchedOutline.closeNotch(); },
                registerValidationAttributeChangeHandler: function (handler) {
                    var /** @type {?} */ getAttributesList = function (mutationsList) { return mutationsList.map(function (mutation) { return mutation.attributeName; }); };
                    var /** @type {?} */ observer = new MutationObserver(function (mutationsList) { return handler(getAttributesList(mutationsList)); });
                    return observer.observe(_this._getInputElement(), { attributes: true });
                },
                deregisterValidationAttributeChangeHandler: function (observer) {
                    if (observer) {
                        observer.disconnect();
                    }
                },
                getNativeInput: function () { return _this._getInputElement(); }
            };
            this._mdcIconAdapter = {
                getAttr: function (attr) { return _this._icons.first.elementRef.nativeElement.getAttribute(attr); },
                setAttr: function (attr, value) { return _this._icons.first.elementRef.nativeElement.setAttribute(attr, value); },
                removeAttr: function (attr) { return _this._icons.first.elementRef.nativeElement.removeAttribute(attr); },
                setContent: function (content) { return _this._icons.first.elementRef.nativeElement.textContent = content; },
                registerInteractionHandler: function (evtType, handler) {
                    return _this._registry.listen(evtType, handler, _this._icons.first.elementRef.nativeElement);
                },
                deregisterInteractionHandler: function (evtType, handler) { return _this._registry.unlisten(evtType, handler); },
                notifyIconAction: function () { return _this.iconAction.emit(true); }
            };
            this._foundation = new MDCTextFieldFoundation(this._mdcAdapter);
            /**
             * View -> model callback called when value changes
             */
            this._onChange = function () { };
            /**
             * View -> model callback called when text field has been touched
             */
            this._onTouched = function () { };
            // Force setter to be called in case id was not specified.
            this.id = this.id;
        }
        Object.defineProperty(MdcTextField.prototype, "id", {
            get: /**
             * @return {?}
             */
            function () { return this._id; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) { this._id = value || this._uid; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "type", {
            /** Input type of the element. */
            get: /**
             * Input type of the element.
             * @return {?}
             */
            function () { return this._type; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._type = value || 'text';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "box", {
            get: /**
             * @return {?}
             */
            function () { return this._box; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setBox(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "outline", {
            get: /**
             * @return {?}
             */
            function () { return this._outline; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setOutline(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "disabled", {
            get: /**
             * @return {?}
             */
            function () { return this._disabled; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setDisabled(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "required", {
            get: /**
             * @return {?}
             */
            function () { return this._required; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setRequired(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "focused", {
            get: /**
             * @return {?}
             */
            function () { return this._focused; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._focused = toBoolean(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "fullwidth", {
            get: /**
             * @return {?}
             */
            function () { return this._fullwidth; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setFullwidth(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "dense", {
            get: /**
             * @return {?}
             */
            function () { return this._dense; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this.setDense(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "helperText", {
            get: /**
             * @return {?}
             */
            function () { return this._helperText; },
            set: /**
             * @param {?} helperText
             * @return {?}
             */
            function (helperText) {
                this.setHelperText(helperText);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "value", {
            /** The input element's value. */
            get: /**
             * The input element's value.
             * @return {?}
             */
            function () { return this._value; },
            set: /**
             * @param {?} newValue
             * @return {?}
             */
            function (newValue) {
                if (this._value !== newValue) {
                    this.setValue(newValue);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "valid", {
            get: /**
             * @return {?}
             */
            function () {
                return this._useCustomValidity ? this._foundation.isValid() :
                    (/** @type {?} */ (this._getInputElement())).validity.valid;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "empty", {
            /** Whether the control is empty. */
            get: /**
             * Whether the control is empty.
             * @return {?}
             */
            function () {
                return !this._getInputElement().value && !this.isBadInput();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "classBox", {
            get: /**
             * @return {?}
             */
            function () {
                return this.box && !this.isTextarea() && !this.fullwidth ? 'mdc-text-field--box' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "classDense", {
            get: /**
             * @return {?}
             */
            function () {
                return this.dense ? 'mdc-text-field--dense' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "classFullwidth", {
            get: /**
             * @return {?}
             */
            function () {
                return this.fullwidth ? 'mdc-text-field--fullwidth' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "classFocused", {
            get: /**
             * @return {?}
             */
            function () {
                return this._focused ? 'mdc-text-field--focused' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcTextField.prototype, "classOutlined", {
            get: /**
             * @return {?}
             */
            function () {
                return this.outline ? 'mdc-text-field--outlined' : '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns a map of all subcomponents to subfoundations.
         * @return {?}
         */
        MdcTextField.prototype._getFoundationMap = /**
         * Returns a map of all subcomponents to subfoundations.
         * @return {?}
         */
        function () {
            return {
                helperText: this._helperText ? this.helperText.foundation : undefined,
                icon: this._hasIcons() ? this._icons.first.foundation : undefined
            };
        };
        /**
         * @return {?}
         */
        MdcTextField.prototype.ngAfterContentInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this._foundation = new MDCTextFieldFoundation(this._mdcAdapter, this._getFoundationMap());
            this._foundation.init();
            this._icons.changes.pipe(operators.startWith(null), operators.takeUntil(this._destroy)).subscribe(function () {
                Promise.resolve().then(function () {
                    _this._icons.forEach(function (icon) {
                        icon.elementRef.nativeElement.classList.add('mdc-text-field__icon');
                        if (icon.isLeading() || icon.isTrailing()) {
                            _this._iconFoundation = new MDCTextFieldIconFoundation(_this._mdcIconAdapter);
                            icon.foundation = _this._iconFoundation;
                        }
                    });
                    _this.updateIconState();
                });
            });
        };
        /**
         * @return {?}
         */
        MdcTextField.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this._hasIcons()) {
                this._icons.forEach(function (icon) {
                    icon.foundation.destroy();
                });
            }
            this._destroy.next();
            this._destroy.complete();
            this._ripple.destroy();
            this._foundation.destroy();
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MdcTextField.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.setValue(value == null ? '' : value, false);
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcTextField.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        MdcTextField.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this._onTouched = fn;
        };
        /**
         * @param {?} value
         * @return {?}
         */
        MdcTextField.prototype.onInput = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.setValue(value);
        };
        /**
         * @return {?}
         */
        MdcTextField.prototype.onFocus = /**
         * @return {?}
         */
        function () {
            this._focused = true;
        };
        /**
         * @return {?}
         */
        MdcTextField.prototype.onBlur = /**
         * @return {?}
         */
        function () {
            this._focused = false;
            this._onTouched();
            this.blur.emit(this.value);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} value
         * @param {?=} isUserInput
         * @return {?}
         */
        MdcTextField.prototype.setValue = /**
         * @param {?} value
         * @param {?=} isUserInput
         * @return {?}
         */
        function (value, isUserInput) {
            var _this = this;
            if (isUserInput === void 0) { isUserInput = true; }
            this._value = this.type === 'number' ?
                (value === '' ? null : toNumber(value)) : value;
            setTimeout(function () {
                _this._foundation.setValue(_this._value);
                if (isUserInput) {
                    _this._onChange(_this._value);
                }
                if (_this.required && !_this._value) {
                    _this.setRequired(false);
                    setTimeout(function () { return _this.setRequired(true); });
                }
            }, 0);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @return {?}
         */
        MdcTextField.prototype.shouldFloat = /**
         * @return {?}
         */
        function () {
            return this._foundation.shouldFloat;
        };
        /**
         * @return {?}
         */
        MdcTextField.prototype.isDisabled = /**
         * @return {?}
         */
        function () {
            return this._foundation.isDisabled();
        };
        /**
         * @return {?}
         */
        MdcTextField.prototype.isBadInput = /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ validity = this._getInputElement().validity;
            return validity && validity.badInput;
        };
        /**
         * @return {?}
         */
        MdcTextField.prototype.focus = /**
         * @return {?}
         */
        function () {
            if (!this.disabled) {
                this._focused = true;
                this._getInputElement().focus();
            }
        };
        /**
         * @param {?} isValid
         * @return {?}
         */
        MdcTextField.prototype.setValid = /**
         * @param {?} isValid
         * @return {?}
         */
        function (isValid) {
            this._useCustomValidity = true;
            this._foundation.setValid(isValid);
        };
        /** Determines if the component host is a textarea. */
        /**
         * Determines if the component host is a textarea.
         * @return {?}
         */
        MdcTextField.prototype.isTextarea = /**
         * Determines if the component host is a textarea.
         * @return {?}
         */
        function () {
            return this._getHostElement().nodeName.toLowerCase() === 'mdc-textarea';
        };
        /** Sets the text-field required or not. */
        /**
         * Sets the text-field required or not.
         * @param {?} required
         * @return {?}
         */
        MdcTextField.prototype.setRequired = /**
         * Sets the text-field required or not.
         * @param {?} required
         * @return {?}
         */
        function (required) {
            this._required = required;
            this._changeDetectorRef.markForCheck();
        };
        /** Styles the text field as a box text field. */
        /**
         * Styles the text field as a box text field.
         * @param {?} box
         * @return {?}
         */
        MdcTextField.prototype.setBox = /**
         * Styles the text field as a box text field.
         * @param {?} box
         * @return {?}
         */
        function (box) {
            this._box = toBoolean(box);
            if (this._outline && box) {
                this._outline = false;
            }
            this._box ? this._ripple.attachTo(this._getHostElement(), false, this._getInputElement()) :
                this._ripple.destroy();
            this._changeDetectorRef.markForCheck();
        };
        /** Styles the text field as an outlined text field. */
        /**
         * Styles the text field as an outlined text field.
         * @param {?} outline
         * @return {?}
         */
        MdcTextField.prototype.setOutline = /**
         * Styles the text field as an outlined text field.
         * @param {?} outline
         * @return {?}
         */
        function (outline) {
            var _this = this;
            this._outline = toBoolean(outline);
            if (outline && this._box) {
                this._box = false;
            }
            if (this.outline && this.value) {
                setTimeout(function () {
                    _this._foundation.notchOutline(_this.value);
                });
            }
            this._changeDetectorRef.markForCheck();
        };
        /** Styles the text field as a fullwidth text field. */
        /**
         * Styles the text field as a fullwidth text field.
         * @param {?} fullwidth
         * @return {?}
         */
        MdcTextField.prototype.setFullwidth = /**
         * Styles the text field as a fullwidth text field.
         * @param {?} fullwidth
         * @return {?}
         */
        function (fullwidth) {
            this._fullwidth = toBoolean(fullwidth);
            this.placeholder = this.fullwidth ? this.label : '';
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} dense
         * @return {?}
         */
        MdcTextField.prototype.setDense = /**
         * @param {?} dense
         * @return {?}
         */
        function (dense) {
            this._dense = toBoolean(dense);
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} disabled
         * @return {?}
         */
        MdcTextField.prototype.setDisabled = /**
         * @param {?} disabled
         * @return {?}
         */
        function (disabled) {
            this.setDisabledState(disabled);
        };
        /**
         * @param {?} helperText
         * @return {?}
         */
        MdcTextField.prototype.setHelperText = /**
         * @param {?} helperText
         * @return {?}
         */
        function (helperText) {
            this._helperText = helperText;
            this._changeDetectorRef.markForCheck();
        };
        /** True if the Text Field is required. */
        /**
         * True if the Text Field is required.
         * @return {?}
         */
        MdcTextField.prototype.isRequired = /**
         * True if the Text Field is required.
         * @return {?}
         */
        function () {
            return this.required;
        };
        /**
         * @return {?}
         */
        MdcTextField.prototype.selectAll = /**
         * @return {?}
         */
        function () {
            (/** @type {?} */ (this._getInputElement())).select();
        };
        /** The value of the input Element. */
        /**
         * The value of the input Element.
         * @return {?}
         */
        MdcTextField.prototype.getValue = /**
         * The value of the input Element.
         * @return {?}
         */
        function () {
            return this._foundation.getValue();
        };
        /** Deactives the Text Field's focus state. */
        /**
         * Deactives the Text Field's focus state.
         * @return {?}
         */
        MdcTextField.prototype.deactivateFocus = /**
         * Deactives the Text Field's focus state.
         * @return {?}
         */
        function () {
            this._foundation.deactivateFocus();
        };
        /** Activates the text field focus state. */
        /**
         * Activates the text field focus state.
         * @return {?}
         */
        MdcTextField.prototype.activateFocus = /**
         * Activates the text field focus state.
         * @return {?}
         */
        function () {
            this._foundation.activateFocus();
        };
        /** Sets the content of the helper text. */
        /**
         * Sets the content of the helper text.
         * @param {?} content
         * @return {?}
         */
        MdcTextField.prototype.setHelperTextContent = /**
         * Sets the content of the helper text.
         * @param {?} content
         * @return {?}
         */
        function (content) {
            this._foundation.setHelperTextContent(content);
        };
        /**
         * @param {?} label
         * @return {?}
         */
        MdcTextField.prototype.setIconAriaLabel = /**
         * @param {?} label
         * @return {?}
         */
        function (label) {
            this._iconFoundation.setAriaLabel(label);
        };
        /**
         * @param {?} content
         * @return {?}
         */
        MdcTextField.prototype.setIconContent = /**
         * @param {?} content
         * @return {?}
         */
        function (content) {
            this._iconFoundation.setContent(content);
        };
        /**
         * @return {?}
         */
        MdcTextField.prototype.updateIconState = /**
         * @return {?}
         */
        function () {
            if (this.getLeadingIcon()) {
                this._getHostElement().classList.add('mdc-text-field--with-leading-icon');
            }
            else if (this.getTrailingIcon()) {
                this._getHostElement().classList.add('mdc-text-field--with-trailing-icon');
            }
        };
        /**
         * @return {?}
         */
        MdcTextField.prototype.getLeadingIcon = /**
         * @return {?}
         */
        function () {
            return this._icons.find(function (_) { return _.isLeading(); });
        };
        /**
         * @return {?}
         */
        MdcTextField.prototype.getTrailingIcon = /**
         * @return {?}
         */
        function () {
            return this._icons.find(function (_) { return _.isTrailing(); });
        };
        // Implemented as part of ControlValueAccessor.
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        MdcTextField.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
        function (isDisabled) {
            var _this = this;
            this._disabled = isDisabled;
            setTimeout(function () { return _this._foundation.setDisabled(isDisabled); });
            if (this.focused) {
                this.focused = false;
            }
            if (this._hasIcons()) {
                // Reset the clickable state of mdc-icon
                this._icons.first.clickable = this._icons.first.clickable;
            }
            this._changeDetectorRef.markForCheck();
        };
        /**
         * @param {?} className
         * @return {?}
         */
        MdcTextField.prototype.hasClass = /**
         * @param {?} className
         * @return {?}
         */
        function (className) {
            return this._getHostElement().classList.contains(className);
        };
        /**
         * @return {?}
         */
        MdcTextField.prototype._hasIcons = /**
         * @return {?}
         */
        function () {
            return this._icons && this._icons.length > 0;
        };
        /**
         * @return {?}
         */
        MdcTextField.prototype._getInputElement = /**
         * @return {?}
         */
        function () {
            return this._input.nativeElement;
        };
        /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        MdcTextField.prototype._getHostElement = /**
         * Retrieves the DOM element of the component host.
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        };
        MdcTextField.decorators = [
            { type: core.Component, args: [{selector: 'mdc-text-field',
                        exportAs: 'mdcTextField',
                        template: "\n  <ng-content select=\"mdc-icon[leading]\"></ng-content>\n  <input #input class=\"mdc-text-field__input\"\n    [id]=\"id\"\n    [type]=\"type\"\n    [tabindex]=\"tabIndex\"\n    [disabled]=\"disabled\"\n    [attr.placeholder]=\"placeholder\"\n    [attr.maxlength]=\"maxlength\"\n    [required]=\"required\"\n    (focus)=\"onFocus()\"\n    (blur)=\"onBlur()\"\n    (input)=\"onInput($event.target.value)\" />\n    <ng-content></ng-content>\n    <label mdcFloatingLabel [attr.for]=\"id\" *ngIf=\"!placeholder\">{{label}}</label>\n    <mdc-line-ripple *ngIf=\"!outline\"></mdc-line-ripple>\n    <mdc-notched-outline *ngIf=\"outline\"></mdc-notched-outline>\n  ",
                        providers: [
                            MDC_TEXTFIELD_CONTROL_VALUE_ACCESSOR,
                            MdcRipple,
                            EventRegistry
                        ],
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        MdcTextField.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.ElementRef },
            { type: MdcRipple },
            { type: EventRegistry }
        ]; };
        MdcTextField.propDecorators = {
            label: [{ type: core.Input }],
            maxlength: [{ type: core.Input }],
            placeholder: [{ type: core.Input }],
            tabIndex: [{ type: core.Input }],
            direction: [{ type: core.Input }],
            id: [{ type: core.Input }],
            type: [{ type: core.Input }],
            box: [{ type: core.Input }],
            outline: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            required: [{ type: core.Input }],
            focused: [{ type: core.Input }],
            fullwidth: [{ type: core.Input }],
            dense: [{ type: core.Input }],
            helperText: [{ type: core.Input }],
            value: [{ type: core.Input }],
            iconAction: [{ type: core.Output }],
            change: [{ type: core.Output }],
            blur: [{ type: core.Output }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-text-field',] }],
            classBox: [{ type: core.HostBinding, args: ['class.mdc-text-field--box',] }],
            classDense: [{ type: core.HostBinding, args: ['class.mdc-text-field--dense',] }],
            classFullwidth: [{ type: core.HostBinding, args: ['class.mdc-text-field--fullwidth',] }],
            classFocused: [{ type: core.HostBinding, args: ['class.mdc-text-field--focused',] }],
            classOutlined: [{ type: core.HostBinding, args: ['class.mdc-text-field--outlined',] }],
            _input: [{ type: core.ViewChild, args: ['input',] }],
            _floatingLabel: [{ type: core.ViewChild, args: [MdcFloatingLabel,] }],
            _lineRipple: [{ type: core.ViewChild, args: [MdcLineRipple,] }],
            _notchedOutline: [{ type: core.ViewChild, args: [MdcNotchedOutline,] }],
            _icons: [{ type: core.ContentChildren, args: [MdcIcon,] }]
        };
        return MdcTextField;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ MDC_TEXTAREA_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return MdcTextarea; }),
        multi: true
    };
    var MdcTextarea = /** @class */ (function (_super) {
        __extends(MdcTextarea, _super);
        function MdcTextarea() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.isHostClass = true;
            return _this;
        }
        MdcTextarea.decorators = [
            { type: core.Component, args: [{selector: 'mdc-textarea',
                        exportAs: 'mdcTextarea',
                        template: "\n  <textarea #input class=\"mdc-text-field__input\"\n    [id]=\"id\"\n    [rows]=\"rows\"\n    [cols]=\"cols\"\n    [tabindex]=\"tabIndex\"\n    [attr.maxlength]=\"maxlength\"\n    [disabled]=\"disabled\"\n    [required]=\"required\"\n    (blur)=\"onBlur()\"\n    (input)=\"onInput($event.target.value)\"></textarea>\n    <label mdcFloatingLabel [attr.for]=\"id\">{{label}}</label>\n  ",
                        providers: [
                            MDC_TEXTAREA_CONTROL_VALUE_ACCESSOR,
                            MdcRipple,
                            EventRegistry
                        ],
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        MdcTextarea.propDecorators = {
            rows: [{ type: core.Input }],
            cols: [{ type: core.Input }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-text-field--textarea',] }]
        };
        return MdcTextarea;
    }(MdcTextField));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ TEXTFIELD_DECLARATIONS = [
        MdcTextarea,
        MdcTextField,
        MdcTextFieldHelperText,
    ];
    var MdcTextFieldModule = /** @class */ (function () {
        function MdcTextFieldModule() {
        }
        MdcTextFieldModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            MdcLineRippleModule,
                            MdcFloatingLabelModule,
                            MdcNotchedOutlineModule
                        ],
                        exports: TEXTFIELD_DECLARATIONS,
                        declarations: TEXTFIELD_DECLARATIONS,
                    },] },
        ];
        return MdcTextFieldModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcContent = /** @class */ (function () {
        function MdcContent() {
            this.isHostClass = true;
        }
        MdcContent.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-content, [mdc-content]'
                    },] },
        ];
        MdcContent.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-content',] }]
        };
        return MdcContent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcMaterialIcons = /** @class */ (function () {
        function MdcMaterialIcons() {
            this.isHostClass = true;
        }
        MdcMaterialIcons.decorators = [
            { type: core.Directive, args: [{
                        selector: '[materialIcons], [material-icon]'
                    },] },
        ];
        MdcMaterialIcons.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.material-icons',] }]
        };
        return MdcMaterialIcons;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ THEME_DECLARATIONS = [
        MdcContent,
        MdcMaterialIcons,
    ];
    var MdcThemeModule = /** @class */ (function () {
        function MdcThemeModule() {
        }
        MdcThemeModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: THEME_DECLARATIONS,
                        declarations: THEME_DECLARATIONS,
                    },] },
        ];
        return MdcThemeModule;
    }());

    function _classCallCheck$n(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties$n(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass$n(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties$n(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties$n(Constructor, staticProps);
      return Constructor;
    }

    function _inherits$n(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf$n(subClass, superClass);
    }

    function _getPrototypeOf$n(o) {
      _getPrototypeOf$n = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf$n(o);
    }

    function _setPrototypeOf$n(o, p) {
      _setPrototypeOf$n = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf$n(o, p);
    }

    function _assertThisInitialized$n(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn$n(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized$n(self);
    }

    function _superPropBase$c(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf$n(object);
        if (object === null) break;
      }

      return object;
    }

    function _get$c(target, property, receiver) {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get$c = Reflect.get;
      } else {
        _get$c = function _get(target, property, receiver) {
          var base = _superPropBase$c(target, property);

          if (!base) return;
          var desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.get) {
            return desc.get.call(receiver);
          }

          return desc.value;
        };
      }

      return _get$c(target, property, receiver || target);
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @template A
     */
    var MDCFoundation$m =
    /*#__PURE__*/
    function () {
      _createClass$n(MDCFoundation, null, [{
        key: "cssClasses",

        /** @return enum{cssClasses} */
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports every
          // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
          return {};
        }
        /** @return enum{strings} */

      }, {
        key: "strings",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
          return {};
        }
        /** @return enum{numbers} */

      }, {
        key: "numbers",
        get: function get() {
          // Classes extending MDCFoundation should implement this method to return an object which exports all
          // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
          return {};
        }
        /** @return {!Object} */

      }, {
        key: "defaultAdapter",
        get: function get() {
          // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
          // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
          // validation.
          return {};
        }
        /**
         * @param {A=} adapter
         */

      }]);

      function MDCFoundation() {
        var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck$n(this, MDCFoundation);

        /** @protected {!A} */
        this.adapter_ = adapter;
      }

      _createClass$n(MDCFoundation, [{
        key: "init",
        value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
        }
      }, {
        key: "destroy",
        value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        }
      }]);

      return MDCFoundation;
    }();

    /**
     * @template F
     */

    var MDCComponent$l =
    /*#__PURE__*/
    function () {
      _createClass$n(MDCComponent, null, [{
        key: "attachTo",

        /**
         * @param {!Element} root
         * @return {!MDCComponent}
         */
        value: function attachTo(root) {
          // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
          // returns an instantiated component with its root set to that element. Also note that in the cases of
          // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
          // from getDefaultFoundation().
          return new MDCComponent(root, new MDCFoundation$m());
        }
        /**
         * @param {!Element} root
         * @param {F=} foundation
         * @param {...?} args
         */

      }]);

      function MDCComponent(root) {
        var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

        _classCallCheck$n(this, MDCComponent);

        /** @protected {!Element} */
        this.root_ = root;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
        // this.root_ is defined and can be used within the foundation class.

        /** @protected {!F} */

        this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
        this.foundation_.init();
        this.initialSyncWithDOM();
      }

      _createClass$n(MDCComponent, [{
        key: "initialize",
        value: function initialize()
        /* ...args */
        {} // Subclasses can override this to do any additional setup work that would be considered part of a
        // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
        // initialized. Any additional arguments besides root and foundation will be passed in here.

        /**
         * @return {!F} foundation
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          // Subclasses must override this method to return a properly configured foundation class for the
          // component.
          throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
        }
      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
          // object. An example of this would be a form control wrapper that needs to synchronize its internal state
          // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
          // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
        }
      }, {
        key: "destroy",
        value: function destroy() {
          // Subclasses may implement this method to release any resources / deregister any listeners they have
          // attached. An example of this might be deregistering a resize event from the window object.
          this.foundation_.destroy();
        }
        /**
         * Wrapper method to add an event listener to the component's root element. This is most useful when
         * listening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "listen",
        value: function listen(evtType, handler) {
          this.root_.addEventListener(evtType, handler);
        }
        /**
         * Wrapper method to remove an event listener to the component's root element. This is most useful when
         * unlistening for custom events.
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "unlisten",
        value: function unlisten(evtType, handler) {
          this.root_.removeEventListener(evtType, handler);
        }
        /**
         * Fires a cross-browser-compatible custom event from the component root of the given type,
         * with the given data.
         * @param {string} evtType
         * @param {!Object} evtData
         * @param {boolean=} shouldBubble
         */

      }, {
        key: "emit",
        value: function emit(evtType, evtData) {
          var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var evt;

          if (typeof CustomEvent === 'function') {
            evt = new CustomEvent(evtType, {
              detail: evtData,
              bubbles: shouldBubble
            });
          } else {
            evt = document.createEvent('CustomEvent');
            evt.initCustomEvent(evtType, shouldBubble, false, evtData);
          }

          this.root_.dispatchEvent(evt);
        }
      }]);

      return MDCComponent;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /* eslint no-unused-vars: [2, {"args": "none"}] */

    /**
     * Adapter for MDC Ripple. Provides an interface for managing
     * - classes
     * - dom
     * - CSS variables
     * - position
     * - dimensions
     * - scroll position
     * - event handlers
     * - unbounded, active and disabled states
     *
     * Additionally, provides type information for the adapter to the Closure
     * compiler.
     *
     * Implement this adapter for your framework of choice to delegate updates to
     * the component in your framework of choice. See architecture documentation
     * for more details.
     * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
     *
     * @record
     */
    var MDCRippleAdapter$c =
    /*#__PURE__*/
    function () {
      function MDCRippleAdapter() {
        _classCallCheck$n(this, MDCRippleAdapter);
      }

      _createClass$n(MDCRippleAdapter, [{
        key: "browserSupportsCssVars",

        /** @return {boolean} */
        value: function browserSupportsCssVars() {}
        /** @return {boolean} */

      }, {
        key: "isUnbounded",
        value: function isUnbounded() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceActive",
        value: function isSurfaceActive() {}
        /** @return {boolean} */

      }, {
        key: "isSurfaceDisabled",
        value: function isSurfaceDisabled() {}
        /** @param {string} className */

      }, {
        key: "addClass",
        value: function addClass(className) {}
        /** @param {string} className */

      }, {
        key: "removeClass",
        value: function removeClass(className) {}
        /** @param {!EventTarget} target */

      }, {
        key: "containsEventTarget",
        value: function containsEventTarget(target) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerInteractionHandler",
        value: function registerInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterInteractionHandler",
        value: function deregisterInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "registerDocumentInteractionHandler",
        value: function registerDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {string} evtType
         * @param {!Function} handler
         */

      }, {
        key: "deregisterDocumentInteractionHandler",
        value: function deregisterDocumentInteractionHandler(evtType, handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "registerResizeHandler",
        value: function registerResizeHandler(handler) {}
        /**
         * @param {!Function} handler
         */

      }, {
        key: "deregisterResizeHandler",
        value: function deregisterResizeHandler(handler) {}
        /**
         * @param {string} varName
         * @param {?number|string} value
         */

      }, {
        key: "updateCssVariable",
        value: function updateCssVariable(varName, value) {}
        /** @return {!ClientRect} */

      }, {
        key: "computeBoundingRect",
        value: function computeBoundingRect() {}
        /** @return {{x: number, y: number}} */

      }, {
        key: "getWindowPageOffset",
        value: function getWindowPageOffset() {}
      }]);

      return MDCRippleAdapter;
    }();

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var cssClasses$l = {
      // Ripple is a special case where the "root" component is really a "mixin" of sorts,
      // given that it's an 'upgrade' to an existing component. That being said it is the root
      // CSS class that all other CSS classes derive from.
      ROOT: 'mdc-ripple-upgraded',
      UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
      BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
      FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
      FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
    };
    var strings$k = {
      VAR_LEFT: '--mdc-ripple-left',
      VAR_TOP: '--mdc-ripple-top',
      VAR_FG_SIZE: '--mdc-ripple-fg-size',
      VAR_FG_SCALE: '--mdc-ripple-fg-scale',
      VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
      VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
    };
    var numbers$f = {
      PADDING: 10,
      INITIAL_ORIGIN_SCALE: 0.6,
      DEACTIVATION_TIMEOUT_MS: 225,
      // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
      FG_DEACTIVATION_MS: 150,
      // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
      TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

    };

    /**
     * @license
     * Copyright 2016 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
     * @private {boolean|undefined}
     */
    var supportsCssVariables_$c;
    /**
     * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
     * @private {boolean|undefined}
     */

    var supportsPassive_$d;
    /**
     * @param {!Window} windowObj
     * @return {boolean}
     */

    function detectEdgePseudoVarBug$c(windowObj) {
      // Detect versions of Edge with buggy var() support
      // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
      var document = windowObj.document;
      var node = document.createElement('div');
      node.className = 'mdc-ripple-surface--test-edge-var-bug';
      document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
      // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
      // but Firefox is known to support CSS custom properties correctly.
      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

      var computedStyle = windowObj.getComputedStyle(node);
      var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
      node.remove();
      return hasPseudoVarBug;
    }
    /**
     * @param {!Window} windowObj
     * @param {boolean=} forceRefresh
     * @return {boolean|undefined}
     */


    function supportsCssVariables$c(windowObj) {
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var supportsCssVariables = supportsCssVariables_$c;

      if (typeof supportsCssVariables_$c === 'boolean' && !forceRefresh) {
        return supportsCssVariables;
      }

      var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

      if (!supportsFunctionPresent) {
        return;
      }

      var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
      // See: README section on Safari

      var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

      if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
        supportsCssVariables = !detectEdgePseudoVarBug$c(windowObj);
      } else {
        supportsCssVariables = false;
      }

      if (!forceRefresh) {
        supportsCssVariables_$c = supportsCssVariables;
      }

      return supportsCssVariables;
    } //

    /**
     * Determine whether the current browser supports passive event listeners, and if so, use them.
     * @param {!Window=} globalObj
     * @param {boolean=} forceRefresh
     * @return {boolean|{passive: boolean}}
     */


    function applyPassive$d() {
      var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
      var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (supportsPassive_$d === undefined || forceRefresh) {
        var isSupported = false;

        try {
          globalObj.document.addEventListener('test', null, {
            get passive() {
              isSupported = true;
            }

          });
        } catch (e) {}

        supportsPassive_$d = isSupported;
      }

      return supportsPassive_$d ? {
        passive: true
      } : false;
    }
    /**
     * @param {!Object} HTMLElementPrototype
     * @return {!Array<string>}
     */


    function getMatchesProperty$c(HTMLElementPrototype) {
      return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(function (p) {
        return p in HTMLElementPrototype;
      }).pop();
    }
    /**
     * @param {!Event} ev
     * @param {{x: number, y: number}} pageOffset
     * @param {!ClientRect} clientRect
     * @return {{x: number, y: number}}
     */


    function getNormalizedEventCoords$c(ev, pageOffset, clientRect) {
      var x = pageOffset.x,
          y = pageOffset.y;
      var documentX = x + clientRect.left;
      var documentY = y + clientRect.top;
      var normalizedX;
      var normalizedY; // Determine touch point relative to the ripple container.

      if (ev.type === 'touchstart') {
        normalizedX = ev.changedTouches[0].pageX - documentX;
        normalizedY = ev.changedTouches[0].pageY - documentY;
      } else {
        normalizedX = ev.pageX - documentX;
        normalizedY = ev.pageY - documentY;
      }

      return {
        x: normalizedX,
        y: normalizedY
      };
    }

    var ACTIVATION_EVENT_TYPES$c = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

    var POINTER_DEACTIVATION_EVENT_TYPES$c = ['touchend', 'pointerup', 'mouseup']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

    /** @type {!Array<!EventTarget>} */

    var activatedTargets$c = [];
    /**
     * @extends {MDCFoundation<!MDCRippleAdapter>}
     */

    var MDCRippleFoundation$c =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$n(MDCRippleFoundation, _MDCFoundation);

      _createClass$n(MDCRippleFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$l;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$k;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers$f;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            browserSupportsCssVars: function browserSupportsCssVars()
            /* boolean - cached */
            {},
            isUnbounded: function isUnbounded()
            /* boolean */
            {},
            isSurfaceActive: function isSurfaceActive()
            /* boolean */
            {},
            isSurfaceDisabled: function isSurfaceDisabled()
            /* boolean */
            {},
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            containsEventTarget: function containsEventTarget()
            /* target: !EventTarget */
            {},
            registerInteractionHandler: function registerInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
            /* evtType: string, handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            updateCssVariable: function updateCssVariable()
            /* varName: string, value: string */
            {},
            computeBoundingRect: function computeBoundingRect()
            /* ClientRect */
            {},
            getWindowPageOffset: function getWindowPageOffset()
            /* {x: number, y: number} */
            {}
          };
        }
      }]);

      function MDCRippleFoundation(adapter) {
        var _this;

        _classCallCheck$n(this, MDCRippleFoundation);

        _this = _possibleConstructorReturn$n(this, _getPrototypeOf$n(MDCRippleFoundation).call(this, Object.assign(MDCRippleFoundation.defaultAdapter, adapter)));
        /** @private {number} */

        _this.layoutFrame_ = 0;
        /** @private {!ClientRect} */

        _this.frame_ =
        /** @type {!ClientRect} */
        {
          width: 0,
          height: 0
        };
        /** @private {!ActivationStateType} */

        _this.activationState_ = _this.defaultActivationState_();
        /** @private {number} */

        _this.initialSize_ = 0;
        /** @private {number} */

        _this.maxRadius_ = 0;
        /** @private {function(!Event)} */

        _this.activateHandler_ = function (e) {
          return _this.activate_(e);
        };
        /** @private {function(!Event)} */


        _this.deactivateHandler_ = function (e) {
          return _this.deactivate_(e);
        };
        /** @private {function(?Event=)} */


        _this.focusHandler_ = function () {
          return _this.handleFocus();
        };
        /** @private {function(?Event=)} */


        _this.blurHandler_ = function () {
          return _this.handleBlur();
        };
        /** @private {!Function} */


        _this.resizeHandler_ = function () {
          return _this.layout();
        };
        /** @private {{left: number, top:number}} */


        _this.unboundedCoords_ = {
          left: 0,
          top: 0
        };
        /** @private {number} */

        _this.fgScale_ = 0;
        /** @private {number} */

        _this.activationTimer_ = 0;
        /** @private {number} */

        _this.fgDeactivationRemovalTimer_ = 0;
        /** @private {boolean} */

        _this.activationAnimationHasEnded_ = false;
        /** @private {!Function} */

        _this.activationTimerCallback_ = function () {
          _this.activationAnimationHasEnded_ = true;

          _this.runDeactivationUXLogicIfReady_();
        };
        /** @private {?Event} */


        _this.previousActivationEvent_ = null;
        return _this;
      }
      /**
       * We compute this property so that we are not querying information about the client
       * until the point in time where the foundation requests it. This prevents scenarios where
       * client-side feature-detection may happen too early, such as when components are rendered on the server
       * and then initialized at mount time on the client.
       * @return {boolean}
       * @private
       */


      _createClass$n(MDCRippleFoundation, [{
        key: "isSupported_",
        value: function isSupported_() {
          return this.adapter_.browserSupportsCssVars();
        }
        /**
         * @return {!ActivationStateType}
         */

      }, {
        key: "defaultActivationState_",
        value: function defaultActivationState_() {
          return {
            isActivated: false,
            hasDeactivationUXRun: false,
            wasActivatedByPointer: false,
            wasElementMadeActive: false,
            activationEvent: null,
            isProgrammatic: false
          };
        }
        /** @override */

      }, {
        key: "init",
        value: function init() {
          var _this2 = this;

          if (!this.isSupported_()) {
            return;
          }

          this.registerRootHandlers_();
          var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$.ROOT,
              UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
          requestAnimationFrame(function () {
            _this2.adapter_.addClass(ROOT);

            if (_this2.adapter_.isUnbounded()) {
              _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


              _this2.layoutInternal_();
            }
          });
        }
        /** @override */

      }, {
        key: "destroy",
        value: function destroy() {
          var _this3 = this;

          if (!this.isSupported_()) {
            return;
          }

          if (this.activationTimer_) {
            clearTimeout(this.activationTimer_);
            this.activationTimer_ = 0;
            var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
            this.adapter_.removeClass(FG_ACTIVATION);
          }

          this.deregisterRootHandlers_();
          this.deregisterDeactivationHandlers_();
          var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$2.ROOT,
              UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
          requestAnimationFrame(function () {
            _this3.adapter_.removeClass(ROOT);

            _this3.adapter_.removeClass(UNBOUNDED);

            _this3.removeCssVars_();
          });
        }
        /** @private */

      }, {
        key: "registerRootHandlers_",
        value: function registerRootHandlers_() {
          var _this4 = this;

          ACTIVATION_EVENT_TYPES$c.forEach(function (type) {
            _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
          });
          this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
          this.adapter_.registerInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.registerResizeHandler(this.resizeHandler_);
          }
        }
        /**
         * @param {!Event} e
         * @private
         */

      }, {
        key: "registerDeactivationHandlers_",
        value: function registerDeactivationHandlers_(e) {
          var _this5 = this;

          if (e.type === 'keydown') {
            this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
          } else {
            POINTER_DEACTIVATION_EVENT_TYPES$c.forEach(function (type) {
              _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
            });
          }
        }
        /** @private */

      }, {
        key: "deregisterRootHandlers_",
        value: function deregisterRootHandlers_() {
          var _this6 = this;

          ACTIVATION_EVENT_TYPES$c.forEach(function (type) {
            _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
          });
          this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
          this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

          if (this.adapter_.isUnbounded()) {
            this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          }
        }
        /** @private */

      }, {
        key: "deregisterDeactivationHandlers_",
        value: function deregisterDeactivationHandlers_() {
          var _this7 = this;

          this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
          POINTER_DEACTIVATION_EVENT_TYPES$c.forEach(function (type) {
            _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
          });
        }
        /** @private */

      }, {
        key: "removeCssVars_",
        value: function removeCssVars_() {
          var _this8 = this;

          var strings$$1 = MDCRippleFoundation.strings;
          Object.keys(strings$$1).forEach(function (k) {
            if (k.indexOf('VAR_') === 0) {
              _this8.adapter_.updateCssVariable(strings$$1[k], null);
            }
          });
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "activate_",
        value: function activate_(e) {
          var _this9 = this;

          if (this.adapter_.isSurfaceDisabled()) {
            return;
          }

          var activationState = this.activationState_;

          if (activationState.isActivated) {
            return;
          } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


          var previousActivationEvent = this.previousActivationEvent_;
          var isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;

          if (isSameInteraction) {
            return;
          }

          activationState.isActivated = true;
          activationState.isProgrammatic = e === null;
          activationState.activationEvent = e;
          activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';
          var hasActivatedChild = e && activatedTargets$c.length > 0 && activatedTargets$c.some(function (target) {
            return _this9.adapter_.containsEventTarget(target);
          });

          if (hasActivatedChild) {
            // Immediately reset activation state, while preserving logic that prevents touch follow-on events
            this.resetActivationState_();
            return;
          }

          if (e) {
            activatedTargets$c.push(
            /** @type {!EventTarget} */
            e.target);
            this.registerDeactivationHandlers_(e);
          }

          activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

          if (activationState.wasElementMadeActive) {
            this.animateActivation_();
          }

          requestAnimationFrame(function () {
            // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
            activatedTargets$c = [];

            if (!activationState.wasElementMadeActive && (e.key === ' ' || e.keyCode === 32)) {
              // If space was pressed, try again within an rAF call to detect :active, because different UAs report
              // active states inconsistently when they're called within event handling code:
              // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
              // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
              // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
              // variable is set within a rAF callback for a submit button interaction (#2241).
              activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

              if (activationState.wasElementMadeActive) {
                _this9.animateActivation_();
              }
            }

            if (!activationState.wasElementMadeActive) {
              // Reset activation state immediately if element was not made active.
              _this9.activationState_ = _this9.defaultActivationState_();
            }
          });
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "checkElementMadeActive_",
        value: function checkElementMadeActive_(e) {
          return e && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
        }
        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: "activate",
        value: function activate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          this.activate_(event);
        }
        /** @private */

      }, {
        key: "animateActivation_",
        value: function animateActivation_() {
          var _this10 = this;

          var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
              VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
              VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
          var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
              FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
              FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
          var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
          this.layoutInternal_();
          var translateStart = '';
          var translateEnd = '';

          if (!this.adapter_.isUnbounded()) {
            var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
                startPoint = _this$getFgTranslatio.startPoint,
                endPoint = _this$getFgTranslatio.endPoint;

            translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
            translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
          }

          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
          this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

          clearTimeout(this.activationTimer_);
          clearTimeout(this.fgDeactivationRemovalTimer_);
          this.rmBoundedActivationClasses_();
          this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

          this.adapter_.computeBoundingRect();
          this.adapter_.addClass(FG_ACTIVATION);
          this.activationTimer_ = setTimeout(function () {
            return _this10.activationTimerCallback_();
          }, DEACTIVATION_TIMEOUT_MS);
        }
        /**
         * @private
         * @return {{startPoint: PointType, endPoint: PointType}}
         */

      }, {
        key: "getFgTranslationCoordinates_",
        value: function getFgTranslationCoordinates_() {
          var _this$activationState = this.activationState_,
              activationEvent = _this$activationState.activationEvent,
              wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
          var startPoint;

          if (wasActivatedByPointer) {
            startPoint = getNormalizedEventCoords$c(
            /** @type {!Event} */
            activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
          } else {
            startPoint = {
              x: this.frame_.width / 2,
              y: this.frame_.height / 2
            };
          } // Center the element around the start point.


          startPoint = {
            x: startPoint.x - this.initialSize_ / 2,
            y: startPoint.y - this.initialSize_ / 2
          };
          var endPoint = {
            x: this.frame_.width / 2 - this.initialSize_ / 2,
            y: this.frame_.height / 2 - this.initialSize_ / 2
          };
          return {
            startPoint: startPoint,
            endPoint: endPoint
          };
        }
        /** @private */

      }, {
        key: "runDeactivationUXLogicIfReady_",
        value: function runDeactivationUXLogicIfReady_() {
          var _this11 = this;

          // This method is called both when a pointing device is released, and when the activation animation ends.
          // The deactivation animation should only run after both of those occur.
          var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
          var _this$activationState2 = this.activationState_,
              hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
              isActivated = _this$activationState2.isActivated;
          var activationHasEnded = hasDeactivationUXRun || !isActivated;

          if (activationHasEnded && this.activationAnimationHasEnded_) {
            this.rmBoundedActivationClasses_();
            this.adapter_.addClass(FG_DEACTIVATION);
            this.fgDeactivationRemovalTimer_ = setTimeout(function () {
              _this11.adapter_.removeClass(FG_DEACTIVATION);
            }, numbers$f.FG_DEACTIVATION_MS);
          }
        }
        /** @private */

      }, {
        key: "rmBoundedActivationClasses_",
        value: function rmBoundedActivationClasses_() {
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
          this.adapter_.removeClass(FG_ACTIVATION);
          this.activationAnimationHasEnded_ = false;
          this.adapter_.computeBoundingRect();
        }
      }, {
        key: "resetActivationState_",
        value: function resetActivationState_() {
          var _this12 = this;

          this.previousActivationEvent_ = this.activationState_.activationEvent;
          this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
          // Store the previous event until it's safe to assume that subsequent events are for new interactions.

          setTimeout(function () {
            return _this12.previousActivationEvent_ = null;
          }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        }
        /**
         * @param {?Event} e
         * @private
         */

      }, {
        key: "deactivate_",
        value: function deactivate_(e) {
          var _this13 = this;

          var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

          if (!activationState.isActivated) {
            return;
          }

          var state =
          /** @type {!ActivationStateType} */
          Object.assign({}, activationState);

          if (activationState.isProgrammatic) {
            var evtObject = null;
            requestAnimationFrame(function () {
              return _this13.animateDeactivation_(evtObject, state);
            });
            this.resetActivationState_();
          } else {
            this.deregisterDeactivationHandlers_();
            requestAnimationFrame(function () {
              _this13.activationState_.hasDeactivationUXRun = true;

              _this13.animateDeactivation_(e, state);

              _this13.resetActivationState_();
            });
          }
        }
        /**
         * @param {?Event=} event Optional event containing position information.
         */

      }, {
        key: "deactivate",
        value: function deactivate() {
          var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
          this.deactivate_(event);
        }
        /**
         * @param {Event} e
         * @param {!ActivationStateType} options
         * @private
         */

      }, {
        key: "animateDeactivation_",
        value: function animateDeactivation_(e, _ref) {
          var wasActivatedByPointer = _ref.wasActivatedByPointer,
              wasElementMadeActive = _ref.wasElementMadeActive;

          if (wasActivatedByPointer || wasElementMadeActive) {
            this.runDeactivationUXLogicIfReady_();
          }
        }
      }, {
        key: "layout",
        value: function layout() {
          var _this14 = this;

          if (this.layoutFrame_) {
            cancelAnimationFrame(this.layoutFrame_);
          }

          this.layoutFrame_ = requestAnimationFrame(function () {
            _this14.layoutInternal_();

            _this14.layoutFrame_ = 0;
          });
        }
        /** @private */

      }, {
        key: "layoutInternal_",
        value: function layoutInternal_() {
          var _this15 = this;

          this.frame_ = this.adapter_.computeBoundingRect();
          var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
          // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
          // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
          // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
          // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
          // `overflow: hidden`.

          var getBoundedRadius = function getBoundedRadius() {
            var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
            return hypotenuse + MDCRippleFoundation.numbers.PADDING;
          };

          this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

          this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;
          this.fgScale_ = this.maxRadius_ / this.initialSize_;
          this.updateLayoutCssVars_();
        }
        /** @private */

      }, {
        key: "updateLayoutCssVars_",
        value: function updateLayoutCssVars_() {
          var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
              VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
              VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
              VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
              VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
          this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
          this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

          if (this.adapter_.isUnbounded()) {
            this.unboundedCoords_ = {
              left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
              top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
            };
            this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
            this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
          }
        }
        /** @param {boolean} unbounded */

      }, {
        key: "setUnbounded",
        value: function setUnbounded(unbounded) {
          var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

          if (unbounded) {
            this.adapter_.addClass(UNBOUNDED);
          } else {
            this.adapter_.removeClass(UNBOUNDED);
          }
        }
      }, {
        key: "handleFocus",
        value: function handleFocus() {
          var _this16 = this;

          requestAnimationFrame(function () {
            return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }, {
        key: "handleBlur",
        value: function handleBlur() {
          var _this17 = this;

          requestAnimationFrame(function () {
            return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
          });
        }
      }]);

      return MDCRippleFoundation;
    }(MDCFoundation$m);

    /**
     * @extends MDCComponent<!MDCRippleFoundation>
     */

    var MDCRipple$c =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$n(MDCRipple, _MDCComponent);

      /** @param {...?} args */
      function MDCRipple() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck$n(this, MDCRipple);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn$n(this, (_getPrototypeOf2 = _getPrototypeOf$n(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
        /** @type {boolean} */

        _this.disabled = false;
        /** @private {boolean} */

        _this.unbounded_;
        return _this;
      }
      /**
       * @param {!Element} root
       * @param {{isUnbounded: (boolean|undefined)}=} options
       * @return {!MDCRipple}
       */


      _createClass$n(MDCRipple, [{
        key: "setUnbounded_",

        /**
         * Closure Compiler throws an access control error when directly accessing a
         * protected or private property inside a getter/setter, like unbounded above.
         * By accessing the protected property inside a method, we solve that problem.
         * That's why this function exists.
         * @private
         */
        value: function setUnbounded_() {
          this.foundation_.setUnbounded(this.unbounded_);
        }
      }, {
        key: "activate",
        value: function activate() {
          this.foundation_.activate();
        }
      }, {
        key: "deactivate",
        value: function deactivate() {
          this.foundation_.deactivate();
        }
      }, {
        key: "layout",
        value: function layout() {
          this.foundation_.layout();
        }
        /**
         * @return {!MDCRippleFoundation}
         * @override
         */

      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          return new MDCRippleFoundation$c(MDCRipple.createAdapter(this));
        }
        /** @override */

      }, {
        key: "initialSyncWithDOM",
        value: function initialSyncWithDOM() {
          this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
        }
      }, {
        key: "unbounded",

        /** @return {boolean} */
        get: function get() {
          return this.unbounded_;
        }
        /** @param {boolean} unbounded */
        ,
        set: function set(unbounded) {
          this.unbounded_ = Boolean(unbounded);
          this.setUnbounded_();
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref$isUnbounded = _ref.isUnbounded,
              isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

          var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

          if (isUnbounded !== undefined) {
            ripple.unbounded =
            /** @type {boolean} */
            isUnbounded;
          }

          return ripple;
        }
        /**
         * @param {!RippleCapableSurface} instance
         * @return {!MDCRippleAdapter}
         */

      }, {
        key: "createAdapter",
        value: function createAdapter(instance) {
          var MATCHES = getMatchesProperty$c(HTMLElement.prototype);
          return {
            browserSupportsCssVars: function browserSupportsCssVars() {
              return supportsCssVariables$c(window);
            },
            isUnbounded: function isUnbounded() {
              return instance.unbounded;
            },
            isSurfaceActive: function isSurfaceActive() {
              return instance.root_[MATCHES](':active');
            },
            isSurfaceDisabled: function isSurfaceDisabled() {
              return instance.disabled;
            },
            addClass: function addClass(className) {
              return instance.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return instance.root_.classList.remove(className);
            },
            containsEventTarget: function containsEventTarget(target) {
              return instance.root_.contains(target);
            },
            registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
              return instance.root_.addEventListener(evtType, handler, applyPassive$d());
            },
            deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
              return instance.root_.removeEventListener(evtType, handler, applyPassive$d());
            },
            registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.addEventListener(evtType, handler, applyPassive$d());
            },
            deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
              return document.documentElement.removeEventListener(evtType, handler, applyPassive$d());
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            updateCssVariable: function updateCssVariable(varName, value) {
              return instance.root_.style.setProperty(varName, value);
            },
            computeBoundingRect: function computeBoundingRect() {
              return instance.root_.getBoundingClientRect();
            },
            getWindowPageOffset: function getWindowPageOffset() {
              return {
                x: window.pageXOffset,
                y: window.pageYOffset
              };
            }
          };
        }
      }]);

      return MDCRipple;
    }(MDCComponent$l);

    /**
     * Copyright 2017 Google Inc. All Rights Reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *      http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var cssClasses$1$d = {
      FIXED: 'mdc-toolbar--fixed',
      FIXED_LASTROW: 'mdc-toolbar--fixed-lastrow-only',
      FIXED_AT_LAST_ROW: 'mdc-toolbar--fixed-at-last-row',
      TOOLBAR_ROW_FLEXIBLE: 'mdc-toolbar--flexible',
      FLEXIBLE_DEFAULT_BEHAVIOR: 'mdc-toolbar--flexible-default-behavior',
      FLEXIBLE_MAX: 'mdc-toolbar--flexible-space-maximized',
      FLEXIBLE_MIN: 'mdc-toolbar--flexible-space-minimized'
    };
    var strings$1$d = {
      TITLE_SELECTOR: '.mdc-toolbar__title',
      ICON_SELECTOR: '.mdc-toolbar__icon',
      FIRST_ROW_SELECTOR: '.mdc-toolbar__row:first-child',
      CHANGE_EVENT: 'MDCToolbar:change'
    };
    var numbers$1$5 = {
      MAX_TITLE_SIZE: 2.125,
      MIN_TITLE_SIZE: 1.25,
      TOOLBAR_ROW_HEIGHT: 64,
      TOOLBAR_ROW_MOBILE_HEIGHT: 56,
      TOOLBAR_MOBILE_BREAKPOINT: 600
    };

    var MDCToolbarFoundation =
    /*#__PURE__*/
    function (_MDCFoundation) {
      _inherits$n(MDCToolbarFoundation, _MDCFoundation);

      _createClass$n(MDCToolbarFoundation, null, [{
        key: "cssClasses",
        get: function get() {
          return cssClasses$1$d;
        }
      }, {
        key: "strings",
        get: function get() {
          return strings$1$d;
        }
      }, {
        key: "numbers",
        get: function get() {
          return numbers$1$5;
        }
      }, {
        key: "defaultAdapter",
        get: function get() {
          return {
            hasClass: function hasClass() {
              return (
                /* className: string */

                /* boolean */
                false
              );
            },
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            registerScrollHandler: function registerScrollHandler()
            /* handler: EventListener */
            {},
            deregisterScrollHandler: function deregisterScrollHandler()
            /* handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            getViewportWidth: function getViewportWidth() {
              return (
                /* number */
                0
              );
            },
            getViewportScrollY: function getViewportScrollY() {
              return (
                /* number */
                0
              );
            },
            getOffsetHeight: function getOffsetHeight() {
              return (
                /* number */
                0
              );
            },
            getFirstRowElementOffsetHeight: function getFirstRowElementOffsetHeight() {
              return (
                /* number */
                0
              );
            },
            notifyChange: function notifyChange()
            /* evtData: {flexibleExpansionRatio: number} */
            {},
            setStyle: function setStyle()
            /* property: string, value: string */
            {},
            setStyleForTitleElement: function setStyleForTitleElement()
            /* property: string, value: string */
            {},
            setStyleForFlexibleRowElement: function setStyleForFlexibleRowElement()
            /* property: string, value: string */
            {},
            setStyleForFixedAdjustElement: function setStyleForFixedAdjustElement()
            /* property: string, value: string */
            {}
          };
        }
      }]);

      function MDCToolbarFoundation(adapter) {
        var _this;

        _classCallCheck$n(this, MDCToolbarFoundation);

        _this = _possibleConstructorReturn$n(this, _getPrototypeOf$n(MDCToolbarFoundation).call(this, Object.assign(MDCToolbarFoundation.defaultAdapter, adapter)));

        _this.resizeHandler_ = function () {
          return _this.checkRowHeight_();
        };

        _this.scrollHandler_ = function () {
          return _this.updateToolbarStyles_();
        };

        _this.checkRowHeightFrame_ = 0;
        _this.scrollFrame_ = 0;
        _this.executedLastChange_ = false;
        _this.calculations_ = {
          toolbarRowHeight: 0,
          // Calculated Height ratio. We use ratio to calculate corresponding heights in resize event.
          toolbarRatio: 0,
          // The ratio of toolbar height to row height
          flexibleExpansionRatio: 0,
          // The ratio of flexible space height to row height
          maxTranslateYRatio: 0,
          // The ratio of max toolbar move up distance to row height
          scrollThresholdRatio: 0,
          // The ratio of max scrollTop that we should listen to to row height
          // Derived Heights based on the above key ratios.
          toolbarHeight: 0,
          flexibleExpansionHeight: 0,
          // Flexible row minus toolbar height (derived)
          maxTranslateYDistance: 0,
          // When toolbar only fix last row (derived)
          scrollThreshold: 0
        }; // Toolbar fixed behavior
        // If toolbar is fixed

        _this.fixed_ = false; // If fixed is targeted only at the last row

        _this.fixedLastrow_ = false; // Toolbar flexible behavior
        // If the first row is flexible

        _this.hasFlexibleRow_ = false; // If use the default behavior

        _this.useFlexDefaultBehavior_ = false;
        return _this;
      }

      _createClass$n(MDCToolbarFoundation, [{
        key: "init",
        value: function init() {
          this.fixed_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.FIXED);
          this.fixedLastrow_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.FIXED_LASTROW) & this.fixed_;
          this.hasFlexibleRow_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.TOOLBAR_ROW_FLEXIBLE);

          if (this.hasFlexibleRow_) {
            this.useFlexDefaultBehavior_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_DEFAULT_BEHAVIOR);
          }

          this.initKeyRatio_();
          this.setKeyHeights_();
          this.adapter_.registerResizeHandler(this.resizeHandler_);
          this.adapter_.registerScrollHandler(this.scrollHandler_);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.adapter_.deregisterResizeHandler(this.resizeHandler_);
          this.adapter_.deregisterScrollHandler(this.scrollHandler_);
        }
      }, {
        key: "updateAdjustElementStyles",
        value: function updateAdjustElementStyles() {
          if (this.fixed_) {
            this.adapter_.setStyleForFixedAdjustElement('margin-top', "".concat(this.calculations_.toolbarHeight, "px"));
          }
        }
      }, {
        key: "getFlexibleExpansionRatio_",
        value: function getFlexibleExpansionRatio_(scrollTop) {
          // To prevent division by zero when there is no flexibleExpansionHeight
          var delta = 0.0001;
          return Math.max(0, 1 - scrollTop / (this.calculations_.flexibleExpansionHeight + delta));
        }
      }, {
        key: "checkRowHeight_",
        value: function checkRowHeight_() {
          var _this2 = this;

          cancelAnimationFrame(this.checkRowHeightFrame_);
          this.checkRowHeightFrame_ = requestAnimationFrame(function () {
            return _this2.setKeyHeights_();
          });
        }
      }, {
        key: "setKeyHeights_",
        value: function setKeyHeights_() {
          var newToolbarRowHeight = this.getRowHeight_();

          if (newToolbarRowHeight !== this.calculations_.toolbarRowHeight) {
            this.calculations_.toolbarRowHeight = newToolbarRowHeight;
            this.calculations_.toolbarHeight = this.calculations_.toolbarRatio * this.calculations_.toolbarRowHeight;
            this.calculations_.flexibleExpansionHeight = this.calculations_.flexibleExpansionRatio * this.calculations_.toolbarRowHeight;
            this.calculations_.maxTranslateYDistance = this.calculations_.maxTranslateYRatio * this.calculations_.toolbarRowHeight;
            this.calculations_.scrollThreshold = this.calculations_.scrollThresholdRatio * this.calculations_.toolbarRowHeight;
            this.updateAdjustElementStyles();
            this.updateToolbarStyles_();
          }
        }
      }, {
        key: "updateToolbarStyles_",
        value: function updateToolbarStyles_() {
          var _this3 = this;

          cancelAnimationFrame(this.scrollFrame_);
          this.scrollFrame_ = requestAnimationFrame(function () {
            var scrollTop = _this3.adapter_.getViewportScrollY();

            var hasScrolledOutOfThreshold = _this3.scrolledOutOfThreshold_(scrollTop);

            if (hasScrolledOutOfThreshold && _this3.executedLastChange_) {
              return;
            }

            var flexibleExpansionRatio = _this3.getFlexibleExpansionRatio_(scrollTop);

            _this3.updateToolbarFlexibleState_(flexibleExpansionRatio);

            if (_this3.fixedLastrow_) {
              _this3.updateToolbarFixedState_(scrollTop);
            }

            if (_this3.hasFlexibleRow_) {
              _this3.updateFlexibleRowElementStyles_(flexibleExpansionRatio);
            }

            _this3.executedLastChange_ = hasScrolledOutOfThreshold;

            _this3.adapter_.notifyChange({
              flexibleExpansionRatio: flexibleExpansionRatio
            });
          });
        }
      }, {
        key: "scrolledOutOfThreshold_",
        value: function scrolledOutOfThreshold_(scrollTop) {
          return scrollTop > this.calculations_.scrollThreshold;
        }
      }, {
        key: "initKeyRatio_",
        value: function initKeyRatio_() {
          var toolbarRowHeight = this.getRowHeight_();
          var firstRowMaxRatio = this.adapter_.getFirstRowElementOffsetHeight() / toolbarRowHeight;
          this.calculations_.toolbarRatio = this.adapter_.getOffsetHeight() / toolbarRowHeight;
          this.calculations_.flexibleExpansionRatio = firstRowMaxRatio - 1;
          this.calculations_.maxTranslateYRatio = this.fixedLastrow_ ? this.calculations_.toolbarRatio - firstRowMaxRatio : 0;
          this.calculations_.scrollThresholdRatio = (this.fixedLastrow_ ? this.calculations_.toolbarRatio : firstRowMaxRatio) - 1;
        }
      }, {
        key: "getRowHeight_",
        value: function getRowHeight_() {
          var breakpoint = MDCToolbarFoundation.numbers.TOOLBAR_MOBILE_BREAKPOINT;
          return this.adapter_.getViewportWidth() < breakpoint ? MDCToolbarFoundation.numbers.TOOLBAR_ROW_MOBILE_HEIGHT : MDCToolbarFoundation.numbers.TOOLBAR_ROW_HEIGHT;
        }
      }, {
        key: "updateToolbarFlexibleState_",
        value: function updateToolbarFlexibleState_(flexibleExpansionRatio) {
          this.adapter_.removeClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MAX);
          this.adapter_.removeClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MIN);

          if (flexibleExpansionRatio === 1) {
            this.adapter_.addClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MAX);
          } else if (flexibleExpansionRatio === 0) {
            this.adapter_.addClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MIN);
          }
        }
      }, {
        key: "updateToolbarFixedState_",
        value: function updateToolbarFixedState_(scrollTop) {
          var translateDistance = Math.max(0, Math.min(scrollTop - this.calculations_.flexibleExpansionHeight, this.calculations_.maxTranslateYDistance));
          this.adapter_.setStyle('transform', "translateY(".concat(-translateDistance, "px)"));

          if (translateDistance === this.calculations_.maxTranslateYDistance) {
            this.adapter_.addClass(MDCToolbarFoundation.cssClasses.FIXED_AT_LAST_ROW);
          } else {
            this.adapter_.removeClass(MDCToolbarFoundation.cssClasses.FIXED_AT_LAST_ROW);
          }
        }
      }, {
        key: "updateFlexibleRowElementStyles_",
        value: function updateFlexibleRowElementStyles_(flexibleExpansionRatio) {
          if (this.fixed_) {
            var height = this.calculations_.flexibleExpansionHeight * flexibleExpansionRatio;
            this.adapter_.setStyleForFlexibleRowElement('height', "".concat(height + this.calculations_.toolbarRowHeight, "px"));
          }

          if (this.useFlexDefaultBehavior_) {
            this.updateElementStylesDefaultBehavior_(flexibleExpansionRatio);
          }
        }
      }, {
        key: "updateElementStylesDefaultBehavior_",
        value: function updateElementStylesDefaultBehavior_(flexibleExpansionRatio) {
          var maxTitleSize = MDCToolbarFoundation.numbers.MAX_TITLE_SIZE;
          var minTitleSize = MDCToolbarFoundation.numbers.MIN_TITLE_SIZE;
          var currentTitleSize = (maxTitleSize - minTitleSize) * flexibleExpansionRatio + minTitleSize;
          this.adapter_.setStyleForTitleElement('font-size', "".concat(currentTitleSize, "rem"));
        }
      }]);

      return MDCToolbarFoundation;
    }(MDCFoundation$m);

    var MDCToolbar =
    /*#__PURE__*/
    function (_MDCComponent) {
      _inherits$n(MDCToolbar, _MDCComponent);

      function MDCToolbar() {
        _classCallCheck$n(this, MDCToolbar);

        return _possibleConstructorReturn$n(this, _getPrototypeOf$n(MDCToolbar).apply(this, arguments));
      }

      _createClass$n(MDCToolbar, [{
        key: "initialize",
        value: function initialize() {
          this.ripples_ = [].map.call(this.root_.querySelectorAll(MDCToolbarFoundation.strings.ICON_SELECTOR), function (icon) {
            var ripple = MDCRipple$c.attachTo(icon);
            ripple.unbounded = true;
            return ripple;
          });
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.ripples_.forEach(function (ripple) {
            ripple.destroy();
          });

          _get$c(_getPrototypeOf$n(MDCToolbar.prototype), "destroy", this).call(this);
        }
      }, {
        key: "getDefaultFoundation",
        value: function getDefaultFoundation() {
          var _this = this;

          return new MDCToolbarFoundation({
            hasClass: function hasClass(className) {
              return _this.root_.classList.contains(className);
            },
            addClass: function addClass(className) {
              return _this.root_.classList.add(className);
            },
            removeClass: function removeClass(className) {
              return _this.root_.classList.remove(className);
            },
            registerScrollHandler: function registerScrollHandler(handler) {
              return window.addEventListener('scroll', handler);
            },
            deregisterScrollHandler: function deregisterScrollHandler(handler) {
              return window.removeEventListener('scroll', handler);
            },
            registerResizeHandler: function registerResizeHandler(handler) {
              return window.addEventListener('resize', handler);
            },
            deregisterResizeHandler: function deregisterResizeHandler(handler) {
              return window.removeEventListener('resize', handler);
            },
            getViewportWidth: function getViewportWidth() {
              return window.innerWidth;
            },
            getViewportScrollY: function getViewportScrollY() {
              return window.pageYOffset;
            },
            getOffsetHeight: function getOffsetHeight() {
              return _this.root_.offsetHeight;
            },
            getFirstRowElementOffsetHeight: function getFirstRowElementOffsetHeight() {
              return _this.firstRowElement_.offsetHeight;
            },
            notifyChange: function notifyChange(evtData) {
              return _this.emit(MDCToolbarFoundation.strings.CHANGE_EVENT, evtData);
            },
            setStyle: function setStyle(property, value) {
              return _this.root_.style.setProperty(property, value);
            },
            setStyleForTitleElement: function setStyleForTitleElement(property, value) {
              return _this.titleElement_.style.setProperty(property, value);
            },
            setStyleForFlexibleRowElement: function setStyleForFlexibleRowElement(property, value) {
              return _this.firstRowElement_.style.setProperty(property, value);
            },
            setStyleForFixedAdjustElement: function setStyleForFixedAdjustElement(property, value) {
              if (_this.fixedAdjustElement) {
                _this.fixedAdjustElement.style.setProperty(property, value);
              }
            }
          });
        }
      }, {
        key: "firstRowElement_",
        get: function get$$1() {
          return this.root_.querySelector(MDCToolbarFoundation.strings.FIRST_ROW_SELECTOR);
        }
      }, {
        key: "titleElement_",
        get: function get$$1() {
          return this.root_.querySelector(MDCToolbarFoundation.strings.TITLE_SELECTOR);
        }
      }, {
        key: "fixedAdjustElement",
        set: function set(fixedAdjustElement) {
          this.fixedAdjustElement_ = fixedAdjustElement;
          this.foundation_.updateAdjustElementStyles();
        },
        get: function get$$1() {
          return this.fixedAdjustElement_;
        }
      }], [{
        key: "attachTo",
        value: function attachTo(root) {
          return new MDCToolbar(root);
        }
      }]);

      return MDCToolbar;
    }(MDCComponent$l);

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcToolbarIcon = /** @class */ (function () {
        function MdcToolbarIcon(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcToolbarIcon.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdc-toolbar-icon]'
                    },] },
        ];
        /** @nocollapse */
        MdcToolbarIcon.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcToolbarIcon.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-toolbar__icon',] }]
        };
        return MdcToolbarIcon;
    }());
    var MdcToolbarSection = /** @class */ (function () {
        function MdcToolbarSection() {
            this.alignStart = false;
            this.alignEnd = false;
            this.shrinkToFit = false;
            this.isHostClass = true;
        }
        Object.defineProperty(MdcToolbarSection.prototype, "classAlignStart", {
            get: /**
             * @return {?}
             */
            function () {
                return this.alignStart ? 'mdc-toolbar__section--align-start' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcToolbarSection.prototype, "classAlignEnd", {
            get: /**
             * @return {?}
             */
            function () {
                return this.alignEnd ? 'mdc-toolbar__section--align-end' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcToolbarSection.prototype, "classShrinkToFit", {
            get: /**
             * @return {?}
             */
            function () {
                return this.shrinkToFit ? 'mdc-toolbar__section--shrink-to-fit' : '';
            },
            enumerable: true,
            configurable: true
        });
        MdcToolbarSection.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-toolbar-section',
                        exportAs: 'mdcToolbarSection'
                    },] },
        ];
        MdcToolbarSection.propDecorators = {
            alignStart: [{ type: core.Input }],
            alignEnd: [{ type: core.Input }],
            shrinkToFit: [{ type: core.Input }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-toolbar__section',] }],
            classAlignStart: [{ type: core.HostBinding, args: ['class.mdc-toolbar__section--align-start',] }],
            classAlignEnd: [{ type: core.HostBinding, args: ['class.mdc-toolbar__section--align-end',] }],
            classShrinkToFit: [{ type: core.HostBinding, args: ['class.mdc-toolbar__section--shrink-to-fit',] }]
        };
        return MdcToolbarSection;
    }());
    var MdcToolbarTitle = /** @class */ (function () {
        function MdcToolbarTitle(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcToolbarTitle.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdc-toolbar-title], mdc-toolbar-title',
                        exportAs: 'mdcToolbarTitle'
                    },] },
        ];
        /** @nocollapse */
        MdcToolbarTitle.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcToolbarTitle.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-toolbar__title',] }]
        };
        return MdcToolbarTitle;
    }());
    var MdcToolbarFixedAdjust = /** @class */ (function () {
        function MdcToolbarFixedAdjust(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcToolbarFixedAdjust.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdc-toolbar-fixed-adjust], mdc-toolbar-fixed-adjust',
                        exportAs: 'mdcToolbarFixedAdjust'
                    },] },
        ];
        /** @nocollapse */
        MdcToolbarFixedAdjust.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcToolbarFixedAdjust.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-toolbar-fixed-adjust',] }]
        };
        return MdcToolbarFixedAdjust;
    }());
    var MdcToolbarRow = /** @class */ (function () {
        function MdcToolbarRow(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcToolbarRow.decorators = [
            { type: core.Directive, args: [{
                        selector: 'mdc-toolbar-row',
                        exportAs: 'mdcToolbarRow'
                    },] },
        ];
        /** @nocollapse */
        MdcToolbarRow.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcToolbarRow.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-toolbar__row',] }]
        };
        return MdcToolbarRow;
    }());
    var MdcToolbarMenuIcon = /** @class */ (function () {
        function MdcToolbarMenuIcon(elementRef) {
            this.elementRef = elementRef;
            this.isHostClass = true;
        }
        MdcToolbarMenuIcon.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdc-toolbar-menu-icon]',
                        exportAs: 'mdcToolbarMenuIcon'
                    },] },
        ];
        /** @nocollapse */
        MdcToolbarMenuIcon.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        MdcToolbarMenuIcon.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-toolbar__menu-icon',] }]
        };
        return MdcToolbarMenuIcon;
    }());
    var MdcToolbar = /** @class */ (function () {
        function MdcToolbar(_changeDetectorRef, _renderer, elementRef, _registry) {
            var _this = this;
            this._changeDetectorRef = _changeDetectorRef;
            this._renderer = _renderer;
            this.elementRef = elementRef;
            this._registry = _registry;
            this.flexibleDefaultBehavior = true;
            this.fixed = false;
            this.waterfall = false;
            this.fixedLastrow = false;
            this.adjustBodyMargin = true;
            this.change = new core.EventEmitter();
            this.isHostClass = true;
            this._mdcAdapter = {
                hasClass: function (className) {
                    return _this.elementRef.nativeElement.classList.contains(className);
                },
                addClass: function (className) {
                    _this._renderer.addClass(_this.elementRef.nativeElement, className);
                },
                removeClass: function (className) {
                    _this._renderer.removeClass(_this.elementRef.nativeElement, className);
                },
                registerScrollHandler: function (handler) {
                    if (isBrowser()) {
                        _this._registry.listen('scroll', handler, window);
                    }
                },
                deregisterScrollHandler: function (handler) {
                    if (isBrowser()) {
                        _this._registry.unlisten('scroll', handler);
                    }
                },
                registerResizeHandler: function (handler) {
                    if (isBrowser()) {
                        _this._registry.listen('resize', handler, window);
                    }
                },
                deregisterResizeHandler: function (handler) {
                    if (isBrowser()) {
                        _this._registry.unlisten('resize', handler);
                    }
                },
                getViewportWidth: function () { return isBrowser() ? window.innerWidth : 0; },
                getViewportScrollY: function () { return isBrowser() ? window.pageYOffset : 0; },
                getOffsetHeight: function () { return _this.elementRef.nativeElement.offsetHeight; },
                getFirstRowElementOffsetHeight: function () {
                    return _this.firstRow ? _this.firstRow.elementRef.nativeElement.offsetHeight : 0;
                },
                notifyChange: function (evtData) {
                    _this.change.emit(evtData.flexibleExpansionRatio);
                },
                setStyle: function (property, value) {
                    _this._renderer.setStyle(_this.elementRef.nativeElement, property, value);
                },
                setStyleForTitleElement: function (property, value) {
                    if (_this.title) {
                        _this._renderer.setStyle(_this.title.elementRef.nativeElement, property, value);
                    }
                },
                setStyleForFlexibleRowElement: function (property, value) {
                    if (_this.firstRow) {
                        _this._renderer.setStyle(_this.firstRow.elementRef.nativeElement, property, value);
                    }
                },
                setStyleForFixedAdjustElement: function (property, value) {
                    if (!isBrowser()) {
                        return;
                    }
                    if (_this.adjustBodyMargin && _this.fixed) {
                        _this._renderer.setStyle(_this._fixedAdjustElement ?
                            _this._fixedAdjustElement : document.body, property, value);
                    }
                }
            };
            this._foundation = new MDCToolbarFoundation(this._mdcAdapter);
        }
        Object.defineProperty(MdcToolbar.prototype, "flexible", {
            get: /**
             * @return {?}
             */
            function () { return this._flexible; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._flexible = toBoolean(value);
                this._changeDetectorRef.markForCheck();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcToolbar.prototype, "fixedAdjustElement", {
            get: /**
             * @return {?}
             */
            function () { return this._fixedAdjustElement; },
            set: /**
             * @param {?} element
             * @return {?}
             */
            function (element) {
                if (this._fixedAdjustElement !== element) {
                    this._fixedAdjustElement = element;
                    this._changeDetectorRef.markForCheck();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcToolbar.prototype, "classFixedToolbar", {
            get: /**
             * @return {?}
             */
            function () {
                return this.fixed ? 'mdc-toolbar--fixed' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcToolbar.prototype, "classWaterfallToolbar", {
            get: /**
             * @return {?}
             */
            function () {
                return this.waterfall ? 'mdc-toolbar--waterfall' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcToolbar.prototype, "classFlexibleToolbar", {
            get: /**
             * @return {?}
             */
            function () {
                return this.flexible ? 'mdc-toolbar--flexible' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcToolbar.prototype, "classFixedLastrow", {
            get: /**
             * @return {?}
             */
            function () {
                return this.fixedLastrow ? 'mdc-toolbar--fixed-lastrow-only' : '';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MdcToolbar.prototype, "classFlexibleDefaultBehavior", {
            get: /**
             * @return {?}
             */
            function () {
                return this.flexible && this.flexibleDefaultBehavior ? 'mdc-toolbar--flexible-default-behavior' : '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} changes
         * @return {?}
         */
        MdcToolbar.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
        function (changes) {
            var /** @type {?} */ fixedAdjustElement = changes['fixedAdjustElement'];
            if (fixedAdjustElement) {
                if (fixedAdjustElement.currentValue) {
                    this._renderer.addClass(fixedAdjustElement.currentValue, 'mdc-toolbar-fixed-adjust');
                }
                if (fixedAdjustElement.previousValue) {
                    this._renderer.removeClass(fixedAdjustElement.previousValue, 'mdc-toolbar-fixed-adjust');
                }
            }
        };
        /**
         * @return {?}
         */
        MdcToolbar.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this._foundation.init();
            this.updateAdjustElementStyles();
            this._changeDetectorRef.detectChanges();
        };
        /**
         * @return {?}
         */
        MdcToolbar.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (isBrowser()) {
                this._renderer.removeStyle(this.fixedAdjustElement ?
                    this.fixedAdjustElement : document.body, 'mdc-toolbar-fixed-adjust');
            }
            this._foundation.destroy();
        };
        /**
         * @return {?}
         */
        MdcToolbar.prototype.updateAdjustElementStyles = /**
         * @return {?}
         */
        function () {
            this._foundation.updateAdjustElementStyles();
        };
        MdcToolbar.decorators = [
            { type: core.Component, args: [{selector: 'mdc-toolbar',
                        template: '<ng-content></ng-content>',
                        exportAs: 'mdcToolbar',
                        providers: [EventRegistry],
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        MdcToolbar.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.Renderer2 },
            { type: core.ElementRef },
            { type: EventRegistry }
        ]; };
        MdcToolbar.propDecorators = {
            flexibleDefaultBehavior: [{ type: core.Input }],
            fixed: [{ type: core.Input }],
            waterfall: [{ type: core.Input }],
            fixedLastrow: [{ type: core.Input }],
            adjustBodyMargin: [{ type: core.Input }],
            flexible: [{ type: core.Input }],
            fixedAdjustElement: [{ type: core.Input }],
            change: [{ type: core.Output }],
            firstRow: [{ type: core.ContentChild, args: [MdcToolbarRow,] }],
            title: [{ type: core.ContentChild, args: [MdcToolbarTitle,] }],
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-toolbar',] }],
            classFixedToolbar: [{ type: core.HostBinding, args: ['class.mdc-toolbar--fixed',] }],
            classWaterfallToolbar: [{ type: core.HostBinding, args: ['class.mdc-toolbar--waterfall',] }],
            classFlexibleToolbar: [{ type: core.HostBinding, args: ['class.mdc-toolbar--flexible',] }],
            classFixedLastrow: [{ type: core.HostBinding, args: ['class.mdc-toolbar--fixed-lastrow-only',] }],
            classFlexibleDefaultBehavior: [{ type: core.HostBinding, args: ['class.mdc-toolbar--flexible-default-behavior',] }]
        };
        return MdcToolbar;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ TOOLBAR_COMPONENTS = [
        MdcToolbar,
        MdcToolbarFixedAdjust,
        MdcToolbarIcon,
        MdcToolbarMenuIcon,
        MdcToolbarRow,
        MdcToolbarSection,
        MdcToolbarTitle,
    ];
    var MdcToolbarModule = /** @class */ (function () {
        function MdcToolbarModule() {
        }
        MdcToolbarModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [TOOLBAR_COMPONENTS],
                        declarations: [TOOLBAR_COMPONENTS],
                    },] },
        ];
        return MdcToolbarModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MdcTypography = /** @class */ (function () {
        function MdcTypography() {
            this.isHostClass = true;
        }
        MdcTypography.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdc-typography], [mdcTypography]'
                    },] },
        ];
        MdcTypography.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-typography',] }]
        };
        return MdcTypography;
    }());
    var MdcTypographyHeadline1 = /** @class */ (function () {
        function MdcTypographyHeadline1() {
            this.isHostClass = true;
        }
        MdcTypographyHeadline1.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcHeadline1], [mdc-typography-display4]'
                    },] },
        ];
        MdcTypographyHeadline1.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-typography--headline1',] }]
        };
        return MdcTypographyHeadline1;
    }());
    var MdcTypographyHeadline2 = /** @class */ (function () {
        function MdcTypographyHeadline2() {
            this.isHostClass = true;
        }
        MdcTypographyHeadline2.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcHeadline2], [mdc-typography-display3]'
                    },] },
        ];
        MdcTypographyHeadline2.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-typography--headline2',] }]
        };
        return MdcTypographyHeadline2;
    }());
    var MdcTypographyHeadline3 = /** @class */ (function () {
        function MdcTypographyHeadline3() {
            this.isHostClass = true;
        }
        MdcTypographyHeadline3.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcHeadline3], [mdc-typography-display2]'
                    },] },
        ];
        MdcTypographyHeadline3.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-typography--headline3',] }]
        };
        return MdcTypographyHeadline3;
    }());
    var MdcTypographyHeadline4 = /** @class */ (function () {
        function MdcTypographyHeadline4() {
            this.isHostClass = true;
        }
        MdcTypographyHeadline4.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcHeadline4], [mdc-typography-display1]'
                    },] },
        ];
        MdcTypographyHeadline4.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-typography--headline4',] }]
        };
        return MdcTypographyHeadline4;
    }());
    var MdcTypographyHeadline5 = /** @class */ (function () {
        function MdcTypographyHeadline5() {
            this.isHostClass = true;
        }
        MdcTypographyHeadline5.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcHeadline5], [mdc-typography-headline]'
                    },] },
        ];
        MdcTypographyHeadline5.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-typography--headline5',] }]
        };
        return MdcTypographyHeadline5;
    }());
    var MdcTypographyHeadline6 = /** @class */ (function () {
        function MdcTypographyHeadline6() {
            this.isHostClass = true;
        }
        MdcTypographyHeadline6.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcHeadline6], [mdc-typography-title]'
                    },] },
        ];
        MdcTypographyHeadline6.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-typography--headline6',] }]
        };
        return MdcTypographyHeadline6;
    }());
    var MdcTypographySubtitle1 = /** @class */ (function () {
        function MdcTypographySubtitle1() {
            this.isHostClass = true;
        }
        MdcTypographySubtitle1.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcSubtitle1], [mdc-typography-subheading2]'
                    },] },
        ];
        MdcTypographySubtitle1.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-typography--subtitle1',] }]
        };
        return MdcTypographySubtitle1;
    }());
    var MdcTypographySubtitle2 = /** @class */ (function () {
        function MdcTypographySubtitle2() {
            this.isHostClass = true;
        }
        MdcTypographySubtitle2.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcSubtitle2], [mdc-typography-subheading1]'
                    },] },
        ];
        MdcTypographySubtitle2.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-typography--subtitle2',] }]
        };
        return MdcTypographySubtitle2;
    }());
    var MdcTypographyBody2 = /** @class */ (function () {
        function MdcTypographyBody2() {
            this.isHostClass = true;
        }
        MdcTypographyBody2.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcBody2], [mdc-typography-body2]'
                    },] },
        ];
        MdcTypographyBody2.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-typography--body2',] }]
        };
        return MdcTypographyBody2;
    }());
    var MdcTypographyBody1 = /** @class */ (function () {
        function MdcTypographyBody1() {
            this.isHostClass = true;
        }
        MdcTypographyBody1.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcBody1], [mdc-typography-body1]'
                    },] },
        ];
        MdcTypographyBody1.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-typography--body1',] }]
        };
        return MdcTypographyBody1;
    }());
    var MdcTypographyCaption = /** @class */ (function () {
        function MdcTypographyCaption() {
            this.isHostClass = true;
        }
        MdcTypographyCaption.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcCaption], [mdc-typography-caption]'
                    },] },
        ];
        MdcTypographyCaption.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-typography--caption',] }]
        };
        return MdcTypographyCaption;
    }());
    var MdcTypographyButton = /** @class */ (function () {
        function MdcTypographyButton() {
            this.isHostClass = true;
        }
        MdcTypographyButton.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcButton]'
                    },] },
        ];
        MdcTypographyButton.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-typography--button',] }]
        };
        return MdcTypographyButton;
    }());
    var MdcTypographyOverline = /** @class */ (function () {
        function MdcTypographyOverline() {
            this.isHostClass = true;
        }
        MdcTypographyOverline.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mdcOverline]'
                    },] },
        ];
        MdcTypographyOverline.propDecorators = {
            isHostClass: [{ type: core.HostBinding, args: ['class.mdc-typography--overline',] }]
        };
        return MdcTypographyOverline;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ TYPOGRAPHY_DECLARATIONS = [
        MdcTypography,
        MdcTypographyBody1,
        MdcTypographyBody2,
        MdcTypographyButton,
        MdcTypographyCaption,
        MdcTypographyHeadline1,
        MdcTypographyHeadline2,
        MdcTypographyHeadline3,
        MdcTypographyHeadline4,
        MdcTypographyHeadline5,
        MdcTypographyHeadline6,
        MdcTypographyOverline,
        MdcTypographySubtitle1,
        MdcTypographySubtitle2
    ];
    var MdcTypographyModule = /** @class */ (function () {
        function MdcTypographyModule() {
        }
        MdcTypographyModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: TYPOGRAPHY_DECLARATIONS,
                        declarations: TYPOGRAPHY_DECLARATIONS,
                    },] },
        ];
        return MdcTypographyModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Current version of Angular MDC.
     */
    var /** @type {?} */ VERSION = new core.Version('0.37.2');

    exports.VERSION = VERSION;
    exports.MdcAppBarModule = MdcAppBarModule;
    exports.MdcAppBarRow = MdcAppBarRow;
    exports.MdcAppBarSection = MdcAppBarSection;
    exports.MdcAppBarActionItem = MdcAppBarActionItem;
    exports.MdcAppBarNavigationIcon = MdcAppBarNavigationIcon;
    exports.MdcAppBarTitle = MdcAppBarTitle;
    exports.MdcAppBarNavSelected = MdcAppBarNavSelected;
    exports.MdcAppBar = MdcAppBar;
    exports.MdcButtonModule = MdcButtonModule;
    exports.MdcButton = MdcButton;
    exports.MdcCardModule = MdcCardModule;
    exports.MdcCardMediaContent = MdcCardMediaContent;
    exports.MdcCardMedia = MdcCardMedia;
    exports.MdcCardPrimaryAction = MdcCardPrimaryAction;
    exports.MdcCardActions = MdcCardActions;
    exports.MdcCardActionButtons = MdcCardActionButtons;
    exports.MdcCardActionIcons = MdcCardActionIcons;
    exports.MdcCardAction = MdcCardAction;
    exports.MdcCard = MdcCard;
    exports.MdcCheckboxModule = MdcCheckboxModule;
    exports.MdcCheckboxChange = MdcCheckboxChange;
    exports.MDC_CHECKBOX_CONTROL_VALUE_ACCESSOR = MDC_CHECKBOX_CONTROL_VALUE_ACCESSOR;
    exports.MdcCheckbox = MdcCheckbox;
    exports.CHIP_DECLARATIONS = CHIP_DECLARATIONS;
    exports.MdcChipsModule = MdcChipsModule;
    exports.MdcChipSelectionEvent = MdcChipSelectionEvent;
    exports.MdcChipIcon = MdcChipIcon;
    exports.MdcChipCheckmark = MdcChipCheckmark;
    exports.MdcChipText = MdcChipText;
    exports.MdcChip = MdcChip;
    exports.MdcChipSet = MdcChipSet;
    exports.toBoolean = toBoolean;
    exports.EventRegistry = EventRegistry;
    exports.isSpaceKey = isSpaceKey;
    exports.UP_ARROW = UP_ARROW;
    exports.DOWN_ARROW = DOWN_ARROW;
    exports.RIGHT_ARROW = RIGHT_ARROW;
    exports.LEFT_ARROW = LEFT_ARROW;
    exports.PAGE_UP = PAGE_UP;
    exports.PAGE_DOWN = PAGE_DOWN;
    exports.HOME = HOME;
    exports.END = END;
    exports.ENTER = ENTER;
    exports.SPACE = SPACE;
    exports.TAB = TAB;
    exports.ESCAPE = ESCAPE;
    exports.BACKSPACE = BACKSPACE;
    exports.DELETE = DELETE;
    exports.A = A;
    exports.Z = Z;
    exports.ZERO = ZERO;
    exports.NINE = NINE;
    exports.COMMA = COMMA;
    exports.toNumber = toNumber;
    exports._isNumberValue = _isNumberValue;
    exports.isBrowser = isBrowser;
    exports.MdcRouter = MdcRouter;
    exports.MdcRouterModule = MdcRouterModule;
    exports.MdcDialogConfig = MdcDialogConfig;
    exports.MdcDialogContainer = MdcDialogContainer;
    exports.MdcDialogSurface = MdcDialogSurface;
    exports.MdcDialogHeader = MdcDialogHeader;
    exports.MdcDialogHeaderTitle = MdcDialogHeaderTitle;
    exports.MdcDialogBody = MdcDialogBody;
    exports.MdcDialogFooter = MdcDialogFooter;
    exports.MdcDialogButton = MdcDialogButton;
    exports.DIALOG_DATA = DIALOG_DATA;
    exports.DIALOG_REF = DIALOG_REF;
    exports.DIALOG_CONFIG = DIALOG_CONFIG;
    exports.DIALOG_CONTAINER = DIALOG_CONTAINER;
    exports.MdcDialogModule = MdcDialogModule;
    exports.MdcDialogRef = MdcDialogRef;
    exports.MdcDialogComponent = MdcDialogComponent;
    exports.MdcDialog = MdcDialog;
    exports.ɵd14 = MdcDrawerContent;
    exports.ɵb14 = MdcDrawerHeader;
    exports.ɵc14 = MdcDrawerHeaderContent;
    exports.ɵe14 = MdcDrawerNavigation;
    exports.ɵa14 = MdcDrawerSpacer;
    exports.MdcDrawerModule = MdcDrawerModule;
    exports.FOCUSABLE_ELEMENTS = FOCUSABLE_ELEMENTS$1;
    exports.MdcDrawer = MdcDrawer;
    exports.MdcElevationModule = MdcElevationModule;
    exports.MdcElevation = MdcElevation;
    exports.MdcFabModule = MdcFabModule;
    exports.MdcFab = MdcFab;
    exports.MdcFloatingLabelModule = MdcFloatingLabelModule;
    exports.MdcFloatingLabel = MdcFloatingLabel;
    exports.MdcFormFieldModule = MdcFormFieldModule;
    exports.MdcFormField = MdcFormField;
    exports.MdcFormFieldControl = MdcFormFieldControl;
    exports.MdcGridListModule = MdcGridListModule;
    exports.MdcGridTileTitle = MdcGridTileTitle;
    exports.MdcGridTileSupportText = MdcGridTileSupportText;
    exports.MdcGridTilePrimary = MdcGridTilePrimary;
    exports.MdcGridTilePrimaryContent = MdcGridTilePrimaryContent;
    exports.MdcGridTileSecondary = MdcGridTileSecondary;
    exports.MdcGridTile = MdcGridTile;
    exports.MdcGridListTiles = MdcGridListTiles;
    exports.MdcGridList = MdcGridList;
    exports.MdcIconModule = MdcIconModule;
    exports.MdcIcon = MdcIcon;
    exports.MdcIconButtonModule = MdcIconButtonModule;
    exports.MDC_ICON_BUTTON_CONTROL_VALUE_ACCESSOR = MDC_ICON_BUTTON_CONTROL_VALUE_ACCESSOR;
    exports.MdcIconButtonChange = MdcIconButtonChange;
    exports.MdcIconButton = MdcIconButton;
    exports.MdcIconToggleModule = MdcIconToggleModule;
    exports.MD_ICON_TOGGLE_CONTROL_VALUE_ACCESSOR = MD_ICON_TOGGLE_CONTROL_VALUE_ACCESSOR;
    exports.MdcIconToggle = MdcIconToggle;
    exports.MdcImageListModule = MdcImageListModule;
    exports.MdcImageListItem = MdcImageListItem;
    exports.MdcImageListImageAspect = MdcImageListImageAspect;
    exports.MdcImageListImage = MdcImageListImage;
    exports.MdcImageListSupporting = MdcImageListSupporting;
    exports.MdcImageListLabel = MdcImageListLabel;
    exports.MdcImageList = MdcImageList;
    exports.MdcLineRippleModule = MdcLineRippleModule;
    exports.MdcLineRipple = MdcLineRipple;
    exports.MdcLinearProgressModule = MdcLinearProgressModule;
    exports.MdcLinearProgress = MdcLinearProgress;
    exports.MdcListModule = MdcListModule;
    exports.MdcListSelectionChange = MdcListSelectionChange;
    exports.MdcListItemGraphic = MdcListItemGraphic;
    exports.MdcListItemMeta = MdcListItemMeta;
    exports.MdcListItemText = MdcListItemText;
    exports.MdcListItemSecondary = MdcListItemSecondary;
    exports.MdcListItem = MdcListItem;
    exports.MdcListItemChange = MdcListItemChange;
    exports.MdcListGroup = MdcListGroup;
    exports.MdcListGroupSubheader = MdcListGroupSubheader;
    exports.MdcListDivider = MdcListDivider;
    exports.MdcList = MdcList;
    exports.MdcMenuModule = MdcMenuModule;
    exports.MdcMenuChange = MdcMenuChange;
    exports.MdcMenuAnchor = MdcMenuAnchor;
    exports.MdcMenuDivider = MdcMenuDivider;
    exports.MdcMenuItems = MdcMenuItems;
    exports.MdcMenuItem = MdcMenuItem;
    exports.MdcMenu = MdcMenu;
    exports.MdcNotchedOutlineModule = MdcNotchedOutlineModule;
    exports.MdcNotchedOutline = MdcNotchedOutline;
    exports.DomPortalOutlet = DomPortalOutlet;
    exports.Portal = Portal;
    exports.ComponentPortal = ComponentPortal;
    exports.BasePortalOutlet = BasePortalOutlet;
    exports.PortalInjector = PortalInjector;
    exports.CdkPortalOutlet = CdkPortalOutlet;
    exports.PortalModule = PortalModule;
    exports.MdcPortalService = MdcPortalService;
    exports.MdcRadioModule = MdcRadioModule;
    exports.MDC_RADIO_CONTROL_VALUE_ACCESSOR = MDC_RADIO_CONTROL_VALUE_ACCESSOR;
    exports.MdcRadioChange = MdcRadioChange;
    exports.MdcRadio = MdcRadio;
    exports.MdcRippleModule = MdcRippleModule;
    exports.MdcRipple = MdcRipple;
    exports.MdcRippleComponent = MdcRippleComponent;
    exports.MdcRippleDirective = MdcRippleDirective;
    exports.MdcSelectModule = MdcSelectModule;
    exports.MDC_SELECT_CONTROL_VALUE_ACCESSOR = MDC_SELECT_CONTROL_VALUE_ACCESSOR;
    exports.MdcSelectChange = MdcSelectChange;
    exports.MdcSelect = MdcSelect;
    exports.MdcShapeModule = MdcShapeModule;
    exports.MdcShapeContainerCorner = MdcShapeContainerCorner;
    exports.MdcShapeContainer = MdcShapeContainer;
    exports.MdcSliderModule = MdcSliderModule;
    exports.MDC_SLIDER_CONTROL_VALUE_ACCESSOR = MDC_SLIDER_CONTROL_VALUE_ACCESSOR;
    exports.MdcSliderChange = MdcSliderChange;
    exports.MdcSlider = MdcSlider;
    exports.MdcSnackbarModule = MdcSnackbarModule;
    exports.MdcSnackbarConfig = MdcSnackbarConfig;
    exports.MdcSnackbarRef = MdcSnackbarRef;
    exports.MdcSnackbarComponent = MdcSnackbarComponent;
    exports.MdcSnackbar = MdcSnackbar;
    exports.MdcSwitchModule = MdcSwitchModule;
    exports.MDC_SWITCH_CONTROL_VALUE_ACCESSOR = MDC_SWITCH_CONTROL_VALUE_ACCESSOR;
    exports.MdcSwitchChange = MdcSwitchChange;
    exports.MdcSwitch = MdcSwitch;
    exports.MdcTabModule = MdcTabModule;
    exports.MdcTabIconText = MdcTabIconText;
    exports.MdcTab = MdcTab;
    exports.MdcTabChangeEvent = MdcTabChangeEvent;
    exports.MdcTabBarIndicator = MdcTabBarIndicator;
    exports.MdcTabBar = MdcTabBar;
    exports.MdcTabBarScrollBack = MdcTabBarScrollBack;
    exports.MdcTabBarScrollForward = MdcTabBarScrollForward;
    exports.MdcTabBarScrollFrame = MdcTabBarScrollFrame;
    exports.MdcTabBarScroller = MdcTabBarScroller;
    exports.MdcTextFieldModule = MdcTextFieldModule;
    exports.MDC_TEXTFIELD_CONTROL_VALUE_ACCESSOR = MDC_TEXTFIELD_CONTROL_VALUE_ACCESSOR;
    exports.MdcTextField = MdcTextField;
    exports.MDC_TEXTAREA_CONTROL_VALUE_ACCESSOR = MDC_TEXTAREA_CONTROL_VALUE_ACCESSOR;
    exports.MdcTextarea = MdcTextarea;
    exports.MdcTextFieldHelperText = MdcTextFieldHelperText;
    exports.MdcThemeModule = MdcThemeModule;
    exports.MdcMaterialIcons = MdcMaterialIcons;
    exports.MdcContent = MdcContent;
    exports.MdcToolbarModule = MdcToolbarModule;
    exports.MdcToolbarIcon = MdcToolbarIcon;
    exports.MdcToolbarSection = MdcToolbarSection;
    exports.MdcToolbarTitle = MdcToolbarTitle;
    exports.MdcToolbarFixedAdjust = MdcToolbarFixedAdjust;
    exports.MdcToolbarRow = MdcToolbarRow;
    exports.MdcToolbarMenuIcon = MdcToolbarMenuIcon;
    exports.MdcToolbar = MdcToolbar;
    exports.MdcTypographyModule = MdcTypographyModule;
    exports.MdcTypography = MdcTypography;
    exports.MdcTypographyHeadline1 = MdcTypographyHeadline1;
    exports.MdcTypographyHeadline2 = MdcTypographyHeadline2;
    exports.MdcTypographyHeadline3 = MdcTypographyHeadline3;
    exports.MdcTypographyHeadline4 = MdcTypographyHeadline4;
    exports.MdcTypographyHeadline5 = MdcTypographyHeadline5;
    exports.MdcTypographyHeadline6 = MdcTypographyHeadline6;
    exports.MdcTypographySubtitle1 = MdcTypographySubtitle1;
    exports.MdcTypographySubtitle2 = MdcTypographySubtitle2;
    exports.MdcTypographyBody2 = MdcTypographyBody2;
    exports.MdcTypographyBody1 = MdcTypographyBody1;
    exports.MdcTypographyCaption = MdcTypographyCaption;
    exports.MdcTypographyButton = MdcTypographyButton;
    exports.MdcTypographyOverline = MdcTypographyOverline;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
